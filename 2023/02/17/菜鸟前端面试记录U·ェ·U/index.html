<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>菜鸟前端面试记录U·ェ·U | Lavender's blog</title><meta name="author" content="流泪猫猫头"><meta name="copyright" content="流泪猫猫头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍自己面试官你好，我叫任蓉，来自四川南充，目前研三，就读于重庆邮电大学软件工程专业，我这次应聘的岗位是前端开发工程师的岗位。 在本科阶段我主修了软件工程、数据结构、计算机网络等专业课程。在研究生阶段，我的研究方向为计算机视觉，目前已经发表一篇EI论文，另外还有一篇中文核心在投。 为了毕业进入前端的行业，我自学了前端的相关基础知识，并且拥有两段相关实习经历，第一段是在同程旅行公司的实习，在这段实习">
<meta property="og:type" content="article">
<meta property="og:title" content="菜鸟前端面试记录U·ェ·U">
<meta property="og:url" content="http://lavender321.github.com/2023/02/17/%E8%8F%9C%E9%B8%9F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95U%C2%B7%E3%82%A7%C2%B7U/index.html">
<meta property="og:site_name" content="Lavender&#39;s blog">
<meta property="og:description" content="介绍自己面试官你好，我叫任蓉，来自四川南充，目前研三，就读于重庆邮电大学软件工程专业，我这次应聘的岗位是前端开发工程师的岗位。 在本科阶段我主修了软件工程、数据结构、计算机网络等专业课程。在研究生阶段，我的研究方向为计算机视觉，目前已经发表一篇EI论文，另外还有一篇中文核心在投。 为了毕业进入前端的行业，我自学了前端的相关基础知识，并且拥有两段相关实习经历，第一段是在同程旅行公司的实习，在这段实习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-02-17T02:20:30.000Z">
<meta property="article:modified_time" content="2024-10-22T07:53:30.380Z">
<meta property="article:author" content="流泪猫猫头">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2022/10/08/k5M7H1NdmnZgtlY.png"><link rel="canonical" href="http://lavender321.github.com/2023/02/17/%E8%8F%9C%E9%B8%9F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95U%C2%B7%E3%82%A7%C2%B7U/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 流泪猫猫头","link":"链接: ","source":"来源: Lavender's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '菜鸟前端面试记录U·ェ·U',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-22 15:53:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Lavender's blog"><span class="site-name">Lavender's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">菜鸟前端面试记录U·ェ·U</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-17T02:20:30.000Z" title="发表于 2023-02-17 10:20:30">2023-02-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-22T07:53:30.380Z" title="更新于 2024-10-22 15:53:30">2024-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="菜鸟前端面试记录U·ェ·U"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="介绍自己"><a href="#介绍自己" class="headerlink" title="介绍自己"></a>介绍自己</h1><p>面试官你好，我叫任蓉，来自四川南充，目前研三，就读于重庆邮电大学软件工程专业，我这次应聘的岗位是前端开发工程师的岗位。</p>
<p>在本科阶段我主修了软件工程、数据结构、计算机网络等专业课程。在研究生阶段，我的研究方向为计算机视觉，目前已经发表一篇EI论文，另外还有一篇中文核心在投。</p>
<p>为了毕业进入前端的行业，我自学了前端的相关基础知识，并且拥有两段相关实习经历，第一段是在同程旅行公司的实习，在这段实习中，我主要参与了<code>Martix</code>项目管理系统的迭代开发和轻任务多维数据平台的开发这两个项目。在<code>Martix</code>项目的开发过程中，我主要负责实现通过<code>qiankun</code>搭建微前端应用，以及完成子应用的任务管理界面和甘特图功能、文件上传这一块需求开发，在轻任务多维数据这一块主要负责个人代办事项和团队待办事项的开发，以及设计导入模板。</p>
<p>项目采用了模块化的设计和Websocket通信，提供强大的实时更新和协作能力，支持多种视图类型，包含个人待办事项、团队待办事项和模板库，通过引入自定义待办事项和丰富的模板库，提升用户在项目管理、数据分析和团队协作方面的效率。</p>
<p>我的第二段实习是在完美世界公司，主要负责游戏AI-Partner心动剧场国际版的前端开发，在这个项目中，主要通过uniapp实现跨端开发，适配于PC端和H5界面，PC端是自己重新实现了一套VUE文件，这个项目是结合智能AI技术和创建的NPC互动的聊天游戏，为了收集用户的喜好，然后手动实现了一部分的埋点操作。在此期间，我也负责了这个游戏后台管理系统和灵思剧场小程序的开发，后台管理系统主要是管理白名单、黑名单，对游戏玩家和NPC角色违规行为的处理，比如一些言论之类的。灵思剧场小程序是AI-Partner的衍生有声小说。</p>
<p>通过这两段实习经历，我不仅熟悉了与后端的协同工作流程，还学到了如何高效解决项目开发过程遇到的困难，还培养了良好的沟通能力。我相信，这些宝贵的经验将为我未来的职业发展奠定坚实基础，并帮助我在新团队中快速融入并作出贡献。</p>
<p>以上是我的自我介绍，非常希望能够加入贵公司为公司创造一份价值。</p>
<h2 id="完美世界"><a href="#完美世界" class="headerlink" title="完美世界"></a>完美世界</h2><ol>
<li><p>开发AI-Partner心动剧场国际版，融合AI技术与社交互动，有效提升了平台的用户活跃度和充值率，显著增强了用户留存率和整体平台收益。</p>
</li>
<li><p>开发运营后台，实现用户和NPC、权限和内容配置等模块的管理，支持封号、申诉、公告发布等功能，提升了平台的运营效率和管理便捷性。</p>
</li>
<li><p>开发灵思剧场小程序，通过解析剧本动态展示有声小说章节内容，并通过AI动态聊天功能增强用户互动和沉浸感。</p>
</li>
<li><p>参与完美AI策略聚合平台的开发，整合OpenAI等大语言模型，提供AI对话、绘图和语音生成功能。负责智能对话模块，集成非流式和流式GPT策略，开发策略创建和管理功能。</p>
</li>
</ol>
<h3 id="AI-Partner"><a href="#AI-Partner" class="headerlink" title="AI-Partner"></a>AI-Partner</h3><blockquote>
<p><code>AI-Partner</code>心动剧场是一款面向海外市场的AI聊天游戏，支持<code>PC</code>端和<code>H5</code>端，结合先进的AI技术与丰富的社交互动功能。用户通过谷歌邮箱注册，创建和管理由<code>GPT、BERT</code>等AI模型驱动的<code>NPC</code>角色，进行个性化互动。游戏中设计了排行榜、动态主题切换、聊天背景音乐等功能，并集成了<code>Solana区块链</code>的<code>USDT支付</code>，支持用户进行虚拟货币的充值和购买。项目通过创新的社交互动设计，成功吸引了大量海外用户，显著提升了用户粘性和系统性能。</p>
</blockquote>
<h4 id="谷歌注册-OAuth2-0"><a href="#谷歌注册-OAuth2-0" class="headerlink" title="谷歌注册-OAuth2.0"></a>谷歌注册-OAuth2.0</h4><p>OAuth 2.0是一种授权框架，允许第三方应用访问用户的资源，而不暴露用户的凭证。它通过授权码和令牌的方式进行交互。</p>
<p>在 Google 登录流程中，通过 Google API控制台创建应用并获取 client_id，然后使用 Google 提供的 JavaScript 库通过 OAuth 2.0 授权机制获取用户的身份验证凭证（credential）。</p>
<p>设置了适当的回调 URI，确保用户登录成功后能够安全地重定向回应用程序，并使用令牌验证用户的身份。</p>
<h5 id="如何在前端实现-Google-登录的？"><a href="#如何在前端实现-Google-登录的？" class="headerlink" title="如何在前端实现 Google 登录的？"></a>如何在前端实现 Google 登录的？</h5><p>使用 Vue.js 框架来构建用户界面。在页面的 <template> 中，创建一个按钮，并使用 Google 提供的 window.google.accounts.id.renderButton 方法进行渲染，使用户能够通过点击该按钮触发 Google 登录。</p>
<p>我在 onMounted 钩子中调用 window.google.accounts.id.initialize 初始化 Google 登录服务，并设置 client_id 和回调函数 handleCredentialResponse，以便在用户登录后处理身份验证响应。</p>
<p>点击按钮后，会触发 window.google.accounts.id.prompt() 方法，这会弹出 Google 登录窗口让用户进行身份验证。</p>
<h5 id="如何在后端处理-Google-登录的？"><a href="#如何在后端处理-Google-登录的？" class="headerlink" title="如何在后端处理 Google 登录的？"></a>如何在后端处理 Google 登录的？</h5><p>用户登录后，Google 会返回一个身份验证令牌（JWT）。将这个令牌通过 API 请求发送到后端服务器，服务器会验证该令牌的有效性，并从中提取用户信息。</p>
<p>在后端，我使用 Google 的令牌验证 API 或 JWT 解码库来验证令牌的签名和有效性，确保令牌是来自 Google 的合法请求。</p>
<p>验证通过后，我会在服务器端创建用户的 session 或生成一个应用程序的访问令牌（token），并将其返回给前端，存储在setStorageSync。</p>
<h5 id="用户体验和界面设计"><a href="#用户体验和界面设计" class="headerlink" title="用户体验和界面设计"></a>用户体验和界面设计</h5><p>问题：你在设计登录流程时是如何考虑用户体验的？</p>
<p>我确保 Google 登录按钮在页面上清晰可见，并且通过 window.google.accounts.id.renderButton 方法选择合适的样式（如 pill 形状、图标等），提高用户的视觉感受。</p>
<p>为了减少用户登录的步骤，我设置了 auto_select 为 false，并确保在用户登录后立即重定向回原始页面，提升流畅的体验。</p>
<p>我还考虑到多设备兼容性，确保按钮在移动设备和桌面设备上都能正常显示和操作。</p>
<h5 id="如何测试-Google-登录功能的？部署时考虑了哪些问题？"><a href="#如何测试-Google-登录功能的？部署时考虑了哪些问题？" class="headerlink" title="如何测试 Google 登录功能的？部署时考虑了哪些问题？"></a>如何测试 Google 登录功能的？部署时考虑了哪些问题？</h5><p>我编写了单元测试来验证登录的核心逻辑，并通过模拟 Google API 响应来测试回调函数的正确性。</p>
<p>我使用集成测试确保登录流程在前后端交互中能够正常工作，同时使用真实环境中的 Google API 测试登录流程的完整性。</p>
<p>部署时，我确保所有的 OAuth 2.0 配置（如重定向 URI 和 client_id）在生产环境中正确配置，并设置了错误日志记录，以便监控任何登录失败或 API 调用异常。在开发过程中遇到的最大挑战是什么？你是如何解决的</p>
<p>我遇到的最大挑战是处理跨域资源共享（CORS）的问题。当后端和前端不在同一域时，Google 返回的令牌可能会被阻止。</p>
<p>为了解决这个问题，我在后端配置了 CORS 规则，允许特定的前端域访问 Google 登录 API，并确保在安全范围内的跨域访问。</p>
<h5 id="这个过程如何保证数据的安全？"><a href="#这个过程如何保证数据的安全？" class="headerlink" title="这个过程如何保证数据的安全？"></a>这个过程如何保证数据的安全？</h5><p>使用HTTPS；token合理存储：set-cookie: httpOnly；token设置过期时间，通过解析token的第二部分payload部分获取日期判断过期了没有</p>
<h4 id="如何判断设备是什么平台"><a href="#如何判断设备是什么平台" class="headerlink" title="如何判断设备是什么平台"></a>如何判断设备是什么平台</h4><p>项目使用的<code>Uniapp框架</code>进行开发，因此使用的<code>条件编译-ifdef H5</code>，不使用<code>Uniapp</code>开发的可以通过 <code>user-agent</code> 来判断平台类型。</p>
<blockquote>
<p><code>#ifdef</code> 和 <code>#ifndef</code>：在编译期间，用于选择性包含代码块。根据目标平台，如 H5、小程序、App 等，决定哪些代码应该被编译和执行。这里的<code>#ifdefH5</code>通过编译时的宏指令，仅在 Web 浏览器环境下执行。类似的编译指令也可以用于其他平台，如原生应用、微信小程序等。这种方法有助于在跨平台开发时有针对性地优化每个平台的功能和性能。</p>
</blockquote>
<h3 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h3><p>css+var定义的</p>
<p>CSS 变量 <code>--background-color</code> 和 <code>--text-color</code> 的值</p>
<h3 id="聊天页面跳转动画实现–基于原生css实现的动画过程-单例模式"><a href="#聊天页面跳转动画实现–基于原生css实现的动画过程-单例模式" class="headerlink" title="聊天页面跳转动画实现–基于原生css实现的动画过程-单例模式"></a>聊天页面跳转动画实现–基于原生css实现的动画过程-单例模式</h3><blockquote>
<p>动画是基于原生的javascript实现的，没有使用第三方动画库，减少项目的体积，更加轻量，比较精确控制动画的细节（位置、尺寸、透明度、速度等），负责实现某社交平台的发现页到聊天页面跳转的动画效果。用户点击发现页卡片时，卡片从点击位置动态展开，并过渡到全屏的聊天页面，形成自然流畅的动画体验。</p>
</blockquote>
<ul>
<li><p>Vue 动态渲染：通过 <code>createVNode </code>和 render 实现 Vue组件的动态挂载，实时渲染卡片内容，并与用户交互。</p>
</li>
<li><p>动画容器创建：使用 JavaScript 动态创建全屏覆盖的容器，并通过精确控制卡片的位置和尺寸，确保动画效果的流畅和一致性。</p>
</li>
<li><p>CSS 动画与 JavaScript 结合：动画主要通过 JavaScript 操控 DOM 元素的位置与大小，同时结合 CSS 过渡效果，增强用户体验。</p>
</li>
<li><p>单例模式：通过单例模式管理动画实例，确保在同一时刻只存在一个动画效果，避免重复创建动画实例导致性能下降和页面冲突。</p>
</li>
</ul>
<p>使用<code>requestAnimationFrame</code>对于需要精确控制每一帧的动画场景，是一种高效的方式，来控制每一帧的渲染，避免不必要的性能开销。</p>
<h4 id="为什么不使用setTimeout？"><a href="#为什么不使用setTimeout？" class="headerlink" title="为什么不使用setTimeout？"></a>为什么不使用<code>setTimeout</code>？</h4><h5 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a><code>requestAnimationFrame</code></h5><ul>
<li><strong>自动同步帧率</strong>：<code>requestAnimationFrame </code>会根据显示器的刷新率（通常是 60Hz，即每秒 60 帧）来调用回调函数。这意味着动画的帧率会自动与显示器的刷新率同步，从而提供更流畅的动画效果。</li>
<li><strong>流畅性</strong>：动画的更新频率与浏览器的重绘频率一致，避免了帧率不一致导致的卡顿或跳帧现象。</li>
<li>后台标签页优化：当页面处于后台标签页时，requestAnimationFrame 会暂停调用回调函数，从而节省 CPU 和电量。这是由浏览器自动处理的，无需开发者额外配置。</li>
<li>自动暂停：在页面不可见时，动画会自动暂停，避免了不必要的资源消耗。</li>
<li>布局计算优化：<code>requestAnimationFrame</code> 会在浏览器完成所有的布局计算和重绘操作之后再执行回调函数，从而避免不必要的布局抖动和重绘。</li>
<li>性能优化：由于回调函数在浏览器的重绘周期内执行，可以有效减少布局和重绘的次数，提高性能。</li>
<li>简化动画循环：通过递归调用 <code>requestAnimationFrame</code>，可以轻松实现动画循环，无需手动计算下一帧的时间间隔。</li>
</ul>
<h5 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h5><ul>
<li><p>不受帧率控制：setTimeout 只能设置一个固定的时间间隔（例如每 16.67 毫秒更新一次，以达到每秒 60 帧），但它无法确保回调函数会在浏览器的重绘周期内执行。</p>
</li>
<li><p>可能导致卡顿：由于浏览器的重绘频率和 setTimeout 的执行频率不一致，可能会导致动画卡顿或不流畅。</p>
</li>
<li><p>持续执行：即使页面处于后台标签页，setTimeout 仍会继续执行回调函数，导致不必要的资源消耗。</p>
</li>
<li><p>手动处理：需要开发者手动检测页面的可见性，并在页面不可见时暂停或停止动画。</p>
</li>
<li><p>可能导致布局抖动：setTimeout 的回调函数可能在浏览器的布局计算和重绘操作中途执行，导致额外的布局计算和重绘，影响性能。</p>
</li>
<li><p>手动计算时间间隔：需要手动计算下一帧的时间间隔，并在回调函数中使用 setTimeout 设置下一次执行的时间。</p>
</li>
</ul>
<blockquote>
<p> 虽然 setTimeout 也可以用来实现动画，但 <code>requestAnimationFrame</code> 提供了更高效和流畅的动画解决方案。它通过帧率同步、节省资源、避免布局抖动和简化动画循环，使得动画更加自然和高效。因此，在大多数情况下，<code>requestAnimationFrame</code> 是实现网页动画的更好选择</p>
</blockquote>
<h3 id="为什么需要使用-SSE-和-WebSocket-两种方法进行流式传输？"><a href="#为什么需要使用-SSE-和-WebSocket-两种方法进行流式传输？" class="headerlink" title="为什么需要使用 SSE 和 WebSocket 两种方法进行流式传输？"></a>为什么需要使用 SSE 和 WebSocket 两种方法进行流式传输？</h3><h5 id="不同的应用场景需求："><a href="#不同的应用场景需求：" class="headerlink" title="不同的应用场景需求："></a>不同的应用场景需求：</h5><p><code>SSE（Server-Sent Events）</code>—fetch</p>
<ul>
<li><p><strong>单向数据推送</strong>：适用于服务器需要向客户端推送更新的场景，比如新闻推送、社交媒体通知、实时数据更新等。</p>
</li>
<li><p><strong>简单实现</strong>：SSE 基于 HTTP 协议，客户端与服务器之间的连接管理相对简单，自动处理重连。</p>
</li>
<li><p><strong>轻量级</strong>：由于只需要服务器推送数据到客户端，SSE 在资源消耗和实现复杂度上都较低，适合那些无需复杂双向通信的场景。</p>
</li>
</ul>
<p><code>WebSocket</code></p>
<ul>
<li><p><strong>双向通信</strong>：适用于需要实时双向交互的场景，比如实时聊天、在线游戏、协同编辑等。</p>
</li>
<li><p><strong>低延迟</strong>：WebSocket 提供了更低的延迟，因为它在初次握手之后会保持一个持续的连接，适合需要高实时性的数据传输。</p>
</li>
<li><p><strong>数据类型丰富</strong>：支持传输文本和二进制数据，能够满足更多样化的数据传输需求。</p>
</li>
</ul>
<h5 id="实现和维护的复杂度："><a href="#实现和维护的复杂度：" class="headerlink" title="实现和维护的复杂度："></a>实现和维护的复杂度：</h5><p><code>SSE</code></p>
<ul>
<li><strong>实现简单</strong>：SSE 只需服务器端推送，客户端接收并处理消息，适合开发周期短、维护成本低的项目。</li>
<li><strong>内置自动重连</strong>：SSE 内置了自动重连机制，无需额外的心跳检测和重连逻辑，简化了开发。</li>
</ul>
<p><code>WebSocket</code></p>
<ul>
<li><strong>实现复杂</strong>：WebSocket 需要处理连接的建立、维护和关闭，需实现心跳机制和重连策略，适合对实时性和稳定性要求较高的应用。</li>
<li><strong>资源占用</strong>：由于 WebSocket 连接会保持长时间的持续连接，对服务器资源的管理要求较高。</li>
</ul>
<p>兼容性和环境限制：</p>
<p><code>SSE</code>	</p>
<ul>
<li><strong>兼容性好</strong>：SSE 在现代浏览器中有良好的兼容性，特别适用于 HTTP&#x2F;2 协议的支持。</li>
<li><strong>微信小程序环境</strong>：在微信小程序等特定环境中，SSE 的实现和使用可能更加方便和稳定。</li>
</ul>
<p><code>WebSocket</code></p>
<ul>
<li><strong>现代化特性</strong>：WebSocket 是现代浏览器和应用中的标准协议，在需要复杂交互的应用中表现出色。</li>
<li><strong>适应性强</strong>：在需要高频率双向数据交换的场景中，WebSocket 能提供更好的用户体验和性能。</li>
</ul>
<p>用户体验和性能优化：</p>
<p><code>SSE</code></p>
<ul>
<li><strong>低频率推送</strong>：适用于更新频率较低的场景，可以减少不必要的资源消耗，提升应用性能。</li>
<li><strong>用户体验</strong>：对于一些只需服务器端推送数据的应用，SSE 提供了足够的实时性和可靠性。</li>
</ul>
<p><code>WebSocket</code></p>
<ul>
<li><strong>高频率双向交互</strong>：适用于高频交互的场景，提供更好的实时性和互动性，增强用户体验。</li>
<li><strong>性能优化</strong>：通过保持长连接，减少了频繁建立连接的开销，提升了数据传输效率。</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>在我们的应用中，同时使用 SSE 和 WebSocket 是基于不同场景和需求的合理选择。SSE 适用于简单的单向数据推送，具有实现简单、资源消耗低的优点。而 WebSocket 则适用于需要低延迟双向通信的复杂场景，能够提供更好的实时性和交互性。通过合理选择和组合这两种技术，我们能够在不同的应用场景中实现最佳的用户体验和性能优化。</p>
<h4 id="流式输出结合webSocket心跳机制"><a href="#流式输出结合webSocket心跳机制" class="headerlink" title="流式输出结合webSocket心跳机制"></a>流式输出结合webSocket心跳机制</h4><p>使用的是<code>SSE--Uniapp</code>和<code>Websocket--PC</code></p>
<ul>
<li><strong>SSE</strong>：适用于服务器向客户端推送数据的场景，使用简单，基于HTTP协议，自动重连，但只能传输文本数据，通信是单向的。基于 <code>uni-app</code> 和 <code>fetch-event-source</code> 的请求封装，支持普通 HTTP 请求、文件上传、流式请求（使用 SSE），并处理了一些常见的请求逻辑，如鉴权、错误处理、登录跳转等。</li>
<li><strong>WebSocket</strong>：适用于需要低延迟双向通信的实时应用，可以传输文本和二进制数据，全双工通信，但实现相对复杂，且需要处理连接的管理和维护。</li>
</ul>
<p>剧情聊天推送使用的是SSE，</p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ol>
<li>onopen</li>
<li>onmessage</li>
<li>onclose</li>
<li>onerror</li>
</ol>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ol>
<li>send</li>
<li>close</li>
</ol>
<h5 id="webSocket心跳机制"><a href="#webSocket心跳机制" class="headerlink" title="webSocket心跳机制"></a>webSocket心跳机制</h5><h3 id="SSE和websocket的区别"><a href="#SSE和websocket的区别" class="headerlink" title="SSE和websocket的区别"></a>SSE和websocket的区别</h3><p>SSE（Server-Sent Events）和 WebSocket 都是用于在客户端和服务器之间进行双向通信或实时数据传输的技术，但它们有一些关键的区别。下面我从多个角度详细解释这两者的差异：</p>
<h3 id="1-通信方向"><a href="#1-通信方向" class="headerlink" title="1. 通信方向"></a>1. <strong>通信方向</strong></h3><ul>
<li><p><strong>SSE (Server-Sent Events)</strong>:</p>
<ul>
<li>单向通信：服务器向客户端推送数据，但客户端无法通过同一连接发送数据到服务器。</li>
<li>客户端通过 <code>EventSource</code> 与服务器建立连接，服务器可以持续推送数据到客户端。</li>
</ul>
</li>
<li><p><strong>WebSocket</strong>:</p>
<ul>
<li>双向通信：客户端和服务器可以通过同一个 WebSocket 连接相互发送数据。既可以从服务器推送数据到客户端，也可以从客户端发送数据到服务器。</li>
</ul>
</li>
</ul>
<h3 id="2-协议层面"><a href="#2-协议层面" class="headerlink" title="2. 协议层面"></a>2. <strong>协议层面</strong></h3><ul>
<li><p><strong>SSE</strong>:</p>
<ul>
<li>使用的是 <strong>HTTP 协议</strong>，具体是 HTTP&#x2F;1.1 长连接。建立连接后，服务器可以不断发送数据，但这个连接仍然是单向的（服务器到客户端）。</li>
<li>SSE 在 HTTP 请求的头部声明 <code>text/event-stream</code> 来表示这是一个持续发送事件的连接。</li>
</ul>
</li>
<li><p><strong>WebSocket</strong>:</p>
<ul>
<li>使用的是 <strong>独立的 WebSocket 协议</strong>。WebSocket 是在 HTTP 握手之后升级协议，从 HTTP 切换到 WebSocket 协议。</li>
<li>握手成功后，WebSocket 在底层是基于 TCP 的全双工通信。</li>
</ul>
</li>
</ul>
<h3 id="3-连接特性"><a href="#3-连接特性" class="headerlink" title="3. 连接特性"></a>3. <strong>连接特性</strong></h3><ul>
<li><p><strong>SSE</strong>:</p>
<ul>
<li><strong>单向连接</strong>：只能由服务器推送事件到客户端。</li>
<li><strong>自动重连</strong>：SSE 内建支持自动重连机制，当连接断开时，浏览器会自动尝试重新连接。</li>
<li><strong>Event ID 支持</strong>：SSE 可以追踪事件的 ID，如果连接断开，可以从最后一个 ID 继续接收数据，确保不会丢失消息。</li>
</ul>
</li>
<li><p><strong>WebSocket</strong>:</p>
<ul>
<li><strong>全双工连接</strong>：支持双向实时通信，客户端和服务器都可以通过同一连接发送和接收消息。</li>
<li><strong>需要手动处理重连</strong>：如果 WebSocket 连接断开，开发者需要手动处理重连逻辑。</li>
</ul>
</li>
</ul>
<h3 id="4-性能与复杂度"><a href="#4-性能与复杂度" class="headerlink" title="4. 性能与复杂度"></a>4. <strong>性能与复杂度</strong></h3><ul>
<li><p><strong>SSE</strong></p>
<ul>
<li><strong>轻量级</strong>：由于是基于 HTTP 长连接的单向通信，SSE 的实现相对简单，特别适合服务器频繁向客户端推送更新的场景。</li>
<li><strong>消息格式</strong>：SSE 发送的消息是文本格式（<code>text/event-stream</code>），比较简单，不支持二进制数据。</li>
<li><strong>适合推送数据的场景</strong>：如社交媒体通知、股票价格更新、实时消息推送等。</li>
</ul>
</li>
<li><p><strong>WebSocket</strong></p>
<ul>
<li><strong>更复杂但更灵活</strong>：支持双向通信，同时可以发送文本和二进制数据，适合需要高频交互的场景。</li>
<li><strong>消息格式</strong>：支持传输二进制数据和文本数据，因此适合需要传输大量数据的场景（如游戏、图像、视频流等）。</li>
<li><strong>适合实时互动场景</strong>：如在线游戏、聊天应用、股票交易平台等，客户端和服务器频繁需要双向通信的场景。</li>
</ul>
</li>
</ul>
<h3 id="5-浏览器支持"><a href="#5-浏览器支持" class="headerlink" title="5. 浏览器支持"></a>5. <strong>浏览器支持</strong></h3><ul>
<li><p><strong>SSE</strong>:</p>
<ul>
<li>原生支持度较好：大部分现代浏览器都支持 SSE，且兼容性较好（IE 不支持，但 Edge 支持）。</li>
</ul>
</li>
<li><p><strong>WebSocket</strong>:</p>
<ul>
<li>浏览器支持广泛：几乎所有现代浏览器都支持 WebSocket。</li>
</ul>
</li>
</ul>
<h3 id="6-使用场景总结"><a href="#6-使用场景总结" class="headerlink" title="6. 使用场景总结"></a>6. <strong>使用场景总结</strong></h3><ul>
<li><p><strong>SSE</strong>：</p>
<ul>
<li>适用于<strong>服务器单向推送数据</strong>的应用场景，例如：<ul>
<li>实时新闻更新</li>
<li>股票行情</li>
<li>社交网络通知</li>
</ul>
</li>
<li>不适合需要客户端发送大量数据或需要双向实时通信的场景。</li>
</ul>
</li>
<li><p><strong>WebSocket</strong>：</p>
<ul>
<li>适用于<strong>双向实时通信</strong>的场景，例如：<ul>
<li>在线多人游戏</li>
<li>实时聊天应用</li>
<li>视频会议或数据密集型应用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-连接数量的处理"><a href="#7-连接数量的处理" class="headerlink" title="7. 连接数量的处理"></a>7. <strong>连接数量的处理</strong></h3><ul>
<li><p><strong>SSE</strong>：</p>
<ul>
<li>每个客户端与服务器之间使用一个 HTTP 长连接。对于需要处理大量客户端连接的服务器而言，相对来说负担较小。</li>
</ul>
</li>
<li><p><strong>WebSocket</strong>：</p>
<ul>
<li>WebSocket 是基于 TCP 连接的，因此服务器需要为每个客户端维护一个独立的 TCP 连接。如果连接数巨大，可能会加重服务器的负担，尤其是没有正确优化时。</li>
</ul>
</li>
</ul>
<h3 id="8-浏览器-API"><a href="#8-浏览器-API" class="headerlink" title="8. 浏览器 API"></a>8. <strong>浏览器 API</strong></h3><ul>
<li><p><strong>SSE</strong>:</p>
<ul>
<li><p>客户端代码通常使用 <code>EventSource</code> 对象来处理 SSE：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;/events&#x27;</span>);</span><br><span class="line">eventSource.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>WebSocket</strong>:</p>
<ul>
<li><p>客户端代码通常使用 <code>WebSocket</code> 对象来处理 WebSocket 通信：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line">socket.<span class="title function_">send</span>(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>如果只需要 <strong>服务器向客户端发送数据</strong>，而不需要客户端频繁发回数据，<strong>SSE</strong> 是较为简单且合适的选择。</li>
<li>如果需要 <strong>双向实时通信</strong>，例如在线聊天或游戏，<strong>WebSocket</strong> 是更灵活且功能更强大的选择。</li>
</ul>
<h3 id="网络请求封装"><a href="#网络请求封装" class="headerlink" title="网络请求封装"></a>网络请求封装</h3><p>SSE和小程序的流式输出</p>
<p>微信小程序使用二进制数据流（arraybuffer）做分块传输</p>
<p>SSE长连接（Connection: keep-alive），减少频繁建立连接的开销，提升传输效率。</p>
<h3 id="埋点-日志记录"><a href="#埋点-日志记录" class="headerlink" title="埋点-日志记录"></a>埋点-日志记录</h3><p>使用window.dotLog进行数据收集，在需要捕获用户行为的地方调用window.dotLog</p>
<blockquote>
<p>window.dotLog &#x3D; dotLog 这行代码将 dotLog 函数挂载到全局的 window 对象上，以便在整个应用的任何地方都可以方便地调用这个函数，通常这是为埋点服务的。埋点是指在特定位置（如页面加载、按钮点击等）记录用户行为或应用事件，以便在后期进行分析和优化。</p>
</blockquote>
<p>埋点的目的是追踪用户行为，如页面点击、表单提交、滚动等。这些信息可以用于用户行为分析、A&#x2F;B 测试、用户体验优化等。</p>
<h3 id="项目的性能优化"><a href="#项目的性能优化" class="headerlink" title="项目的性能优化"></a>项目的性能优化</h3><p>首页图片的预加载，使用<code>Promise.all</code>进行网络的并行预加载，设置了最大的并发进行控制，及时的销毁最上面的元素，使用虚拟列表结合懒加载</p>
<h4 id="预加载图片资源时有哪些性能优化措施？"><a href="#预加载图片资源时有哪些性能优化措施？" class="headerlink" title="预加载图片资源时有哪些性能优化措施？"></a>预加载图片资源时有哪些性能优化措施？</h4><ul>
<li><strong>并行加载</strong>：通过 <code>Promise.all</code> 来并行预加载所有图片，这能够最大化利用网络带宽，加快加载速度。</li>
<li><strong>进度反馈</strong>：通过 <code>scheduleChange</code> 回调函数，将加载进度实时反馈给调用方，可以在页面上展示加载动画或进度条，提升用户体验。</li>
<li><strong>错误处理</strong>：虽然 <code>img.onerror</code> 捕捉了加载错误，但目前代码中没有针对错误的具体处理措施，这可能是未来的一个改进点。这段代码已经包含了一些性能优化的措施：</li>
<li><strong>并行加载</strong>：通过 <code>Promise.all</code> 来并行预加载所有图片，这能够最大化利用网络带宽，加快加载速度。</li>
<li><strong>进度反馈</strong>：通过 <code>scheduleChange</code> 回调函数，将加载进度实时反馈给调用方，可以在页面上展示加载动画或进度条，提升用户体验。</li>
<li><strong>错误处理</strong>：虽然 <code>img.onerror</code> 捕捉了加载错误，但目前代码中没有针对错误的具体处理措施，这可能是未来的一个改进点。</li>
</ul>
<h4 id="如果预加载的图片非常多，可能会产生什么性能问题？如何改进？"><a href="#如果预加载的图片非常多，可能会产生什么性能问题？如何改进？" class="headerlink" title="如果预加载的图片非常多，可能会产生什么性能问题？如何改进？"></a>如果预加载的图片非常多，可能会产生什么性能问题？如何改进？</h4><p>当预加载的图片数量非常多时，使用 <code>Promise.all</code> 并行加载所有图片可能会带来以下问题：</p>
<ul>
<li><p><strong>网络压力</strong>：瞬间发送大量并发请求可能会导致网络拥塞，尤其是在网络带宽有限的情况下。</p>
</li>
<li><p><strong>浏览器连接限制</strong>：浏览器对于同一域名的并发请求数是有限制的，超过限制的请求会进入等待队列，反而可能降低整体加载效率。</p>
</li>
<li><p><strong>并发控制</strong>：通过设置最大并发数，限制同时发出的请求数量，从而控制加载节奏，避免瞬间大量请求。例如，可以使用自定义的并发控制函数来实现。</p>
</li>
</ul>
<h4 id="如何检测和处理预加载失败的图片？有什么方法可以确保加载的图片质量和加载的可靠性？"><a href="#如何检测和处理预加载失败的图片？有什么方法可以确保加载的图片质量和加载的可靠性？" class="headerlink" title="如何检测和处理预加载失败的图片？有什么方法可以确保加载的图片质量和加载的可靠性？"></a>如何检测和处理预加载失败的图片？有什么方法可以确保加载的图片质量和加载的可靠性？</h4><p>当前代码使用 <code>img.onerror</code> 来捕获图片加载失败，但没有进一步的处理。如果某张图片加载失败，可以采取以下策略：</p>
<ul>
<li><strong>重试机制</strong>：对于加载失败的图片，可以实现自动重试机制，尝试重新加载，增加成功率。</li>
<li><strong>加载占位符图片</strong>：如果多次重试失败，可以为该图片展示一个默认的占位符，避免页面空白，改善用户体验。</li>
<li><strong>错误日志记录</strong>：可以将加载失败的图片 URL 记录下来，用于后续的排查和修复。</li>
</ul>
<h4 id="你如何判断已经加载的图片是否需要重新加载？可以如何进一步避免重复加载？"><a href="#你如何判断已经加载的图片是否需要重新加载？可以如何进一步避免重复加载？" class="headerlink" title="你如何判断已经加载的图片是否需要重新加载？可以如何进一步避免重复加载？"></a>你如何判断已经加载的图片是否需要重新加载？可以如何进一步避免重复加载？</h4><p>为了避免重复加载已经成功加载过的图片，可以利用浏览器的缓存机制。以下是具体的优化方法：</p>
<ul>
<li>**使用 <code>img.complete</code>**：在每次加载图片之前，先检查图片是否已经被浏览器缓存。如果图片已经加载过并缓存，可以直接使用缓存，避免重复加载。</li>
<li><strong>基于 URL 缓存机制</strong>：在更复杂的场景中，可以实现 URL 层面的缓存管理，记录每个已加载图片的 URL，防止重复加载同一张图片。</li>
</ul>
<h4 id="一直往下滑到底部，图片会不会加载？"><a href="#一直往下滑到底部，图片会不会加载？" class="headerlink" title="一直往下滑到底部，图片会不会加载？"></a>一直往下滑到底部，图片会不会加载？</h4><p>一直往下滑会造成内存占用增加，带宽消耗</p>
<p>在处理大量数据时，主要面临的挑战包括：</p>
<ul>
<li><strong>内存占用</strong>：加载和渲染十万条数据会消耗大量的内存，导致页面卡顿甚至崩溃。</li>
<li><strong>渲染性能</strong>：如果页面不断渲染大量 DOM 元素，尤其是带图片的元素，会导致性能瓶颈。</li>
<li><strong>图片资源管理</strong>：图片在内存中的占用是非常高的，尤其是当用户滚动时，图片资源的管理必须谨慎处理。</li>
</ul>
<h5 id="虚拟列表（Virtual-Scrolling）"><a href="#虚拟列表（Virtual-Scrolling）" class="headerlink" title="虚拟列表（Virtual Scrolling）"></a>虚拟列表（Virtual Scrolling）</h5><p><strong>概念</strong>：虚拟列表技术是处理长列表渲染的最佳实践之一。它只渲染当前可视区域的内容，其他不可见部分的 DOM 节点则不会被渲染或保留在内存中。对于十万条数据，虚拟列表能显著减少页面的内存占用和 DOM 渲染的开销。</p>
<ul>
<li>**React 的 <code>react-window</code> 或 <code>react-virtualized</code>**：这些库专为长列表的虚拟化而设计，它们只会渲染当前可见部分的元素，并随着用户滚动动态更新可见区域的 DOM。</li>
<li>**Vue 的 <code>vue-virtual-scroller</code>**：Vue 中也有类似的库用于虚拟化长列表。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FixedSizeList</span> <span class="keyword">as</span> <span class="title class_">List</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-window&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Row</span> = (<span class="params">&#123; index, style &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Row &#123;index&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">List</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">height</span>=<span class="string">&#123;500&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">itemCount</span>=<span class="string">&#123;100000&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">itemSize</span>=<span class="string">&#123;35&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">width</span>=<span class="string">&#123;300&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;Row&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">List</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>只渲染当前可视区域的内容，显著减少 DOM 节点的数量。</li>
<li>动态管理 DOM 元素的创建与销毁，大幅降低内存占用。</li>
</ul>
<h5 id="按需数据加载"><a href="#按需数据加载" class="headerlink" title="按需数据加载"></a>按需数据加载</h5><p>对于十万条数据，不应该一次性加载到页面中。可以采用<strong>按需加载</strong>的策略，结合分页或滚动加载数据，逐步获取数据。</p>
<ul>
<li><strong>分页加载</strong>：每次加载一小部分数据（例如 100 条或 500 条），随着用户的滚动逐步加载更多数据。</li>
<li><strong>IntersectionObserver + Infinite Scroll</strong>：可以通过 <code>IntersectionObserver</code> 监测用户的滚动，当用户接近底部时自动加载更多数据。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> page = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loadMoreData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 调用 API 获取更多数据</span></span><br><span class="line">  <span class="title function_">fetchData</span>(page).<span class="title function_">then</span>(<span class="function"><span class="params">newData</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">appendDataToList</span>(newData);</span><br><span class="line">    page++;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entries[<span class="number">0</span>].<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">    <span class="title function_">loadMoreData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">threshold</span>: <span class="number">1.0</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sentinel = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#sentinel&#x27;</span>); <span class="comment">// 滚动到的底部检测点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(sentinel);</span><br></pre></td></tr></table></figure>

<h5 id="图片懒加载与资源回收"><a href="#图片懒加载与资源回收" class="headerlink" title="图片懒加载与资源回收"></a>图片懒加载与资源回收</h5><p>对于图片资源的管理，需要结合<strong>懒加载</strong>和<strong>销毁</strong>策略，确保当前只加载可见的图片，并且当图片滚出可视区域时释放内存。</p>
<ul>
<li><strong>懒加载图片</strong>：仅当图片出现在视口中时，才加载它。可以使用 <code>IntersectionObserver</code> 实现图片的懒加载。</li>
<li><strong>资源回收</strong>：对于已经滚出视口且长时间不可见的图片，应该销毁它们并释放内存。可以将 <code>src</code> 设置为空或移除 DOM 节点，确保不会占用多余的内存。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> images = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;img[data-src]&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> img = entry.<span class="property">target</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span>;</span><br><span class="line">      observer.<span class="title function_">unobserve</span>(img); <span class="comment">// 加载后不再监听</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      img.<span class="property">src</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 当图片滚出可视区域时，释放图片资源</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">images.<span class="title function_">forEach</span>(<span class="function"><span class="params">img</span> =&gt;</span> observer.<span class="title function_">observe</span>(img));</span><br></pre></td></tr></table></figure>

<h5 id="节流与防抖"><a href="#节流与防抖" class="headerlink" title="节流与防抖"></a>节流与防抖</h5><p>为了防止过多的滚动事件导致频繁的渲染和数据加载，可以对滚动事件进行<strong>节流（throttle）</strong>或<strong>防抖（debounce）</strong>处理。这样可以确保只有当用户停止滚动或滚动一段距离时，才会触发新的渲染和加载逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">func, limit</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> lastFunc;</span><br><span class="line">  <span class="keyword">let</span> lastRan;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!lastRan) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      lastRan = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(lastFunc);</span><br><span class="line">      lastFunc = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="title class_">Date</span>.<span class="title function_">now</span>() - lastRan) &gt;= limit) &#123;</span><br><span class="line">          func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">          lastRan = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, limit - (<span class="title class_">Date</span>.<span class="title function_">now</span>() - lastRan));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="title function_">throttle</span>(handleScroll, <span class="number">200</span>));</span><br></pre></td></tr></table></figure>

<h5 id="是否需要销毁最开始的图片？"><a href="#是否需要销毁最开始的图片？" class="headerlink" title="是否需要销毁最开始的图片？"></a>是否需要销毁最开始的图片？</h5><p><strong>应该销毁最开始的图片资源</strong>，但要有一个合理的策略。</p>
<ol>
<li><strong>内存优化</strong>：由于图片占用的内存较大，长时间保留不可见的图片会导致内存使用不断增加。因此，<strong>不可见的图片应该销毁</strong>，从而释放内存。</li>
<li><strong>重新加载</strong>：当用户返回顶部时，应该能够重新加载那些已经销毁的图片。可以通过懒加载的方式重新加载已经滚出视口并被销毁的图片。</li>
</ol>
<h4 id="合理的图片销毁策略："><a href="#合理的图片销毁策略：" class="headerlink" title="合理的图片销毁策略："></a>合理的图片销毁策略：</h4><ul>
<li><strong>滚出视口后延迟销毁</strong>：不要立即销毁刚刚滚出视口的图片，而是可以延迟一段时间再进行销毁。这是为了防止用户稍后返回时，频繁加载和卸载图片造成卡顿。</li>
<li><strong>缓存重要内容</strong>：对于一些关键图片或内容，可以通过缓存机制保留在内存中，以免频繁销毁和重新加载。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在处理包含大量数据（如十万条）的页面时，性能优化的关键是：</p>
<ul>
<li><strong>虚拟列表</strong>：通过虚拟化技术，只渲染当前可视区域，减少 DOM 节点。</li>
<li><strong>按需加载数据</strong>：采用分页和滚动加载策略，避免一次性加载所有数据。</li>
<li><strong>懒加载和销毁图片</strong>：通过懒加载只加载可见图片，并在滚出视口后延迟销毁以节省内存。</li>
<li><strong>节流与防抖</strong>：通过节流或防抖技术，优化滚动事件的触发频率，避免频繁触发渲染和加载。</li>
</ul>
<h4 id="HEAD取代Get方法"><a href="#HEAD取代Get方法" class="headerlink" title="HEAD取代Get方法"></a>HEAD取代Get方法</h4><h2 id="完美聚合平台"><a href="#完美聚合平台" class="headerlink" title="完美聚合平台"></a>完美聚合平台</h2><blockquote>
<p>完美AI策略聚合平台通过整合多个主流大语言模型（如 OpenAI、阿里通义千问等），为用户提供全面的 AI 功能支持，包括对话、绘图和生成语音等，项目主要涵盖四大模块：模型应用、工具类、游戏和虚拟角色。平台面向公司用户，帮助提升生产效率。</p>
</blockquote>
<p>在该项目中，我主要负责流式传输的整体架构设计与实现，包括fetchEventSource的集成及其与前端显示的无缝衔接。我实现了消息接收后的数据处理逻辑，确保返回的流数据能够实时展示并保持流畅的用户体验。此外，我还设计了中止控制功能，通过 AbortController实现对流请求的即时取消，并在系统内加入了错误处理机制和状态管理，确保流式传输的稳定性和健壮性。在用户界面方面，我优化了滚动条的自动更新，使得用户能够即时查看到最新生成的内容，显著提升了交互体验。</p>
<h4 id="如何处理流式请求？"><a href="#如何处理流式请求？" class="headerlink" title="如何处理流式请求？"></a>如何处理流式请求？</h4><blockquote>
<p>实现了一个基于 fetch-event-source 的流式请求。这个实现方式利用了 Server-Sent Events (SSE)来处理流式数据传输，接收服务器推送的数据流；在请求头添加Authorization携带用户的token进行身份验证；根据不同的状态码进行处理，比如跳转登陆页面，公告等。</p>
</blockquote>
<h4 id="fetchEventSource配置"><a href="#fetchEventSource配置" class="headerlink" title="fetchEventSource配置"></a>fetchEventSource配置</h4><ul>
<li><p>url: 请求的完整 URL。</p>
<ul>
<li>method: HTTP 请求方法，这里使用 POST。</li>
<li>headers: 请求头，包含 Content-Type 和 Authorization。</li>
<li>body: 请求体，使用 JSON.stringify 将数据序列化。</li>
<li>openWhenHidden: 允许在页面隐藏时保持连接。</li>
<li>onmessage: 当服务器发送消息时的回调函数，处理接收到的数据。</li>
<li>onclose: 当连接关闭时的回调函数，处理连接关闭的逻辑。</li>
</ul>
</li>
<li><p>回调函数</p>
<ul>
<li>callback: 处理每条消息的回调函数。</li>
<li>close: 处理连接关闭的回调函数（如果提供），在连接关闭或者出错的时候，使用自动重试机制</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">stream</span> = <span class="function">(<span class="params">url: string, data: any, callback: (val: any) =&gt; <span class="keyword">void</span>, close?: () =&gt; <span class="keyword">void</span>, token = store.user.token</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetchEventSource</span>(<span class="string">`<span class="subst">$&#123;process.env.baseUrl&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,      <span class="title class_">Authorization</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>    &#125;,    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data),    <span class="attr">openWhenHidden</span>: <span class="literal">true</span>,    <span class="title function_">onmessage</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(e)</span><br><span class="line">    &#125;,    <span class="title function_">onclose</span>(<span class="params"></span>) &#123;</span><br><span class="line">      close &amp;&amp; <span class="title function_">close</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在处理流式输出的稳定性时，通常会遇到以下几个主要挑战：网络波动、数据延迟、输出流中断以及不稳定的模型响应</p>
<p>使用 WebSocket 进行实时通讯： WebSocket 提供了双向通信的能力，可以确保服务器和客户端之间的实时数据传输。这对于流式输出尤其重要，因为它能够减少延迟，提供稳定的数据流。相比传统的 HTTP 轮询，WebSocket 更高效且延迟更低。</p>
<p>数据缓冲与重试机制： 在流式输出的过程中，可以引入数据缓冲机制，确保数据能够有序且完整地输出。如果网络波动导致流式输出中断，可以使用重试机制来重新请求未完成的部分，保证用户体验不受影响。</p>
<p>设置超时与断开重连机制： 为了避免网络问题导致长时间等待或流式数据丢失，建议在客户端设置超时机制，一旦超过指定时间没有收到数据，就主动重连服务器。这样可以在网络短暂中断后，恢复流式输出的连续性。</p>
<p>逐步加载和流式传输优化： 当处理流式 GPT 模型时，可以分批次逐步加载模型生成的内容，而不是等待整个输出完成后再传输。这种分块式的流数据传输可以大大提升用户体验，避免长时间等待。</p>
<p>带宽和网络优化： 流式传输对网络带宽要求较高，因此可以通过优化传输协议或压缩传输的数据包，减少带宽占用，增强稳定性。</p>
<p>异步处理与多线程： 在前端实现中，可以采用异步处理或者多线程技术来处理接收到的流式数据，确保数据在接收到时就能被即时渲染，而不需要等待整个流式输出的完成。</p>
<p>流数据的分片与合并： 对于较大的数据流，可以将其拆分成小块进行传输，客户端接收到小块数据后立即渲染，这样能提升实时响应速度，降低数据丢失或超时的风险。</p>
<p>状态监控与回退机制： 实时监控流式输出的状态，如果检测到输出过程不稳定或中断，可以立即触发回退机制，通知用户进行重试，或者从最后一个接收的有效输出开始重新连接数据流。</p>
<h4 id="处理流式"><a href="#处理流式" class="headerlink" title="处理流式"></a>处理流式</h4><p>发送请求：根据 props.strategy.stream 判断是否采用流式传输，如果是流式传输，则使用 fetchEventSource 进行数据的流式获取。</p>
<p>流式处理：</p>
<p>使用 fetchEventSource 发起 POST 请求，请求的数据通过流式输出方式返回。</p>
<p>在 onmessage 回调函数中处理每一段流数据，根据返回的数据类型（如 text、audio 等）动态更新 dialogue 列表，并通过滚动条的更新（scrollBottom()）确保页面自动滚动到最新内容。</p>
<p>通过 requestId 确保每个流的消息顺序正确，并处理可能的重复消息或延迟消息。</p>
<p>错误处理：</p>
<p>在 onopen、onclose 和 onerror 回调中进行相应的连接、关闭和错误处理，确保流在出现异常时可以正确中止并反馈给用户。</p>
<h4 id="关键的流式稳定性优化"><a href="#关键的流式稳定性优化" class="headerlink" title="关键的流式稳定性优化"></a>关键的流式稳定性优化</h4><ul>
<li><p>重试机制与中止控制：通过 AbortController 实现了对流式请求的中止控制，用户可以在需要时中止请求，或者在网络问题出现时取消请求。处理了 requestId 的匹配逻辑，确保流在处理时不会因为前后请求的混淆导致输出错误。</p>
</li>
<li><p>逐步加载和数据拼接：onmessage 中对返回的流数据进行了处理，通过判断返回数据类型进行拼接和内容追加，特别是对 text 类型的数据，通过累加 value 进行逐步渲染，保证流式数据的顺滑展示。</p>
</li>
<li><p>连接与状态管理：在 onopen 中判断连接状态并设置 streamChatEnd，确保流式传输的状态正确维护。在 onclose 和 onerror 中根据 requestId 检查当前流的状态，防止错误处理遗漏或误判，确保用户能够得到及时的反馈。</p>
</li>
<li><p>滚动条与界面更新：通过 scrollBottom() 保证页面的自动滚动，使得流式输出的内容能够即时展现给用户，提高了用户体验。</p>
</li>
</ul>
<h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><ul>
<li>延时与节流控制：在高频率的 onmessage 更新中，可以引入节流机制，避免页面的频繁更新导致的卡顿现象。</li>
<li>多策略并行处理：考虑是否会有多个策略同时运行的情况，必要时可以对 requestId 处理逻辑进行更加精细的管理。</li>
<li>重连机制：目前的实现较为基础，如果需要更高的稳定性，建议加入自动重连机制，在流意外中断时自动尝试重新连接。</li>
</ul>
<h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><p>使用CancelToken创建取消令牌，再发起请求的时候传递给Axios—Axios</p>
<p>使用AbortController 创建一个控制器，用于取消请求。—Fetch</p>
<h2 id="Martix一站式开发"><a href="#Martix一站式开发" class="headerlink" title="Martix一站式开发"></a>Martix一站式开发</h2><p>负责Martix项目管理平台和轻任务协作数据管理平台完成前端业务的开发，Martix的项目进行了第二版本的性能优化，首页性能提高到170ms以内，对轻任务进行个人待办事项和团队待办事项的开发。</p>
<h4 id="微前端–qiankun"><a href="#微前端–qiankun" class="headerlink" title="微前端–qiankun"></a>微前端–qiankun</h4><p>生命周期</p>
<p>如何做的样式隔离，它的原理是什么？</p>
<p>子应用间的通信</p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>服务端渲染，减少不必要的服务端渲染，</p>
<p>动态加载子应用，使用dynamic动态导入进行按需加载资源</p>
<p>v-if和v-show</p>
<p>watch合理使用监听状态，使用computed代替watch</p>
<p>按需加载+懒加载+虚拟列表</p>
<ol>
<li>组件懒加载</li>
<li>路由懒加载</li>
</ol>
<p>keep-alive</p>
<p>分片上传+断点续传</p>
<p>vuex</p>
<p>主子应用通信</p>
<p>props和EventBus</p>
<p>尽量使用事件驱动方式触发主子应用通信，避免频繁数据同步</p>
<h2 id="轻任务"><a href="#轻任务" class="headerlink" title="轻任务"></a>轻任务</h2><blockquote>
<p>基于ApiTable开源的实时协作数据管理平台，允许用户创建、管理和共享数据表、表单和仪表板。提供了强大的数据操作和协作功能。支持多种视图类型（画廊、日历、多维表格、看板等）和扩展性，包含个人待办事项、团队待办事项和模板库，通过引入自定义待办事项和丰富的模板库，极大提升了用户在项目管理、数据分析和团队协作方面的效率。</p>
</blockquote>
<p>在<code>AI-Partner</code>心动剧场项目中，我主要负责了多个核心模块的开发和优化。包括实现NPC角色的展示与互动功能，集成GPT、BERT等AI模型，提供智能对话体验；设计并开发了用户注册和登录功能，使用<code>Google OAuth 2.0</code>认证简化用户流程，并通过<code>AutoLogin</code>功能优化了用户体验。同时，我还负责了动态主题切换功能，确保跨设备的无缝体验，并提升了页面渲染性能。此外，成功集成了Solana区块链USDT支付系统，保证了虚拟货币交易的安全性和高效性，支持游戏内的购买和充值功能。文件管理方面，通过优化大数据处理和管理机制，显著提高了系统的稳定性与性能。</p>
<h3 id="如何实现数据同步"><a href="#如何实现数据同步" class="headerlink" title="如何实现数据同步"></a>如何实现数据同步</h3><p>使用<code>WebSocket</code>来实现实时数据同步。WebSocket允许在客户端和服务器之间建立持久连接，支持双向通信。每当用户在前端进行数据操作时，这些操作会通过WebSocket即时发送到服务器，服务器处理后再将更新的数据广播给所有连接的客户端，从而实现数据的实时同步。</p>
<h3 id="如何实现视图切换"><a href="#如何实现视图切换" class="headerlink" title="如何实现视图切换"></a>如何实现视图切换</h3><blockquote>
<p>多视图切换的核心在于视图状态的管理。我们使用了React的状态管理工具（如Redux）来管理当前的视图状态。每种视图（如表格视图、相册视图）都对应一个独立的组件，这些组件共享同一套数据源。通过在状态管理中维护当前视图的类型，我们可以根据状态的变化动态加载和渲染不同的视图组件，实现视图的无缝切换。</p>
</blockquote>
<h3 id="实现复杂的查询功能，如何处理性能问题"><a href="#实现复杂的查询功能，如何处理性能问题" class="headerlink" title="实现复杂的查询功能，如何处理性能问题"></a>实现复杂的查询功能，如何处理性能问题</h3><p>索引、缓存、分页</p>
<blockquote>
<p>为了处理复杂查询的性能问题，我们采取了多种优化措施。首先，在数据库层面，我们对常用的查询字段建立了索引，以加快查询速度。其次，我们使用了缓存机制，将频繁查询的数据缓存到内存中，减少数据库的访问次数。另外，我们还实现了分页加载，避免一次性加载大量数据，进一步提升性能。</p>
</blockquote>
<p>React.memo：高阶组件，对比props</p>
<p>useCallback：函数</p>
<p>useMemo：缓存结果</p>
<p>React.lazy</p>
<p>按需加载组件</p>
<p>虚拟列表加载：可视区域，分页</p>
<h3 id="如何多用户的实时协同时的数据一致性"><a href="#如何多用户的实时协同时的数据一致性" class="headerlink" title="如何多用户的实时协同时的数据一致性"></a>如何多用户的实时协同时的数据一致性</h3><blockquote>
<p>在多用户实时协同环境下，数据一致性是一个重要问题。我们采用了乐观锁机制来处理并发修改。每次数据更新时，都会附带一个版本号，只有当版本号匹配时，才允许更新成功，否则会提示用户数据冲突。对于冲突的数据，我们提供了冲突解决机制，用户可以选择保留自己的修改或接受他人的修改。</p>
</blockquote>
<p>在这个项目中，多用户同步功能是通过WebSocket实现的。每个用户在登录或进入特定空间时都会建立一个WebSocket连接，并加入对应的空间。服务器端维护一个WebSocket连接池，根据消息的目标空间ID，将消息广播给在同一空间内的所有连接。客户端接收到消息后，根据消息的类型和内容进行相应的处理，如更新Redux状态或显示通知，从而实现多用户之间的实时数据同步和协作。</p>
<h3 id="如何保证数据的安全性和隐私性的？"><a href="#如何保证数据的安全性和隐私性的？" class="headerlink" title="如何保证数据的安全性和隐私性的？"></a>如何保证数据的安全性和隐私性的？</h3><blockquote>
<p>为了保证数据的安全性和隐私性，我们采取了多种措施。首先，在数据传输过程中，我们使用HTTPS协议加密通信，防止数据被窃取。其次，在数据存储方面，我们对敏感数据进行加密存储，确保数据在被盗或泄露时仍然无法被解读。此外，我们还实施了严格的访问控制机制，只有授权用户才能访问和操作数据。我们定期进行安全审计和漏洞扫描，及时发现和修复安全问题。</p>
</blockquote>
<h3 id="遇到最大的问题–挑战"><a href="#遇到最大的问题–挑战" class="headerlink" title="遇到最大的问题–挑战"></a>遇到最大的问题–挑战</h3><blockquote>
<p>开发过程中最大的挑战是实现实时协同功能，因为这涉及到复杂的并发控制和数据同步问题。为了解决这个问题，我们首先进行了详细的技术调研，选择了合适的技术方案（如WebSocket和乐观锁机制）。然后，我们通过不断的迭代开发和测试，逐步完善了实时协同功能，并在实际使用中进行优化和改进。</p>
</blockquote>
<ul>
<li><p>使用Google OAuth 2.0认证，用户可以通过Google账户进行安全便捷的注册和登录。开发了AutoLogin方法，支持自动登录功能，通过解析URL查询参数、验证码验证和用户信息获取，实现无缝登录体验。</p>
</li>
<li><p>负责开发NPC角色创建和管理模块，支持用户通过表单填写基础信息、设定角色个性，选择不同的GPT模型，添加角色介绍，并设置角色的公开、私有、半公开状态，提升游戏的个性化和用户参与度</p>
</li>
<li><p>实现与NPC角色的聊天互动功能，支持聊天背景和音乐设置、聊天内容分享，并在聊天过程中动态调整所使用的AI模型，增强互动体验。</p>
</li>
<li><p>开发NPC角色创建，允许用户创建、编辑和管理多个NPC角色。调用并集成预训练的AI模型（如GPT系列、BERT等），为NPC角色提供智能对话能力。</p>
</li>
<li><p>开发了用户自定义剧场功能，使用户能够自主创建剧场，选择剧场类型，上传相关文件，并进行内容的更新与发布，增强了游戏的个性化和用户参与度。</p>
</li>
<li><p>建立和管理<code>WebSocket</code>连接，确保连接稳定，处理服务器发送的消息，并通过心跳检测机制保持连接活跃。如果连接中断，会自动重连。通过回调管理机制，可以方便地添加和移除消息处理逻辑，使其具有良好的扩展性和维护性。</p>
<p>在心动剧场实现聊天记录组件，通过 <code>ResizeObserver</code> 和 Vue 的 <code>watch</code>，确保每次接收到新消息时自动平滑滚动到底部，并确保用户始终能看到最新消息。</p>
</li>
<li><p>支付功能，使用虚拟货币支付，创建了Express服务器，通过 <code>/sendUSDT</code> 路径处理USDT代币转移请求。它检查请求的合法性，处理必要的参数，并通过与Solana区块链交互完成代币转移。</p>
</li>
<li><p>开发了一个Express服务器和实用函数，用于处理Solana区块链上的USDT代币转账。服务器通过验证请求来源和必要参数，确保安全性。使用自定义的 <code>transferSolanaToken</code> 函数管理代币账户，创建并签署转账指令，发送并确认交易。该过程包括全面的错误处理和详细的日志记录，确保转账过程的高效和可靠。</p>
</li>
</ul>
<ol>
<li><p><strong>数据缓冲与重试机制</strong>：<br>在流式输出的过程中，可以引入数据缓冲机制，确保数据能够有序且完整地输出。如果网络波动导致流式输出中断，可以使用重试机制来重新请求未完成的部分，保证用户体验不受影响。</p>
</li>
<li><p><strong>设置超时与断开重连机制</strong>：<br>为了避免网络问题导致长时间等待或流式数据丢失，建议在客户端设置超时机制，一旦超过指定时间没有收到数据，就主动重连服务器。这样可以在网络短暂中断后，恢复流式输出的连续性。</p>
</li>
<li><p><strong>逐步加载和流式传输优化</strong>：<br>当处理流式 GPT 模型时，可以分批次逐步加载模型生成的内容，而不是等待整个输出完成后再传输。这种分块式的流数据传输可以大大提升用户体验，避免长时间等待。</p>
</li>
<li><p><strong>带宽和网络优化</strong>：<br>流式传输对网络带宽要求较高，因此可以通过优化传输协议或压缩传输的数据包，减少带宽占用，增强稳定性。</p>
</li>
<li><p><strong>异步处理与多线程</strong>：<br>在前端实现中，可以采用异步处理或者多线程技术来处理接收到的流式数据，确保数据在接收到时就能被即时渲染，而不需要等待整个流式输出的完成。</p>
</li>
<li><p><strong>流数据的分片与合并</strong>：<br>对于较大的数据流，可以将其拆分成小块进行传输，客户端接收到小块数据后立即渲染，这样能提升实时响应速度，降低数据丢失或超时的风险。</p>
</li>
<li><p><strong>状态监控与回退机制</strong>：<br>实时监控流式输出的状态，如果检测到输出过程不稳定或中断，可以立即触发回退机制，通知用户进行重试，或者从最后一个接收的有效输出开始重新连接数据流。</p>
</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li><strong>发送请求</strong>：根据 <code>props.strategy.stream</code> 判断是否采用流式传输，如果是流式传输，则使用 <code>fetchEventSource</code> 进行数据的流式获取。</li>
<li><strong>流式处理</strong>：<ul>
<li>使用 <code>fetchEventSource</code> 发起 POST 请求，请求的数据通过流式输出方式返回。</li>
<li>在 <code>onmessage</code> 回调函数中处理每一段流数据，根据返回的数据类型（如 <code>text</code>、<code>audio</code> 等）动态更新 <code>dialogue</code> 列表，并通过滚动条的更新（<code>scrollBottom()</code>）确保页面自动滚动到最新内容。</li>
<li>通过 <code>requestId</code> 确保每个流的消息顺序正确，并处理可能的重复消息或延迟消息。</li>
</ul>
</li>
<li><strong>错误处理</strong>：<ul>
<li>在 <code>onopen</code>、<code>onclose</code> 和 <code>onerror</code> 回调中进行相应的连接、关闭和错误处理，确保流在出现异常时可以正确中止并反馈给用户。</li>
</ul>
</li>
</ol>
<h3 id="关键的流式稳定性优化-1"><a href="#关键的流式稳定性优化-1" class="headerlink" title="关键的流式稳定性优化"></a>关键的流式稳定性优化</h3><ol>
<li><p><strong>重试机制与中止控制</strong>：</p>
<ul>
<li>通过 <code>AbortController</code> 实现了对流式请求的中止控制，用户可以在需要时中止请求，或者在网络问题出现时取消请求。</li>
<li>处理了 <code>requestId</code> 的匹配逻辑，确保流在处理时不会因为前后请求的混淆导致输出错误。</li>
</ul>
</li>
<li><p><strong>逐步加载和数据拼接</strong>：</p>
<ul>
<li><code>onmessage</code> 中对返回的流数据进行了处理，通过判断返回数据类型进行拼接和内容追加，特别是对 <code>text</code> 类型的数据，通过累加 <code>value</code> 进行逐步渲染，保证流式数据的顺滑展示。</li>
</ul>
</li>
<li><p><strong>连接与状态管理</strong>：</p>
<ul>
<li>在 <code>onopen</code> 中判断连接状态并设置 <code>streamChatEnd</code>，确保流式传输的状态正确维护。</li>
<li>在 <code>onclose</code> 和 <code>onerror</code> 中根据 <code>requestId</code> 检查当前流的状态，防止错误处理遗漏或误判，确保用户能够得到及时的反馈。</li>
</ul>
</li>
<li><p><strong>滚动条与界面更新</strong>：</p>
<ul>
<li>通过 <code>scrollBottom()</code> 保证页面的自动滚动，使得流式输出的内容能够即时展现给用户，提高了用户体验。</li>
</ul>
</li>
</ol>
<h1 id="Martix项目管理平台"><a href="#Martix项目管理平台" class="headerlink" title="Martix项目管理平台"></a>Martix项目管理平台</h1><p>为什么选择qiankun做微前端</p>
<p>微前端的生命周期</p>
<p>如何做样式隔离</p>
<p><strong>描述</strong>：Martix项目管理平台</p>
<ul>
<li>使用qiankun微前端架构，使用 React 开发的主应用负责动态加载和管理多个独立开发的微应用；</li>
<li>封装富文本编辑器组件，实现图片自动上传、代码块编辑、历史版本管理和恢复以及内容缓存管理等功能。组件支持内容粘贴处理、自动识别和转换图片，确保编辑过程的流畅性和稳定性，优化用户界面的互动体验。</li>
<li>开发需求管理组件和实现需求评审流程配置功能，运用Vue.js、Vuex等技术实现复杂表单的动态生成和校验，处理多层嵌套组件的通信和状态管理，优化异步数据的加载和处理逻辑，实现了需求数据的动态加载和实时更新； </li>
<li>开发文件批量上传与管理组件，支持文件多种操作（如上传、预览、关联文档等），通过客户端验证减少服务器压力，提高项目文档管理的效率和用户体验；</li>
<li>开发甘特图视图组件，采用虚拟滚动和延迟加载技术解决大规模数据渲染带来的性能挑战，开发自定义列配置组件，利用localStorage实现了用户配置的跨会话持久化，实现的视图切换和动态数据过滤功能，包括精确的时间线对齐、动态数据绑定、以及用户交互的拖拽和缩放功能，提高甘特图的查看和操作效率。</li>
</ul>
<h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>使用registerMicroApps注册微前端，使用nextjs的useRouter路由和useEffect监听路由，</p>
<p>并通过全局状态管理与子应用共享路由状态，使得子应用能够响应路由变化。</p>
<h3 id="qiankun生命周期，在子应用中使用"><a href="#qiankun生命周期，在子应用中使用" class="headerlink" title="qiankun生命周期，在子应用中使用"></a>qiankun生命周期，在子应用中使用</h3><h3 id="bootstrap、mount、unmount、update"><a href="#bootstrap、mount、unmount、update" class="headerlink" title="bootstrap、mount、unmount、update"></a>bootstrap、mount、unmount、update</h3><p>当使用 Vue 2 构建 Qiankun 的子应用时，你需要在子应用中定义和导出相应的生命周期钩子，这些钩子会与 Qiankun 主应用进行交互以实现模块的正确加载和卸载。这些生命周期钩子包括：<code>bootstrap</code>、<code>mount</code>、<code>unmount</code>，以及可选的 <code>update</code>（如果你需要处理主应用传递的 props）。下面是如何在 Vue 2 子应用中实现这些生命周期钩子的一个示例：</p>
<ol>
<li><p><strong>bootstrap</strong>：</p>
<ul>
<li>这个阶段主要用于全局级别的初始化工作，如设置日志、初始化服务等，通常只运行一次。</li>
</ul>
</li>
<li><p><strong>mount</strong>：</p>
<ul>
<li>这个阶段用于将 Vue 实例挂载到 DOM 上，通常在这里初始化和渲染 Vue 组件。</li>
</ul>
</li>
<li><p><strong>unmount</strong>：</p>
<ul>
<li>这个阶段用于清理、卸载 Vue 实例，避免内存泄露，确保所有事件监听器和依赖都被适当移除。</li>
</ul>
</li>
<li><p><strong>update</strong>：</p>
<ul>
<li>这个阶段用于处理新的 props 或状态更新，是可选的，依赖于你的应用是否需要响应外部变化。</li>
</ul>
</li>
</ol>
<h3 id="实现注意事项"><a href="#实现注意事项" class="headerlink" title="实现注意事项"></a>实现注意事项</h3><ul>
<li>确保在 <code>mount</code> 函数中正确地挂载 Vue 实例到由 Qiankun 提供的 DOM 容器中。通常这是通过 <code>props.container.querySelector(&#39;#app&#39;)</code> 实现的，其中 <code>#app</code> 是容器内的一个 DOM 元素的 ID。</li>
<li>在 <code>unmount</code> 函数中，彻底销毁 Vue 实例和清理 DOM 是至关重要的，以防止内存泄漏或其他副作用。</li>
<li>如果实现了 <code>update</code> 函数，确保你的应用可以响应外部状态的变化，例如，接收来自主应用的数据更新。</li>
</ul>
<p>通过这样的设置，Vue 2 子应用可以被 Qiankun 框架有效地管理，实现真正意义上的微前端架构，其中各个子应用可以独立开发、部署和更新，而不会影响到主应用或其他子应用的运行。</p>
<h2 id="路由鉴权"><a href="#路由鉴权" class="headerlink" title="路由鉴权"></a>路由鉴权</h2><p>您提供的 JavaScript 函数 <code>hasPermission</code> 是用于在基于路由的系统中检查用户是否拥有访问某个特定路由的权限。这个函数通过分析路由对象和用户的权限列表来决定是否允许访问某个路由。下面我将详细解释这个函数的逻辑和作用：</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul>
<li><code>to</code>: 这个参数表示即将访问的路由对象。通常，这个对象包含了路由的元数据（如名称、查询参数等）。</li>
<li><code>hasPermissionList</code>: 这是一个数组，包含了用户拥有的权限名称。</li>
</ul>
<h3 id="函数逻辑"><a href="#函数逻辑" class="headerlink" title="函数逻辑"></a>函数逻辑</h3><ol>
<li><p><strong>检查元数据是否存在</strong>：</p>
<ul>
<li>函数首先检查 <code>to.meta</code> 是否存在，<code>to.meta</code> 通常包含与路由相关的元数据，比如权限相关信息。</li>
</ul>
</li>
<li><p><strong>特定路由的权限检查</strong>：</p>
<ul>
<li>函数中有特定的逻辑来处理名为 <code>workload</code> 和 <code>bugreport</code> 的路由。对于这些路由，它进一步检查查询参数 <code>to.query.type</code>，来决定用户是否有权限访问不同类型的统计信息。</li>
<li>对于 <code>workload</code> 路由：<ul>
<li>如果 <code>type</code> 是 <code>dept</code>（部门），则检查用户权限列表中是否包含 <code>&#39;部门工作量统计&#39;</code>。</li>
<li>如果 <code>type</code> 是 <code>member</code>（员工），则检查是否包含 <code>&#39;员工工作量统计&#39;</code>。</li>
<li>如果 <code>type</code> 是 <code>project</code>（项目集），则检查是否包含 <code>&#39;项目集工作量统计&#39;</code>。</li>
</ul>
</li>
<li>对于 <code>bugreport</code> 路由：<ul>
<li>类似地，基于 <code>type</code>（部门、员工或项目集），检查相应的 <code>&#39;部门缺陷量统计&#39;</code>、<code>&#39;员工缺陷量统计&#39;</code> 或 <code>&#39;项目集缺陷量统计&#39;</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>通用权限检查</strong>：</p>
<ul>
<li>如果路由名称不是 <code>workload</code> 或 <code>bugreport</code>，则检查 <code>hasPermissionList</code> 是否包含 <code>to.meta.title</code>。如果不包含，则表示没有权限。</li>
</ul>
</li>
<li><p><strong>默认行为</strong>：</p>
<ul>
<li>如果没有 <code>to.meta</code>，函数默认允许访问，即返回 <code>true</code>。</li>
</ul>
</li>
</ol>
<h3 id="示例使用场景"><a href="#示例使用场景" class="headerlink" title="示例使用场景"></a>示例使用场景</h3><p>假设这个函数被用在一个 Web 应用的路由守卫中，每次路由跳转之前都会调用这个函数来确定用户是否有权限访问目标路由。这种权限检查是维护应用安全性的重要方式，确保用户只能访问他们被授权的部分。</p>
<h3 id="代码改进建议"><a href="#代码改进建议" class="headerlink" title="代码改进建议"></a>代码改进建议</h3><p>虽然这个函数能够正常工作，但它的逻辑有些重复，可以通过一些重构来优化：</p>
<ul>
<li><strong>提取重复逻辑</strong>：对于检查权限的逻辑，可以考虑抽象出一个辅助函数，简化代码。</li>
<li><strong>使用映射</strong>：将权限名称和路由查询类型映射起来，减少重复的 <code>if-else</code> 语句。</li>
<li><strong>错误处理</strong>：在实际应用中，可能需要更复杂的错误处理逻辑，比如当路由对象缺失必要信息时提供默认行为或记录错误。</li>
</ul>
<p>这个函数的存在显示了如何在客户端进行基于路由的访问控制，这是构建安全且可维护的现代 Web 应用的一个关键方面。</p>
<p><strong>描述</strong>：实时协作数据平台，允许用户创建、管理和共享数据表、表单和仪表板。项目采用了模块化的设计和Websocket通信，提供强大的实时更新和协作能力，支持多种视图类型，包含个人待办事项、团队待办事项和模板库，通过引入自定义待办事项和丰富的模板库，提升用户在项目管理、数据分析和团队协作方面的效率。</p>
<ul>
<li><p>登录系统集成无痕验证码技术，通过服务器端自动执行，减少了传统验证码对用户体验的干扰。该系统全面涵盖了用户数据处理、前端校验、无痕验证，以及服务器端的认证与状态管理，确保用户操作的便捷性和系统的安全性；</p>
</li>
<li><p>实现动态的页面导航，通过postMessage实现了iframe中的应用与主页面的安全通信，根据不同的应用场景，如分享视图、嵌入视图、个人路径等，实现了条件性导航逻辑，在不同上下文中都能够正确地引导用户到期望的视图；</p>
</li>
<li><p>通过Sentry用于错误监控和性能优化，提高错误追踪的准确性和应用性能监控的效率，设计自定义hooks用于封装复杂的业务逻辑和API请求，包括节点的增删改查、个人待办事项的管理、共享和收藏节点操作等；</p>
</li>
<li><p>基于Websocket实现实时双向通信，在不刷新页面情况下同步和更新用户数据，增强用户交互体验；性能优化与后台处理：引入 Web Workers 处理复杂的后台数据计算任务，解放了主 UI 线程，避免了复杂运算对用户界面响应的影响。通过有效管理线程，提高了页面渲染效率和应用响应速度。</p>
</li>
<li><p>负责甘特图视图内任务内容的动态渲染组件开发，使用延迟加载和按需渲染的策略，减少了页面的初始加载时间和运行时的性能开销，采用 React 和 Konva 库实现客户端绘制，通过 Next.js 动态导入技术优化加载速度；</p>
</li>
<li><p>负责轻任务应用的主导航栏组件，支持在不同设备和屏幕尺寸上的操作体验，处理了用户登录、空间选择、通知计数等多个状态的同步和更新，根据用户权限动态调整导航栏展示的功能模块，对于非管理员用户隐藏空间管理入口，对于删除空间的用户限制访问等，实现了细粒度的功能控制。</p>
</li>
<li><p>开发个人待办事项管理组件，通过Hooks和高阶组件等技术实现功能模块的解耦和复用，利用自定义hooks处理数据请求和副作用，在处理共享目录的逻辑时，通过Redux和封装自定义hooks，实现了状态的更新和数据的同步；</p>
</li>
</ul>
<h1 id="04-09北京海致科技集团"><a href="#04-09北京海致科技集团" class="headerlink" title="04-09北京海致科技集团"></a>04-09北京海致科技集团</h1><h2 id="遍历数据方法？"><a href="#遍历数据方法？" class="headerlink" title="遍历数据方法？"></a>遍历数据方法？</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-of：ES6中的方法，不会遍历数组的私有属性，不能遍历对象，可以遍历字符串，数组，有返回值"><a href="#for-of：ES6中的方法，不会遍历数组的私有属性，不能遍历对象，可以遍历字符串，数组，有返回值" class="headerlink" title="for of：ES6中的方法，不会遍历数组的私有属性，不能遍历对象，可以遍历字符串，数组，有返回值"></a>for of：ES6中的方法，不会遍历数组的私有属性，不能遍历对象，可以遍历字符串，数组，有返回值</h3>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);<span class="comment">//输出 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-in：数组的私有属性也会遍历，所以一般用来遍历对象"><a href="#for-in：数组的私有属性也会遍历，所以一般用来遍历对象" class="headerlink" title="for in：数组的私有属性也会遍历，所以一般用来遍历对象"></a>for in：数组的私有属性也会遍历，所以一般用来遍历对象</h3>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);<span class="comment">//item是数组索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="foreach：forEach-方法对数组的每个元素执行一次给定的函数。"><a href="#foreach：forEach-方法对数组的每个元素执行一次给定的函数。" class="headerlink" title="foreach：forEach() 方法对数组的每个元素执行一次给定的函数。"></a>foreach：forEach() 方法对数组的每个元素执行一次给定的函数。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;<span class="comment">//item为值，index为数组索引值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="遍历对象的方法和遍历数组的方法分别说五个"><a href="#遍历对象的方法和遍历数组的方法分别说五个" class="headerlink" title="遍历对象的方法和遍历数组的方法分别说五个"></a><strong>遍历对象的方法和遍历数组的方法分别说五个</strong></h3><p>在 JavaScript 中遍历对象并访问其属性的方法有多种，每种方法都适用于不同的情况和需求。以下是一些常见的方法：</p>
<h3 id="1-for-in-循环"><a href="#1-for-in-循环" class="headerlink" title="1. for...in 循环"></a>1. <code>for...in</code> 循环</h3><p>这是遍历对象属性最传统的方式。<code>for...in</code> 循环会遍历对象自身的所有可枚举属性以及它继承的可枚举属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：使用 <code>for...in</code> 时，通常需要使用 <code>hasOwnProperty</code> 方法来过滤掉从原型链继承的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Object-keys-方法"><a href="#2-Object-keys-方法" class="headerlink" title="2. Object.keys() 方法"></a>2. <code>Object.keys()</code> 方法</h3><p><code>Object.keys()</code> 返回一个数组，包含对象自身的所有可枚举属性名称。配合 <code>forEach</code> 循环使用可以遍历对象属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-Object-values-方法"><a href="#3-Object-values-方法" class="headerlink" title="3. Object.values() 方法"></a>3. <code>Object.values()</code> 方法</h3><p>这个方法返回一个数组，包含对象自身的所有可枚举属性值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-Object-entries-方法"><a href="#4-Object-entries-方法" class="headerlink" title="4. Object.entries() 方法"></a>4. <code>Object.entries()</code> 方法</h3><p><code>Object.entries()</code> 返回一个数组，其元素是与对象自身可枚举属性键值对对应的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-Object-getOwnPropertyNames-方法"><a href="#5-Object-getOwnPropertyNames-方法" class="headerlink" title="5. Object.getOwnPropertyNames() 方法"></a>5. <code>Object.getOwnPropertyNames()</code> 方法</h3><p>这个方法返回一个数组，包含对象自身的所有属性（无论是否可枚举）的名称：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="6-使用-for-of-循环（配合-Object-entries-）"><a href="#6-使用-for-of-循环（配合-Object-entries-）" class="headerlink" title="6. 使用 for...of 循环（配合 Object.entries()）"></a>6. 使用 <code>for...of</code> 循环（配合 <code>Object.entries()</code>）</h3><p>如果你想使用 <code>for...of</code> 循环遍历对象属性，可以结合使用 <code>Object.entries()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-Reflect-ownKeys-方法"><a href="#7-Reflect-ownKeys-方法" class="headerlink" title="7. Reflect.ownKeys() 方法"></a>7. <code>Reflect.ownKeys()</code> 方法</h3><p><code>Reflect.ownKeys(obj)</code> 返回一个数组，包含对象自身的所有键（包括不可枚举属性及 Symbol 类型的键）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用场景选择"><a href="#使用场景选择" class="headerlink" title="使用场景选择"></a>使用场景选择</h3><ul>
<li>**<code>for...in</code>**：适用于需要遍历继承的属性的情况，但通常需要配合 <code>hasOwnProperty</code>。</li>
<li>**<code>Object.keys()</code>、<code>Object.values()</code>、<code>Object.entries()</code>**：适用于现代 JavaScript 应用，可以更方便地遍历对象的可枚举属性。</li>
<li>**<code>Object.getOwnPropertyNames()</code> 和 <code>Reflect.ownKeys()</code>**：适用于需要访问对象所有键（包括不可枚举的）的高级用途。</li>
</ul>
<p>这些方法可以灵活选择和使用，以满足不同的遍历需求和特定的编程环境。</p>
<h3 id="遍历数组的方法有："><a href="#遍历数组的方法有：" class="headerlink" title="遍历数组的方法有："></a>遍历数组的方法有：</h3><ol>
<li>for 循环</li>
<li>forEach() 方法</li>
<li>map() 方法</li>
<li>filter() 方法</li>
<li>reduce() 方法</li>
<li>some() 方法</li>
<li>every() 方法</li>
<li>for…of 循环</li>
</ol>
<h1 id="04-11-滴滴日常实习"><a href="#04-11-滴滴日常实习" class="headerlink" title="04-11-滴滴日常实习"></a>04-11-滴滴日常实习</h1><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><h2 id="qiankun机制是怎样的"><a href="#qiankun机制是怎样的" class="headerlink" title="qiankun机制是怎样的"></a>qiankun机制是怎样的</h2><p><code>qiankun</code>是一个实现了微前端架构的JavaScript库，它允许开发者将一个大型的前端应用分解为多个可以独立开发、部署、运行的小型应用（微应用）。<code>qiankun</code>基于<code>single-spa</code>，提供了一套比较完善的微前端解决方案，其工作机制主要可以从以下几个方面理解：</p>
<h3 id="初始化和注册"><a href="#初始化和注册" class="headerlink" title="初始化和注册"></a>初始化和注册</h3><ul>
<li><p><strong>主应用启动</strong>：在主应用中，<code>qiankun</code>提供<code>registerMicroApps</code>方法用于注册微应用。在注册时，你需要为每个微应用指定一个唯一的名称、入口（可以是URL或者一段HTML标记）、容器（用于挂载微应用的DOM元素）以及激活条件（当URL符合某个规则时激活对应的微应用）。</p>
</li>
<li><p><strong>微应用加载</strong>：当激活条件满足时，<code>qiankun</code>会动态加载微应用的静态资源（JavaScript、CSS等）。这一过程通常是通过<code>fetch</code>API完成的。</p>
</li>
</ul>
<h3 id="沙箱机制"><a href="#沙箱机制" class="headerlink" title="沙箱机制"></a>沙箱机制</h3><ul>
<li><p><strong>JavaScript沙箱</strong>：为了防止微应用间的全局变量污染，<code>qiankun</code>为每个微应用创建了一个JavaScript运行时沙箱。这个沙箱通过代理全局对象（如<code>window</code>）来隔离全局变量，确保微应用间的隔离性。</p>
</li>
<li><p><strong>样式隔离</strong>：<code>qiankun</code>使用Shadow DOM或者其他策略来实现CSS隔离，防止微应用间的样式冲突。</p>
</li>
</ul>
<h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><ul>
<li><p><code>qiankun</code>为微应用定义了一系列生命周期钩子，例如<code>bootstrap</code>、<code>mount</code>、<code>unmount</code>等。主应用通过这些钩子可以管理微应用的加载、挂载、更新和卸载。</p>
</li>
<li><p>微应用需要暴露这些生命周期方法，以便<code>qiankun</code>在适当的时刻调用它们。</p>
</li>
</ul>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><ul>
<li><code>qiankun</code>提供了主应用和微应用之间的通信机制。通常，这是通过在注册微应用时传递<code>props</code>来实现的。<code>props</code>可以包含需要共享的状态、函数等。</li>
</ul>
<h3 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li><p><strong>预加载</strong>：<code>qiankun</code>支持配置预加载微应用的静态资源，以缩短微应用首次启动的时间。</p>
</li>
<li><p><strong>资源复用</strong>：<code>qiankun</code>支持主应用和微应用之间的依赖共享，减少了重复加载相同依赖库的需要。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>qiankun</code>的机制提供了一种有效的方式来构建大型的、由多个团队独立开发和部署的前端应用。它通过动态加载、沙箱隔离、生命周期管理和通信机制，实现了技术栈无关、运行时独立、应用间隔离的微前端架构。这使得大型项目可以更加模块化、易于管理，同时还能保证不同团队的开发效率和应用性能。</p>
<h2 id="nextjs做服务端渲染"><a href="#nextjs做服务端渲染" class="headerlink" title="nextjs做服务端渲染"></a>nextjs做服务端渲染</h2><p>Next.js 是一个基于 React 的框架，专门用于构建服务端渲染（Server-Side Rendering, SSR）和静态网站生成（Static Site Generation, SSG）的应用。Next.js 通过预渲染页面来提高性能和搜索引擎优化（SEO），预渲染可以在服务端生成HTML，也可以在构建时生成，然后发送到客户端。</p>
<h3 id="服务端渲染（SSR）的工作原理"><a href="#服务端渲染（SSR）的工作原理" class="headerlink" title="服务端渲染（SSR）的工作原理"></a>服务端渲染（SSR）的工作原理</h3><p>在传统的React应用中，大部分渲染工作都在客户端进行。而在Next.js中，服务端渲染意味着首次页面加载时的HTML是在服务器上生成的，这个过程包括：</p>
<ol>
<li><strong>请求处理</strong>：用户请求一个页面时，该请求被发送到服务器。</li>
<li><strong>页面渲染</strong>：服务器运行React代码来生成页面的HTML内容，同时也可以在这个阶段获取和包含必要的数据（例如，通过API调用获取）。</li>
<li><strong>发送响应</strong>：服务器将生成的HTML作为响应发送给客户端。</li>
<li><strong>客户端处理</strong>：客户端浏览器接收到HTML并呈现给用户。然后，React代码在浏览器端“接管”页面，使其成为一个完全交互式的单页应用。</li>
</ol>
<h3 id="如何在Next-js中使用SSR"><a href="#如何在Next-js中使用SSR" class="headerlink" title="如何在Next.js中使用SSR"></a>如何在Next.js中使用SSR</h3><p>Next.js 通过文件系统基路由和数据获取方法如<code>getServerSideProps</code>自动处理SSR。</p>
<h4 id="页面组件"><a href="#页面组件" class="headerlink" title="页面组件"></a>页面组件</h4><p>每一个位于<code>pages</code>目录下的<code>.js</code>、<code>.jsx</code>、<code>.ts</code>或<code>.tsx</code>文件都会自动成为路由，并且默认是通过服务端渲染的。</p>
<h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><p>对于需要服务端获取数据的页面，你可以使用<code>getServerSideProps</code>函数来获取数据：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/posts.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://api.example.com/data`</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123; data &#125;, <span class="comment">// 将作为props传递给页面组件</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Posts</span>(<span class="params">&#123; data &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 渲染数据 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Posts</span>;</span><br></pre></td></tr></table></figure>

<p><code>getServerSideProps</code>在请求时运行，允许你在渲染页面前从服务器获取数据。这个函数只在服务端运行，绝不会在客户端运行，因此可以直接写服务器代码，如直接访问数据库等。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li><strong>SEO友好</strong>：由于页面的HTML是预先在服务器上生成的，搜索引擎可以更容易地抓取和索引内容。</li>
<li><strong>性能提升</strong>：首次加载时直接提供包含所有必要数据的HTML，可以减少首屏渲染时间。</li>
<li><strong>灵活的数据获取策略</strong>：Next.js不仅支持SSR，还支持SSG（静态网站生成），以及客户端数据获取，开发者可以根据页面的需求选择最适合的策略。</li>
</ol>
<p>Next.js通过这些机制，极大地简化了使用React进行服务端渲染应用的开发流程，同时也提供了灵活、高效的数据处理和页面渲染方案。</p>
<h2 id="看题输出–this"><a href="#看题输出–this" class="headerlink" title="看题输出–this"></a>看题输出–this</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">dev</span>: <span class="string">&#x27;22222&#x27;</span>,</span><br><span class="line"><span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">dev</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">dev</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">c</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">dev</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">d</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">dev</span></span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">e</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">b</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">f</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">b</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">a</span>())<span class="comment">//a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">b</span>())<span class="comment">//a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">c</span>())<span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">d</span>())<span class="comment">//a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">e</span>())<span class="comment">//a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">f</span>()())<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>在JavaScript中，<code>this</code>关键字的值取决于函数是如何被调用的。在对象<code>obj</code>中定义的方法表现出不同的<code>this</code>行为：</p>
<ol>
<li><strong>a</strong> - 是一个正常的函数，当被调用时，<code>this</code>指向<code>obj</code>对象。</li>
<li><strong>b</strong> - 是ES6的简写方法，当被调用时，<code>this</code>同样指向<code>obj</code>对象。</li>
<li><strong>c</strong> - 是一个箭头函数，它没有自己的<code>this</code>，<code>this</code>值是从创建它的上下文（即定义它的上下文）继承的，在全局代码中，<code>this</code>指向全局对象。</li>
<li><strong>d</strong> - 是一个正常的函数，它返回一个箭头函数。箭头函数内部的<code>this</code>由外围最近一层非箭头函数决定，在这里是<code>d</code>函数，因此箭头函数中的<code>this</code>指向<code>obj</code>对象。</li>
<li><strong>e</strong> - 是一个正常的函数，它调用<code>obj</code>对象的<code>b</code>方法，<code>this</code>指向<code>obj</code>对象。</li>
<li><strong>f</strong> - 是一个正常的函数，它返回<code>obj</code>对象的<code>b</code>方法，但不执行它。当<code>f</code>被调用，它返回对<code>b</code>的引用，此时<code>this</code>尚未被绑定。</li>
</ol>
<p>现在，根据以上规则，可以确定<code>console.log</code>语句的输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">a</span>())  <span class="comment">// &#x27;222222&#x27; - &#x27;this&#x27;指向obj</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">b</span>())  <span class="comment">// &#x27;222222&#x27; - &#x27;this&#x27;指向obj</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">c</span>())  <span class="comment">// undefined 或报错，取决于运行环境（在严格模式下，全局的this是undefined；非严格模式下，浏览器中this指向window，Node.js中this指向global对象）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">d</span>())  <span class="comment">// &#x27;222222&#x27; - 外层函数的&#x27;this&#x27;指向obj</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">e</span>())  <span class="comment">// &#x27;222222&#x27; - &#x27;this&#x27;指向obj，调用b方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">f</span>()()) <span class="comment">// &#x27;undefined&#x27;，取决于返回的函数b如何被调用。在这种情况下，它是作为一个独立的函数被调用，所以通常情况下&#x27;this&#x27;不会指向obj，但由于在obj的上下文中直接调用，&#x27;this&#x27;仍然指向obj。</span></span><br></pre></td></tr></table></figure>

<p>对于<code>obj.c()</code>，由于箭头函数不绑定<code>this</code>，它将会捕获定义时的<code>this</code>值。如果<code>obj</code>是在全局上下文中定义的，<code>this.dev</code>可能会返回<code>undefined</code>（严格模式下）或者全局对象的<code>dev</code>属性（非严格模式下）。</p>
<p>对于<code>obj.f()</code>，它返回<code>b</code>函数的引用，但在执行时它已经失去了原始的<code>obj</code>上下文，因此在严格模式下<code>this</code>将会是<code>undefined</code>，在非严格模式下通常是全局对象。然而，如果<code>obj.f()</code>在<code>obj</code>的上下文中直接被调用，<code>this</code>会正确地指向<code>obj</code>，因为它继承了<code>f()</code>调用时的上下文。</p>
<p>请注意，如果<code>obj</code>对象是在某个函数作用域或模块作用域中定义的，而且该作用域是严格模式（例如ES6模块默认是严格模式），那么<code>this</code>的行为可能会与非严格模式不同。在Node.js或模块化JavaScript环境中运行时，全局上下文中的<code>this</code>是<code>undefined</code>。</p>
<h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>在JavaScript中，执行顺序涉及到宏任务和微任务的概念。<code>setTimeout</code>被放入宏任务队列，而Promise的<code>.then</code>方法产生的回调被放入微任务队列。微任务队列在每次宏任务执行完毕后执行，且在下一个宏任务开始前，微任务队列会被完全清空。这里是这段代码执行的顺序解释：</p>
<ol>
<li><code>console.log(&#39;1&#39;)</code> 直接执行，打印 <code>1</code>。</li>
<li><code>setTimeout(..., 0)</code> 排入宏任务队列，等待执行。</li>
<li><code>Promise.resolve().then(...)</code> 的回调函数排入微任务队列。</li>
<li>新的 <code>Promise</code> 立即执行 <code>console.log(&#39;4&#39;)</code>，打印 <code>4</code>。</li>
<li>然后立即执行 <code>console.log(&#39;5&#39;)</code>，打印 <code>5</code>。</li>
<li>该Promise的<code>.then(...)</code>回调函数被排入微任务队列。</li>
<li>第二个带<code>setTimeout</code>的Promise构造函数执行，但其内部的<code>setTimeout</code>是一个宏任务，排入宏任务队列，等待执行。</li>
<li>当前宏任务（脚本的主体）执行完毕，开始执行微任务队列：首先执行 <code>Promise.resolve().then(...)</code> 的回调，打印 <code>3</code>，然后执行第一个Promise的<code>.then(...)</code>回调，打印 <code>6</code>。</li>
<li>微任务队列清空，开始下一个宏任务，首先是第一个<code>setTimeout</code>的回调，打印 <code>2</code>。</li>
<li>然后执行第二个<code>Promise</code>中的<code>setTimeout</code>，等待100ms后，它的<code>.then(...)</code>回调被排入微任务队列。</li>
<li>等到该宏任务完成后，执行微任务队列中的回调，打印 <code>7</code>。</li>
</ol>
<p>综上，打印顺序是：<code>1</code>, <code>4</code>, <code>5</code>, <code>3</code>, <code>6</code>, <code>2</code>, <code>7</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">a</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：1 4 5 3 6 2 7</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise的常用方法有哪些？"><a href="#Promise的常用方法有哪些？" class="headerlink" title="Promise的常用方法有哪些？"></a>Promise的常用方法有哪些？</h2><h3 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h3><ul>
<li>接受一个 Promise 对象的集合（数组、迭代器等）作为输入。</li>
<li>当所有的 Promise 都成功解决（resolved）时，返回一个新的 Promise，该 Promise 成功解决，并且其结果是所有输入 Promise 的结果数组。</li>
<li>如果任何一个 Promise 被拒绝（rejected），<code>Promise.all</code> 返回的 Promise 会立即被拒绝，其拒绝原因是第一个拒绝的 Promise 的原因。</li>
</ul>
<h3 id="Promise-allSettled-iterable"><a href="#Promise-allSettled-iterable" class="headerlink" title="Promise.allSettled(iterable)"></a>Promise.allSettled(iterable)</h3><ul>
<li>接受一个 Promise 对象的集合作为输入。</li>
<li>无论输入的 Promise 对象是成功还是失败，都会等待它们全部完成。</li>
<li>返回一个新的 Promise，该 Promise 解决后的结果是一个数组，数组中每个元素表示对应的 Promise 的结果，包括状态（<code>fulfilled</code> 或 <code>rejected</code>）和值（或拒绝原因）。</li>
</ul>
<h3 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h3><ul>
<li>接受一个 Promise 对象的集合作为输入。</li>
<li>返回一个新的 Promise，它将与输入的 Promise 中第一个解决或拒绝的 Promise 具有相同的解决值或拒绝原因。</li>
</ul>
<h3 id="Promise-resolve-valve"><a href="#Promise-resolve-valve" class="headerlink" title="Promise.resolve(valve)"></a>Promise.resolve(valve)</h3><ul>
<li>返回一个以给定值解决的 Promise。</li>
<li>如果输入是一个 Promise，那么 <code>Promise.resolve</code> 将返回这个 Promise。</li>
<li>如果输入带有一个 <code>then</code> 方法（即“thenable”对象），返回的 Promise 会“跟随”这个 thenable 的行为，即采用其最终状态。</li>
</ul>
<h3 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h3><p>返回一个以给定原因拒绝的 Promise。</p>
<h3 id="Promise-prototype-then-onFulfilled-onRejected"><a href="#Promise-prototype-then-onFulfilled-onRejected" class="headerlink" title="Promise.prototype.then(onFulfilled,onRejected)"></a>Promise.prototype.then(onFulfilled,onRejected)</h3><ul>
<li>在 Promise 上添加解决（fulfilled）和拒绝（rejected）的回调函数。</li>
<li>返回一个新的 Promise，以链式处理异步操作。</li>
</ul>
<h3 id="Promise-prototype-catch-onRejected"><a href="#Promise-prototype-catch-onRejected" class="headerlink" title="Promise.prototype.catch(onRejected)"></a>Promise.prototype.catch(onRejected)</h3><ul>
<li>添加一个拒绝（rejected）回调函数，是 <code>.then(null, onRejected)</code> 的语法糖。</li>
<li>返回一个新的 Promise。</li>
</ul>
<h3 id="Promise-prototype-finally-onFinally"><a href="#Promise-prototype-finally-onFinally" class="headerlink" title="Promise.prototype.finally(onFinally)"></a>Promise.prototype.finally(onFinally)</h3><ul>
<li>添加一个回调函数，无论 Promise 是解决还是拒绝，该回调函数都会被执行。</li>
<li>返回一个新的 Promise，在原始 Promise 解决或拒绝之后解决。</li>
</ul>
<p>这些方法提供了丰富的接口来处理异步操作，使得异步代码更加可读和易于管理。</p>
<h2 id="Commonjs和ES-Module"><a href="#Commonjs和ES-Module" class="headerlink" title="Commonjs和ES Module"></a>Commonjs和ES Module</h2><ol>
<li><p>Commonjs 和 Es Module 有什么区别 ？</p>
<p><strong>CJS：</strong></p>
<ul>
<li><strong>环境</strong>：最初被设计用于 Node.js。</li>
<li><strong>导入模块</strong>：使用 <code>require()</code> 函数导入模块。</li>
<li><strong>导出模块</strong>：使用 <code>module.exports</code> 和 <code>exports</code> 对象导出模块。</li>
<li><strong>加载方式</strong>：同步加载模块，即在代码执行到 <code>require()</code> 语句时立即同步地加载和执行模块。</li>
<li><strong>用例</strong>：主要用于服务器端和桌面应用程序。</li>
</ul>
<p><strong>ESM：</strong></p>
<ul>
<li><strong>环境</strong>：作为 ECMAScript（JavaScript的规范）的一部分，被设计用于浏览器和现代 JavaScript 环境。</li>
<li><strong>导入模块</strong>：使用 <code>import</code> 语句导入模块。</li>
<li><strong>导出模块</strong>：使用 <code>export</code> 关键字导出模块。</li>
<li><strong>加载方式</strong>：支持异步加载模块，允许进行代码分割和懒加载。</li>
<li><strong>用例</strong>：主要用于浏览器应用程序，但现在在 Node.js 和其他 JavaScript 环境中也得到了支持。</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li><strong>语法</strong>：CommonJS 使用 <code>require</code> 和 <code>module.exports</code>，而 ES Modules 使用 <code>import</code> 和 <code>export</code>。</li>
<li><strong>加载机制</strong>：CommonJS 模块是同步加载的，主要适用于服务器端，而 ES Modules 可以异步加载，更适合浏览器环境。</li>
<li><strong>模块解析</strong>：在 CommonJS 中，<code>require</code> 的路径可以是动态的，支持表达式，而 ES Modules 中的 <code>import</code> 路径必须是静态的，不能使用表达式。</li>
<li><strong>模块值的处理</strong>：CommonJS 导入的模块值是一个模块对象的拷贝，而 ES Modules 导入的是一个模块接口的“活”绑定。</li>
</ul>
<p><strong>联系：</strong></p>
<ul>
<li><strong>模块化目标</strong>：两者都旨在提供一种封装代码的方式，将代码分割成可复用的单元，并控制它们的作用域和公开接口。</li>
<li><strong>兼容性考虑</strong>：在现代 JavaScript 环境中（特别是在 Node.js 中），有努力使 CommonJS 和 ES Modules 能够相互操作。例如，Node.js 通过特定的导入语法支持在使用 CommonJS 规范的代码中导入 ES Module。</li>
</ul>
<p>随着 JavaScript 生态的发展，ES Modules 逐渐成为主流的模块化标准，但在很多现有项目和库中，CommonJS 仍然广泛使用。在新项目中选择哪种标准，通常取决于项目的运行环境、目标平台和开发者的偏好。</p>
</li>
<li><p>Commonjs 如何解决的循环引用问题 </p>
</li>
<li><p>既然有了 exports，为何又出了 module.exports ? 既生瑜，何生亮 ？</p>
</li>
<li><p>require 模块查找机制 ？</p>
</li>
<li><p>Es Module 如何解决循环引用问题 ？</p>
</li>
<li><p>exports &#x3D; {} 这种写法为何无效 ？</p>
</li>
<li><p>关于 import() 的动态引入 ？</p>
</li>
<li><p>Es Module 如何改变模块下的私有变量 ？</p>
</li>
</ol>
<h1 id="04-11趣链科技"><a href="#04-11趣链科技" class="headerlink" title="04-11趣链科技"></a>04-11趣链科技</h1><h2 id="介绍实习项目"><a href="#介绍实习项目" class="headerlink" title="介绍实习项目"></a>介绍实习项目</h2><h2 id="介绍微前端"><a href="#介绍微前端" class="headerlink" title="介绍微前端"></a>介绍微前端</h2><p><code>qiankun</code> 是一个基于 <code>single-spa</code> 的微前端实现库，它通过一系列 API 简化了微前端的实现，允许开发者将不同的前端应用组合成一个完整的应用。以下是 <code>qiankun</code> 的一些底层实现细节以及主应用和子应用通信的方式。</p>
<h3 id="qiankun-底层实现"><a href="#qiankun-底层实现" class="headerlink" title="qiankun 底层实现"></a><code>qiankun</code> 底层实现</h3><ol>
<li><p><strong>JavaScript 沙箱</strong>：</p>
<ul>
<li><code>qiankun</code> 通过 JavaScript 沙箱技术隔离主应用和子应用的运行环境。沙箱主要通过代理全局变量来实现，每个微应用都运行在自己的全局上下文中。</li>
</ul>
</li>
<li><p><strong>样式隔离</strong>：</p>
<ul>
<li>为了防止 CSS 污染，<code>qiankun</code> 对子应用的样式进行隔离。它可以使用 Shadow DOM 或者为子应用的样式增加特定的前缀来实现。</li>
</ul>
</li>
<li><p><strong>生命周期钩子</strong>：</p>
<ul>
<li><code>qiankun</code> 实现了一套生命周期钩子，允许在加载、挂载、更新和卸载微应用时进行相应的处理。</li>
</ul>
</li>
<li><p><strong>资源加载</strong>：</p>
<ul>
<li><code>qiankun</code> 使用 <code>fetch</code> API 动态加载微应用的资源文件，包括 HTML、JavaScript 和 CSS。</li>
</ul>
</li>
<li><p><strong>路由代理</strong>：</p>
<ul>
<li><code>qiankun</code> 对浏览器历史 API 进行了劫持，以支持微应用的路由系统，确保路由变化能够被正确处理。</li>
</ul>
</li>
</ol>
<h3 id="主应用和子应用通信方式"><a href="#主应用和子应用通信方式" class="headerlink" title="主应用和子应用通信方式"></a>主应用和子应用通信方式</h3><ol>
<li><p><strong>Props 传递</strong>：</p>
<ul>
<li>类似于 React 或 Vue 组件的 props，<code>qiankun</code> 允许主应用在加载微应用时传递 props。这些 props 可以是简单的数据，也可以是可以调用的函数，用于主子应用间的直接通信。</li>
</ul>
</li>
<li><p><strong>全局变量</strong>：</p>
<ul>
<li>可以通过全局变量在主应用和子应用之间通信。例如，主应用可以将一个全局变量或者函数挂载到 <code>window</code> 对象上，子应用可以访问和使用这些变量或函数。</li>
</ul>
</li>
<li><p><strong>自定义事件（Custom Events）</strong>：</p>
<ul>
<li>主应用和子应用可以通过触发和监听自定义事件来实现通信。这种方式不直接依赖于 <code>qiankun</code> 的 API。</li>
</ul>
</li>
<li><p><strong>状态管理库</strong>：</p>
<ul>
<li>如果主应用和子应用都使用相同的状态管理库（如 Redux、Vuex），可以通过共享一个状态存储来进行通信。</li>
</ul>
</li>
<li><p><strong>消息通道（Message Channel）</strong>：</p>
<ul>
<li>可以使用 <code>window.postMessage</code> 和监听 <code>window</code> 上的 <code>message</code> 事件来在主应用和子应用之间进行跨域通信。</li>
</ul>
</li>
<li><p><strong>Observable 对象</strong>：</p>
<ul>
<li>使用诸如 RxJS 这类响应式编程库中的 Observable 对象，可以在应用之间创建一个可观察的数据流。</li>
</ul>
</li>
</ol>
<p>这些通信方式可以根据应用的实际需要和开发习惯进行选择和使用。在微前端架构中，选择合适的通信机制对于确保应用的独立性和协调一致性非常重要。</p>
<p>Qiankun 是一个基于 single-spa 的微前端框架，提供了更简单的 API 和配置方式，让开发者能够构建大型的、由多个前端应用组合而成的应用系统。在 Qiankun 中，每个子应用都有自己的生命周期，这些生命周期钩子允许主应用在特定时刻介入子应用的状态，实现控制和资源管理。</p>
<h3 id="Qiankun-子应用的生命周期"><a href="#Qiankun-子应用的生命周期" class="headerlink" title="Qiankun 子应用的生命周期"></a>Qiankun 子应用的生命周期</h3><p>以下是 Qiankun 子应用的主要生命周期钩子及其用途：</p>
<ol>
<li><p><strong>bootstrap</strong>：</p>
<ul>
<li><strong>时机</strong>：子应用初次加载时调用。</li>
<li><strong>用途</strong>：用于启动子应用，通常包括初始化资源、依赖项或其它只需执行一次的设置。</li>
</ul>
</li>
<li><p><strong>mount</strong>：</p>
<ul>
<li><strong>时机</strong>：每次子应用需要被激活（即展示到视图中）时调用。</li>
<li><strong>用途</strong>：用于挂载子应用的实例到 DOM，处理状态恢复和事件监听器的添加等。</li>
</ul>
</li>
<li><p><strong>unmount</strong>：</p>
<ul>
<li><strong>时机</strong>：每次子应用需要被卸载（从视图中移除）时调用。</li>
<li><strong>用途</strong>：用于卸载子应用，清除相关资源和事件监听器，保证内存释放，避免内存泄漏。</li>
</ul>
</li>
<li><p><strong>update</strong>（可选）：</p>
<ul>
<li><strong>时机</strong>：主应用或自身传入新的 props 时调用。</li>
<li><strong>用途</strong>：响应 props 变化，执行相关更新逻辑。</li>
</ul>
</li>
</ol>
<h3 id="生命周期的实现"><a href="#生命周期的实现" class="headerlink" title="生命周期的实现"></a>生命周期的实现</h3><p>在子应用中，你通常需要导出这些生命周期钩子的实现。这可以通过单独的函数或对象方法实现。例如，如果你的子应用是用 React 构建的，你的生命周期实现可能如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bootstrap</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;React app bootstraped&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">mount</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, props.<span class="property">container</span> ? props.<span class="property">container</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#root&#x27;</span>) : <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">unmount</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(props.<span class="property">container</span> ? props.<span class="property">container</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#root&#x27;</span>) : <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">update</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// 响应 props 更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>这些生命周期方法对于管理应用状态、资源分配和优化性能至关重要。例如，通过 <code>unmount</code> 方法清理事件监听器和外部插件，可以避免内存泄漏。通过 <code>mount</code> 和 <code>unmount</code> 方法，可以确保子应用只在必要时占用浏览器资源，从而优化整体的应用性能。</p>
<p>了解和合理利用这些生命周期钩子，是使用 Qiankun 微前端框架有效管理多个前端应用的关键。这有助于确保应用的稳定性、响应性和高效性。</p>
<h4 id="CSS的动画了解吗：比如transition"><a href="#CSS的动画了解吗：比如transition" class="headerlink" title="CSS的动画了解吗：比如transition"></a>CSS的动画了解吗：比如transition</h4><h4 id="事件循环机制：宏任务和微任务"><a href="#事件循环机制：宏任务和微任务" class="headerlink" title="事件循环机制：宏任务和微任务"></a>事件循环机制：宏任务和微任务</h4><h4 id="浏览器的存储，cookie，localstorage，sessionstorage"><a href="#浏览器的存储，cookie，localstorage，sessionstorage" class="headerlink" title="浏览器的存储，cookie，localstorage，sessionstorage"></a>浏览器的存储，cookie，localstorage，sessionstorage</h4><h4 id="说一下Websocket"><a href="#说一下Websocket" class="headerlink" title="说一下Websocket"></a>说一下Websocket</h4><blockquote>
<p>WebSocket 是一种在单个TCP连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。他不是HTTP协议，</p>
</blockquote>
<h4 id="节流和防抖的使用场景，闭包"><a href="#节流和防抖的使用场景，闭包" class="headerlink" title="节流和防抖的使用场景，闭包"></a>节流和防抖的使用场景，闭包</h4><h4 id="强缓存和协商缓存：cache-control-Expires-，协商缓存：E-Tag，Last-Modified"><a href="#强缓存和协商缓存：cache-control-Expires-，协商缓存：E-Tag，Last-Modified" class="headerlink" title="强缓存和协商缓存：cache-control+Expires ，协商缓存：E-Tag，Last-Modified"></a>强缓存和协商缓存：<strong>cache-control</strong>+<strong>Expires</strong> ，协商缓存：<strong>E-Tag</strong>，<strong>Last-Modified</strong></h4><h4 id="Promise和一些静态方法（promise-all，promise，race等）"><a href="#Promise和一些静态方法（promise-all，promise，race等）" class="headerlink" title="Promise和一些静态方法（promise.all，promise，race等）"></a>Promise和一些静态方法（promise.all，promise，race等）</h4><p><code>Promise</code> 是JavaScript中用于异步编程的一个重要概念。它代表了一个最终可能完成或失败的操作及其结果值。一个<code>Promise</code>对象有三种状态：</p>
<ul>
<li><code>pending</code>（等待状态）：初始状态，既不是成功，也不是失败状态。</li>
<li><code>fulfilled</code>（成功状态）：操作完成，且成功返回值。</li>
<li><code>rejected</code>（失败状态）：操作完成，但失败，返回拒绝的原因。</li>
</ul>
<p><code>Promise</code>提供了一种更加优雅的处理异步操作的方法，相比于传统的回调函数，它可以减少代码的嵌套，并且更易于理解和维护。</p>
<h2 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a><code>Promise</code>的静态方法</h2><ol>
<li>**Promise.all(iterable)**：当你需要并行执行多个异步操作，并且只有当所有异步操作成功时才继续执行，可以使用<code>Promise.all</code>。</li>
<li>**Promise.allSettled(iterable)**：如果你需要知道一系列异步操作的每一个的结果，不管是成功还是失败，可以使用<code>Promise.allSettled</code>。</li>
<li>**Promise.race(iterable)**：当你有多个异步操作，并且你只关心哪个操作最先完成（或失败），可以使用<code>Promise.race</code>。</li>
<li>**Promise.resolve(value)和Promise.reject(reason)**：这两个方法可以用来创建已经处于完成或拒绝状态的<code>Promise</code>，用于测试或者与其他<code>Promise</code>操作结合使用。</li>
</ol>
<h2 id="Vue2的生命周期"><a href="#Vue2的生命周期" class="headerlink" title="Vue2的生命周期"></a>Vue2的生命周期</h2><blockquote>
<p>创建前后，挂载前后，更新前后，销毁前后</p>
</blockquote>
<p>异步请求的阶段：created，mounted</p>
<h2 id="组件通信的方式"><a href="#组件通信的方式" class="headerlink" title="组件通信的方式"></a>组件通信的方式</h2><ol>
<li>props，$emit；</li>
<li>provide，inject；</li>
<li>Event Bus</li>
<li>vuex</li>
<li>Vue3 Composition API（Vue3）：setup</li>
<li>Refs 和 $parent &#x2F; $children：</li>
</ol>
<h2 id="路由鉴权-1"><a href="#路由鉴权-1" class="headerlink" title="路由鉴权"></a>路由鉴权</h2><p>路由守卫<strong>routerConfig.beforeEach</strong>的<strong>meta.access</strong>的值决定是否允许访问某个路由</p>
<h2 id="微前端生命周期钩子"><a href="#微前端生命周期钩子" class="headerlink" title="微前端生命周期钩子"></a>微前端生命周期钩子</h2><ol>
<li><strong>bootstrap</strong>：子应用的启动</li>
<li><strong>mount</strong>：挂载</li>
<li><strong>onmount</strong>：卸载</li>
</ol>
<p>在微前端架构下，子应用的静态资源路径可能需要动态设置以确保资源加载正确。代码中通过修改<code>__webpack_public_path__</code>来实现这一点。</p>
<h2 id="dom节点事件"><a href="#dom节点事件" class="headerlink" title="dom节点事件"></a>dom节点事件</h2><blockquote>
<p>DOM 事件流描述了从页面中接收事件的顺序，它是一个将事件从窗口发送到具体节点，然后再回传回去的过程。DOM 事件流主要分为三个阶段：<strong>捕获、目标、冒泡</strong></p>
</blockquote>
<h3 id="1-捕获阶段（Capturing-Phase）"><a href="#1-捕获阶段（Capturing-Phase）" class="headerlink" title="1. 捕获阶段（Capturing Phase）"></a>1. 捕获阶段（Capturing Phase）</h3><ul>
<li>事件从 <code>window</code> 对象传导到事件目标的父节点的过程。</li>
<li>在捕获阶段，事件会从文档的根节点开始，经过祖先节点，向下传递到目标节点（触发事件的那个最深层的节点）。</li>
<li>目的是更早地在文档层次中捕捉事件，但是默认情况下，大多数事件处理程序在此阶段不会处理事件。</li>
</ul>
<h3 id="2-目标阶段（Target-Phase）"><a href="#2-目标阶段（Target-Phase）" class="headerlink" title="2. 目标阶段（Target Phase）"></a>2. 目标阶段（Target Phase）</h3><ul>
<li>当事件到达目标元素时。在这个阶段，事件不会进一步传播，而是在目标上触发指定的监听器。</li>
<li>这是事件被实际处理的阶段，可以在这个阶段对事件进行操作或响应。</li>
</ul>
<h3 id="3-冒泡阶段（Bubbling-Phase）"><a href="#3-冒泡阶段（Bubbling-Phase）" class="headerlink" title="3. 冒泡阶段（Bubbling Phase）"></a>3. 冒泡阶段（Bubbling Phase）</h3><ul>
<li>事件从目标元素向上冒泡到文档的根节点。</li>
<li>在冒泡阶段，事件会从目标元素开始，逐级向上传递给祖先节点，一直传到文档的根。</li>
<li>大部分事件处理发生在此阶段，因为它允许一个单一的父级处理器来监听一个元素和它的所有子元素上发生的事件。</li>
</ul>
<h3 id="使用事件流的优点"><a href="#使用事件流的优点" class="headerlink" title="使用事件流的优点"></a>使用事件流的优点</h3><p>利用 DOM 事件流的特性，可以实现更加灵活的事件处理机制，例如事件委托。事件委托是一种利用事件冒泡原理来减少事件处理器数量的技巧。通过在父节点上监听事件，然后根据事件的目标（<code>event.target</code>）来判断如何响应，可以有效地处理动态元素或大量相似元素的事件，这样做既可以减少内存占用，也可以提高程序性能。</p>
<h3 id="设置事件监听的阶段"><a href="#设置事件监听的阶段" class="headerlink" title="设置事件监听的阶段"></a>设置事件监听的阶段</h3><p>在使用 <code>addEventListener</code> 方法为元素添加事件监听器时，可以指定是在捕获阶段还是冒泡阶段触发处理器。这是通过该方法的第三个参数实现的，如果是 <code>true</code>，则在捕获阶段触发；如果是 <code>false</code> 或不设置，则在冒泡阶段触发。</p>
<p>理解 DOM 事件流的工作机制，对于开发复杂的交互式网页应用是非常重要的，它有助于开发者编写出更高效、更可控的事件处理代码。</p>
<h2 id="Vue-2-和-Vue-3-在设计和功能上有许多重要的区别，这些区别旨在提高性能、增加灵活性，以及改进开发体验。下面是-Vue-2-和-Vue-3-之间的一些主要区别："><a href="#Vue-2-和-Vue-3-在设计和功能上有许多重要的区别，这些区别旨在提高性能、增加灵活性，以及改进开发体验。下面是-Vue-2-和-Vue-3-之间的一些主要区别：" class="headerlink" title="Vue 2 和 Vue 3 在设计和功能上有许多重要的区别，这些区别旨在提高性能、增加灵活性，以及改进开发体验。下面是 Vue 2 和 Vue 3 之间的一些主要区别："></a>Vue 2 和 Vue 3 在设计和功能上有许多重要的区别，这些区别旨在提高性能、增加灵活性，以及改进开发体验。下面是 Vue 2 和 Vue 3 之间的一些主要区别：</h2><h3 id="1-性能提升"><a href="#1-性能提升" class="headerlink" title="1. 性能提升"></a>1. 性能提升</h3><p>Vue 3 引入了许多性能优化，包括更快的虚拟 DOM 算法、优化的组件初始化过程、以及基于代理的观察者机制。这些改进使得 Vue 3 在渲染速度、内存占用以及启动时间上相较于 Vue 2 有显著提升。</p>
<h3 id="2-Composition-API"><a href="#2-Composition-API" class="headerlink" title="2. Composition API"></a>2. Composition API</h3><p>Vue 3 引入了一个全新的 Composition API，它提供了一种更灵活的方式来组织和重用逻辑。与 Vue 2 的 Options API 相比，Composition API 使得在相同组件中处理多个功能点变得更加清晰，并且更容易将逻辑提取到可复用的函数中。</p>
<h3 id="3-更好的-TypeScript-支持"><a href="#3-更好的-TypeScript-支持" class="headerlink" title="3. 更好的 TypeScript 支持"></a>3. 更好的 TypeScript 支持</h3><p>Vue 3 从一开始就考虑了对 TypeScript 的支持，使得在使用 TypeScript 开发 Vue 应用时的体验更加流畅。相比之下，Vue 2 的 TypeScript 支持是后来通过社区努力逐步改进的。</p>
<h3 id="4-Fragment、Teleport-和-Suspense"><a href="#4-Fragment、Teleport-和-Suspense" class="headerlink" title="4. Fragment、Teleport 和 Suspense"></a>4. Fragment、Teleport 和 Suspense</h3><ul>
<li><strong>Fragment</strong>: Vue 3 允许组件有多个根节点，解决了 Vue 2 中组件必须有单一根节点的限制。</li>
<li><strong>Teleport</strong>: Vue 3 引入的 Teleport 特性允许将组件的子元素渲染到 DOM 树的其他位置，这对于如模态框或通知之类的 UI 元素非常有用。</li>
<li><strong>Suspense</strong>: Vue 3 新增了 Suspense 组件，为异步组件的加载提供了内置的等待机制，使得处理异步组件变得更加方便。</li>
</ul>
<h3 id="5-响应式系统的重写"><a href="#5-响应式系统的重写" class="headerlink" title="5. 响应式系统的重写"></a>5. 响应式系统的重写</h3><p>Vue 3 的响应式系统从使用 Object.defineProperty 重写为基于 ES6 的 Proxy，这提供了更好的性能和更灵活的响应式能力，同时解决了 Vue 2 中的一些响应式系统限制，如检测属性的添加和删除、数组索引和长度的变化等。</p>
<h3 id="6-更轻量和模块化"><a href="#6-更轻量和模块化" class="headerlink" title="6. 更轻量和模块化"></a>6. 更轻量和模块化</h3><p>Vue 3 的设计更加模块化，允许在打包过程中自动摇树优化（Tree-shaking），这意味着最终的应用只包含真正使用到的功能代码，从而减小了应用大小。</p>
<h3 id="7-新的组件挂载方式和全局-API-更改"><a href="#7-新的组件挂载方式和全局-API-更改" class="headerlink" title="7. 新的组件挂载方式和全局 API 更改"></a>7. 新的组件挂载方式和全局 API 更改</h3><p>Vue 3 更改了组件挂载到 DOM 的方式，以及全局 API（如 <code>Vue.use</code>、<code>Vue.mixin</code> 等）的使用方式，使得它们更适合模块化的项目结构。</p>
<p>尽管 Vue 3 带来了很多新特性和改进，Vue 2 仍然是一个非常稳定和功能丰富的框架，被广泛用于生产环境中。迁移到 Vue 3 是一个值得考虑的步骤，尤其是对于新项目或正在考虑重构的项目。</p>
<h2 id="代码输出："><a href="#代码输出：" class="headerlink" title="代码输出："></a>代码输出：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3 </span></span><br></pre></td></tr></table></figure>

<p>这段JavaScript代码定义了一个名为<code>Fn</code>的构造函数，它没有参数和执行体。接着，在<code>Fn</code>的原型（<code>Fn.prototype</code>）上定义了一个名为<code>add</code>的方法和一个名为<code>count</code>的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;<span class="comment">//`function Fn() &#123;&#125;`：这行代码定义了一个空的构造函数`Fn`。</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//这行代码在`Fn`的原型对象上添加了一个方法`add`。</span></span><br><span class="line">    <span class="comment">//这个`add`方法的作用是将实例上的`count`属性值增加1，并且在控制台打印出来。这里的`this`指的是调用`add`方法的实例。</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`this.count: <span class="subst">$&#123;<span class="variable language_">this</span>.count&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line">fn1.<span class="title function_">add</span>(); <span class="comment">// this.count: 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line">fn2.<span class="title function_">add</span>(); <span class="comment">// this.count: 1</span></span><br><span class="line"><span class="comment">//this.count:1</span></span><br><span class="line"><span class="comment">//this.count:1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>Fn.prototype.count = 0;</code>：这行代码在<code>Fn</code>的原型对象上设置了一个属性<code>count</code>，初始值为0。所有通过<code>Fn</code>构造函数创建的实例都会共享这个原型上的<code>count</code>属性。但是，当使用<code>add</code>方法时，由于属性提升（即实例上没有<code>count</code>属性，所以会在实例上创建一个新的<code>count</code>属性，并且将其值设置为原型上<code>count</code>的当前值加1），每个实例都会有自己独立的<code>count</code>属性。</li>
</ol>
<p>然后代码创建了两个<code>Fn</code>的实例，并且分别调用了它们的<code>add</code>方法：</p>
<ul>
<li><p><code>let fn1 = new Fn();</code>：通过<code>new</code>关键字和<code>Fn</code>构造函数创建了一个新的实例<code>fn1</code>。</p>
</li>
<li><p><code>fn1.add();</code>：调用<code>fn1</code>实例的<code>add</code>方法，这会使<code>fn1</code>实例上的<code>count</code>属性值从0变为1，并打印出<code>this.count: 1</code>。</p>
</li>
<li><p><code>let fn2 = new Fn();</code>：同样地，创建了另一个名为<code>fn2</code>的<code>Fn</code>实例。</p>
</li>
<li><p><code>fn2.add();</code>：调用<code>fn2</code>实例的<code>add</code>方法，和<code>fn1</code>一样，这也会使<code>fn2</code>实例上的<code>count</code>属性值从0变为1，并打印出<code>this.count: 1</code>。</p>
</li>
</ul>
<p>值得注意的是，尽管<code>count</code>属性最初是定义在<code>Fn</code>的原型上的，当调用<code>add</code>方法时，由于<code>this.count++</code>这行代码的作用，实际上是在各自的实例上创建了一个新的<code>count</code>属性，并且这个属性不再和原型上的<code>count</code>属性共享。所以，即使是<code>Fn.prototype.count</code>的值没有变化，每个实例上的<code>count</code>属性都是独立的，它们的值互不影响。</p>
<h2 id="Vite-和-webpack-区别"><a href="#Vite-和-webpack-区别" class="headerlink" title="Vite 和 webpack 区别"></a>Vite 和 webpack 区别</h2><p>Vite 和 Webpack 是前端开发中常用的两个现代 JavaScript 构建工具，它们在模块打包和开发服务器方面有着根本的不同。了解这两个工具的区别对于选择适合项目的构建工具非常重要。</p>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><ul>
<li><strong>开发模式：</strong> Vite 在开发模式下使用原生 ES 模块导入（ESM），这允许浏览器直接加载模块，而无需打包。这种方法可以显著提高冷启动时间和模块热更新（HMR）的速度。</li>
<li><strong>生产模式：</strong> 在构建生产版本时，Vite 使用 Rollup 进行打包。Rollup 通常被认为在打包库和轻量级应用时比 Webpack 更高效。</li>
<li><strong>优点：</strong> Vite 提供了极快的启动时间和即时模块热替换（HMR），因为它不需要预打包。它还利用现代浏览器支持的 ES 模块导入，减少了不必要的代码转换。</li>
<li><strong>使用场景：</strong> Vite 特别适合 Vue 和 React 项目，但也可以配置用于其他框架。它的设计理念使其特别适合需要快速开发和迭代的现代网页应用（SPA）。</li>
</ul>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ul>
<li><strong>开发模式：</strong> Webpack 在开发和生产模式下都依赖于将项目的所有依赖打包成一个（或多个）bundle的概念。在开发模式下，它提供了模块热替换（HMR）但通常启动和编译速度比 Vite 慢。</li>
<li><strong>生产模式：</strong> Webpack 使用复杂的算法来优化输出的大小和加载时间，包括代码拆分、树摇（Tree-shaking）、懒加载等。</li>
<li><strong>优点：</strong> Webpack 提供了高度灵活和可配置的打包策略，支持广泛的插件生态系统，适合于需要复杂打包逻辑的大型应用。</li>
<li><strong>使用场景：</strong> Webpack 适用于各种项目，从简单的静态网站到复杂的单页应用（SPA）。它的灵活性和插件生态使其成为许多企业级应用的首选。</li>
</ul>
<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>启动速度：</strong> Vite 在开发模式下提供了更快的启动和热更新速度，因为它避免了预打包的步骤。</li>
<li><strong>打包策略：</strong> Vite 利用现代浏览器的 ES 模块特性，而 Webpack 使用传统的打包方法，将所有资源和代码编译成一个或多个文件。</li>
<li><strong>构建工具链：</strong> Vite 默认使用 Rollup 作为生产环境的打包工具，而 Webpack 自身就是一个打包工具。</li>
<li><strong>插件和生态系统：</strong> Webpack 拥有一个成熟的插件生态系统，几乎可以定制任何构建流程。Vite 也支持插件，但相对较新，生态系统仍在发展中。</li>
<li><strong>配置复杂度：</strong> Vite 旨在提供开箱即用的体验，其默认配置已经足够多数应用，而 Webpack 通常需要更多的配置和优化。</li>
</ul>
<p>选择 Vite 还是 Webpack 取决于项目需求、团队熟悉度和特定场景。对于新项目，特别是当开发速度和现代浏览器特性是优先考虑时，Vite 可能是一个更好的选择。对于需要复杂构建流程和已经深度依赖于 Webpack</p>
<p> 生态系统的项目，Webpack 仍然是一个强大的选择。</p>
<h2 id="Vue2-升级-Vue3-需要注意什么"><a href="#Vue2-升级-Vue3-需要注意什么" class="headerlink" title="Vue2 升级 Vue3 需要注意什么"></a>Vue2 升级 Vue3 需要注意什么</h2><h2 id="数组去重有哪些方法"><a href="#数组去重有哪些方法" class="headerlink" title="数组去重有哪些方法"></a>数组去重有哪些方法</h2><p>数组去重是编程中常见的一个需求，尤其是在处理大量数据时。JavaScript 提供了多种方法来实现数组的去重。以下是一些常用的方法：</p>
<h3 id="1-使用-Set-和展开运算符"><a href="#1-使用-Set-和展开运算符" class="headerlink" title="1. 使用 Set 和展开运算符"></a>1. 使用 Set 和展开运算符</h3><p>这是最简单和最现代的方法之一，利用了 <code>Set</code> 对象可以存储任何类型的唯一值的特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = [...<span class="keyword">new</span> <span class="title class_">Set</span>(array)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray); <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用-Set-和-Array-from"><a href="#2-使用-Set-和-Array-from" class="headerlink" title="2. 使用 Set 和 Array.from()"></a>2. 使用 Set 和 Array.from()</h3><p>与使用展开运算符类似，但是通过 <code>Array.from()</code> 方法将 <code>Set</code> 转换成数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray); <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用-filter-方法"><a href="#3-使用-filter-方法" class="headerlink" title="3. 使用 filter 方法"></a>3. 使用 filter 方法</h3><p>通过数组的 <code>filter()</code> 方法结合 <code>indexOf()</code> 方法来过滤重复元素。这种方法不需要额外的数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> array.<span class="title function_">indexOf</span>(item) === index);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray); <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-使用-reduce-方法"><a href="#4-使用-reduce-方法" class="headerlink" title="4. 使用 reduce 方法"></a>4. 使用 reduce 方法</h3><p>使用 <code>reduce()</code> 方法累加数组中的元素，结合条件判断实现去重。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!acc.<span class="title function_">includes</span>(current)) &#123;</span><br><span class="line">    acc.<span class="title function_">push</span>(current);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray); <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="5-使用-Map-数据结构"><a href="#5-使用-Map-数据结构" class="headerlink" title="5. 使用 Map 数据结构"></a>5. 使用 Map 数据结构</h3><p>利用 <code>Map</code> 的键唯一的特性来去重，适合于数组元素是对象这类比较复杂的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Map</span>(array.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> [item, item])).<span class="title function_">values</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray); <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="6-循环比较（传统方法）"><a href="#6-循环比较（传统方法）" class="headerlink" title="6. 循环比较（传统方法）"></a>6. 循环比较（传统方法）</h3><p>传统的双重循环检查方法，性能较低，但在一些特定情况下仍然有其用途。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> uniqueArray = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(uniqueArray.<span class="title function_">indexOf</span>(array[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">    uniqueArray.<span class="title function_">push</span>(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray); <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>根据你的具体需求（比如是否考虑到数组中元素的类型、执行效率等），可以选择最适合的方法进行数组去重。对于大多数情况，使用 <code>Set</code> 和展开运算符或 <code>Array.from()</code> 是最简洁和现代的解决方案。</p>
<p>CSS怎么解析选择器<br>2、V8解析执行JavaScript代码过程<br>3、script标签<br>4、子元素里面绝对定位，设置宽高，能否撑起父元素<br>5、怎么形成BFC<br>6、ES6新特性<br>7、ES6新增什么作用域，之前有什么作用域<br>8、类型转换<br>9、代码题——立即执行函数能否访问到全局变量<br>10、React——setState同步异步<br>11、React父子组件通信</p>
<h1 id="0412网易"><a href="#0412网易" class="headerlink" title="0412网易"></a>0412网易</h1><h2 id="介绍项目，项目的适配不是基于移动端的适配，针对不同的电脑"><a href="#介绍项目，项目的适配不是基于移动端的适配，针对不同的电脑" class="headerlink" title="介绍项目，项目的适配不是基于移动端的适配，针对不同的电脑"></a>介绍项目，项目的适配不是基于移动端的适配，针对不同的电脑</h2><h2 id="盒模型以及组成"><a href="#盒模型以及组成" class="headerlink" title="盒模型以及组成"></a>盒模型以及组成</h2><h2 id="事件流-捕获、目标、冒泡，如果有1000个事件需要触发，如何解决？–事件代理，原生事件问得多"><a href="#事件流-捕获、目标、冒泡，如果有1000个事件需要触发，如何解决？–事件代理，原生事件问得多" class="headerlink" title="事件流:捕获、目标、冒泡，如果有1000个事件需要触发，如何解决？–事件代理，原生事件问得多"></a>事件流:捕获、目标、冒泡，如果有1000个事件需要触发，如何解决？–事件代理，原生事件问得多</h2><h2 id="css如何布局？flex-1–flex-grow-flex-basis-flex-shrink"><a href="#css如何布局？flex-1–flex-grow-flex-basis-flex-shrink" class="headerlink" title="css如何布局？flex:1–flex-grow,flex-basis,flex-shrink"></a>css如何布局？<code>flex:1</code>–flex-grow,flex-basis,flex-shrink</h2><img src="https://lofter.lf127.net/1698569107364/SCR-20231029-nrdl.png" alt="img" style="zoom:50%;" />

<p>左右浮动，上面设置右边的flex：1，右边的文字设置超过两行隐藏</p>
<h2 id="css的动画-transition-和animation"><a href="#css的动画-transition-和animation" class="headerlink" title="css的动画,transition 和animation"></a>css的动画,<code>transition</code> 和<code>animation</code></h2><p><strong>transition</strong>：只能在初始状态和结束状态之间提供动画效果，不支持中间状态或复杂的动画序列。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: background-color <span class="number">0.5s</span> ease;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**animation:**用于更复杂的动画效果，它允许你通过关键帧（@<strong>keyframes</strong> 规则）定义动画的中间步骤。你可以控制动画的中间状态、循环次数、方向、延迟等。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> example &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;<span class="attribute">background-color</span>: blue;&#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;<span class="attribute">background-color</span>: red;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: example;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack、vite，代码中如何配置，举例说明"><a href="#webpack、vite，代码中如何配置，举例说明" class="headerlink" title="webpack、vite，代码中如何配置，举例说明"></a>webpack、vite，代码中如何配置，举例说明</h2><p>分成不同的环境：生产、灰度、线上，</p>
<h2 id="ts的泛型、接口、枚举"><a href="#ts的泛型、接口、枚举" class="headerlink" title="ts的泛型、接口、枚举"></a>ts的泛型、接口、枚举</h2><ol>
<li>定义泛型函数<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output1 = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);  <span class="comment">// 类型为 string</span></span><br><span class="line"><span class="keyword">let</span> output2 = identity&lt;<span class="built_in">number</span>&gt;(<span class="number">100</span>);         <span class="comment">// 类型为 number</span></span><br></pre></td></tr></table></figure></li>
<li>ts的泛型有属性的时候可以使用extends关键字进行约束，在这个例子中，泛型 T 被约束了，它必须符合 Lengthwise 接口，这意味着 T 必须有一个 length 属性。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);  <span class="comment">//  它有一个 .length 属性</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>枚举遍历，for …  in<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title class_">Red</span>,</span><br><span class="line">    <span class="title class_">Green</span>,</span><br><span class="line">    <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">in</span> <span class="title class_">Color</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(color); <span class="comment">// 打印出 &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h1><h2 id="cookie如何设置跨域"><a href="#cookie如何设置跨域" class="headerlink" title="cookie如何设置跨域"></a>cookie如何设置跨域</h2><p><strong>Cookie</strong>跨域实现主要依赖于<strong>CORS（Cross-Origin Resource Sharing）</strong>策略。在服务器端设置<strong>Access-Control-Allow-Credentials</strong>和<strong>Access-Control-Allow-Origin</strong>响应头，并在<strong>AJAX</strong>请求中设置<strong>withCredentials</strong>为<strong>true</strong>。</p>
<p>服务器端设置（以<strong>Node.js</strong>的<strong>Express</strong>为例）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://example.com&quot;</span>); <span class="comment">// 允许的域</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 允许cookies</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET, POST, OPTIONS&quot;</span>); <span class="comment">// 允许的方法</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With, X-HTTP-Method-Override, Content-Type, Accept&quot;</span>); <span class="comment">// 允许的头</span></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>客户端设置（以<strong>JavaScript</strong>的<strong>XMLHttpRequest</strong>为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;GET&quot;, &quot;http://example.com/path&quot;, true);</span><br><span class="line"></span><br><span class="line">// 设置withCredentials为true来发送cookies</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>确保服务器响应头中的<strong>Access-Control-Allow-Origin</strong>与实际请求的域相匹配，并且如果<strong>withCredentials</strong>为<strong>true</strong>，则<strong>Access-Control-Allow-Credentials</strong>也必须设置为<strong>true</strong>。</p>
<h1 id="0415DeepLang"><a href="#0415DeepLang" class="headerlink" title="0415DeepLang"></a>0415DeepLang</h1><h2 id="postmessage和http通信"><a href="#postmessage和http通信" class="headerlink" title="postmessage和http通信"></a>postmessage和http通信</h2><h2 id="浏览器原理，事件循环和url，"><a href="#浏览器原理，事件循环和url，" class="headerlink" title="浏览器原理，事件循环和url，"></a>浏览器原理，事件循环和url，</h2><h2 id="ES6创建的函数我不想他被new创造新的实例"><a href="#ES6创建的函数我不想他被new创造新的实例" class="headerlink" title="ES6创建的函数我不想他被new创造新的实例"></a>ES6创建的函数我不想他被new创造新的实例</h2><p>使用<strong>new target：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;myFunction cannot be called as a constructor.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is my function.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myFunction</span>();  <span class="comment">// 正常输出 &quot;This is my function.&quot;</span></span><br><span class="line"><span class="comment">// new myFunction();  // 抛出错误</span></span><br></pre></td></tr></table></figure>



<h2 id="对es6的理解"><a href="#对es6的理解" class="headerlink" title="对es6的理解"></a>对es6的理解</h2><h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><h2 id="用户1修改了数据，用户2及时更新查看，你们是用的是什么方式？请求的数据如何不请求http的方式进行更新"><a href="#用户1修改了数据，用户2及时更新查看，你们是用的是什么方式？请求的数据如何不请求http的方式进行更新" class="headerlink" title="用户1修改了数据，用户2及时更新查看，你们是用的是什么方式？请求的数据如何不请求http的方式进行更新"></a>用户1修改了数据，用户2及时更新查看，你们是用的是什么方式？请求的数据如何不请求http的方式进行更新</h2><p>在多用户环境中，确保所有用户看到的数据都是最新的，是一个常见的挑战。特别是在你提到的场景中，用户1修改了数据后，用户2需要无需发送传统HTTP请求就能看到更新的数据。为此，可以使用以下技术和策略：</p>
<h3 id="1-WebSocket"><a href="#1-WebSocket" class="headerlink" title="1. WebSocket"></a>1. WebSocket</h3><p>WebSocket 提供了一种在单个连接上进行全双工、双向交互的方式。服务器可以通过WebSocket连接直接向客户端推送数据，这对于实时应用来说非常有用。当用户1更新数据时，服务器可以通过所有打开的WebSocket连接向其他用户推送这些更改。</p>
<p><strong>实施步骤：</strong></p>
<ul>
<li>建立WebSocket连接。</li>
<li>当用户1提交更新时，服务器处理这些更改并通过WebSocket向所有其他在线用户广播更新。</li>
<li>客户端收到推送的数据后，更新UI以反映最新信息。</li>
</ul>
<h3 id="2-Server-Sent-Events-SSE"><a href="#2-Server-Sent-Events-SSE" class="headerlink" title="2. Server-Sent Events (SSE)"></a>2. Server-Sent Events (SSE)</h3><p>Server-Sent Events 允许服务器向浏览器推送事件。与WebSocket相比，SSE是单向的，从服务器到客户端，这在只需要服务器推送而不需要从客户端到服务器的消息传递的应用中非常有效。</p>
<p><strong>实施步骤：</strong></p>
<ul>
<li>客户端设置监听特定URI的SSE。</li>
<li>当用户1更新数据时，服务器将这些更新作为事件发送给所有监听该事件的客户端。</li>
<li>客户端接收到这些事件后，更新页面数据。</li>
</ul>
<h3 id="3-使用轮询或长轮询"><a href="#3-使用轮询或长轮询" class="headerlink" title="3. 使用轮询或长轮询"></a>3. 使用轮询或长轮询</h3><p>如果WebSocket或SSE不适用于您的情况，轮询是另一种确保用户看到最新数据的方法，尽管它不如前两种方法实时。轮询涉及定期发送HTTP请求以检查更新，而长轮询则保持连接打开直到有更新可发送。</p>
<p><strong>实施步骤：</strong></p>
<ul>
<li>客户端每隔几秒发送一次HTTP请求，询问服务器是否有数据更新。</li>
<li>服务器响应请求，如果有更新则发送更新数据。</li>
</ul>
<h3 id="4-使用Pub-x2F-Sub模型的服务"><a href="#4-使用Pub-x2F-Sub模型的服务" class="headerlink" title="4. 使用Pub&#x2F;Sub模型的服务"></a>4. 使用Pub&#x2F;Sub模型的服务</h3><p>使用像Google Firebase Realtime Database这样的Pub&#x2F;Sub模型服务，可以允许客户端订阅数据更新，并在数据发生变化时接收实时更新。</p>
<p><strong>实施步骤：</strong></p>
<ul>
<li>客户端在应用中订阅特定数据。</li>
<li>任何数据更改都会触发通知，所有订阅了这些数据的客户端将自动接收更新。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据你的应用需求（如用户基数、预期负载、实时性需求等）和技术堆栈，你可以选择最适合的方法。WebSocket和SSE提供了更加实时的数据同步方案，而轮询则是一种更简单但请求量较大的解决方案。使用如Firebase这样的实时数据库可以简化开发工作，但可能会引入外部依赖和额外成本。</p>
<h2 id="封装一个hooks"><a href="#封装一个hooks" class="headerlink" title="封装一个hooks"></a>封装一个hooks</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useWestate</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(initialState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">customSetState</span> = (<span class="params">newState</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">set</span>:<span class="string">&quot;1111&quot;</span>,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, customSetState];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useWestate;</span><br></pre></td></tr></table></figure>

<h2 id="现在我有一个文件，下载需要8s，如何使用协商缓存和强缓存进行优化？"><a href="#现在我有一个文件，下载需要8s，如何使用协商缓存和强缓存进行优化？" class="headerlink" title="现在我有一个文件，下载需要8s，如何使用协商缓存和强缓存进行优化？"></a>现在我有一个文件，下载需要8s，如何使用协商缓存和强缓存进行优化？</h2><p>对于文件下载缓慢的问题，正确地使用HTTP缓存策略可以显著提高性能。在HTTP缓存中，主要分为<strong>强缓存</strong>和<strong>协商缓存</strong>。这两种缓存策略可以有效减少不必要的网络请求，加快文件访问速度。以下是如何选择和使用这两种缓存策略来优化你的文件下载问题：</p>
<h3 id="强缓存-Strong-Caching"><a href="#强缓存-Strong-Caching" class="headerlink" title="强缓存 (Strong Caching)"></a>强缓存 (Strong Caching)</h3><p>强缓存直接从浏览器缓存中获取资源，不与服务器进行交互，除非缓存过期。设置强缓存的方法主要是通过<code>Cache-Control</code> 和 <code>Expires</code> HTTP响应头实现。</p>
<ul>
<li><p><strong>Cache-Control</strong>: 最常用的缓存控制指令包括<code>max-age</code>（资源可以缓存的最大时间，单位是秒）和<code>public</code>（指示响应可被任何缓存区缓存）。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=31536000</span><br></pre></td></tr></table></figure>
<p>这表示资源将被缓存并在一年后过期，非常适用于不经常变动的文件。</p>
</li>
<li><p><strong>Expires</strong>: 指定资源的过期日期和时间。在<code>Cache-Control</code>出现之前就已存在，通常与<code>Cache-Control</code>一起使用以保证兼容性。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 01 Dec 2022 16:00:00 GMT</span><br></pre></td></tr></table></figure>
<p>如果设置了<code>Cache-Control</code>的<code>max-age</code>，通常不需要<code>Expires</code>。</p>
</li>
</ul>
<h3 id="协商缓存-Negotiation-Caching"><a href="#协商缓存-Negotiation-Caching" class="headerlink" title="协商缓存 (Negotiation Caching)"></a>协商缓存 (Negotiation Caching)</h3><p>当强缓存过期后，协商缓存允许浏览器向服务器发出请求，询问资源是否有更新。如果服务器确认资源未更新（通过发送HTTP状态码304），浏览器将从本地缓存加载资源。</p>
<ul>
<li><p><strong>Last-Modified &#x2F; If-Modified-Since</strong>: 服务器在响应中发送<code>Last-Modified</code>日期，浏览器下次请求时发送<code>If-Modified-Since</code>，询问服务器在该日期后资源是否被修改。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ETag &#x2F; If-None-Match</strong>: 服务器发送资源的ETag（一种标识符），浏览器使用<code>If-None-Match</code>来发送ETag，检查资源是否有变动。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;686897696a7c876b7e&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="选择适合的缓存策略"><a href="#选择适合的缓存策略" class="headerlink" title="选择适合的缓存策略"></a>选择适合的缓存策略</h3><p>对于你的文件下载问题，考虑以下因素：</p>
<ul>
<li><strong>文件变动频率</strong>：如果文件不经常更新，使用强缓存是一个好选择。可以通过设置<code>Cache-Control</code>的<code>max-age</code>为一个相对较长的值来实现。</li>
<li><strong>实时性要求</strong>：如果文件更新不频繁但需要保证用户能快速获取最新版本的文件，可以结合使用强缓存和协商缓存。强缓存确保在文件不变时快速加载，协商缓存确保文件一旦更新，用户能立即获取最新版本。</li>
</ul>
<h3 id="实施示例"><a href="#实施示例" class="headerlink" title="实施示例"></a>实施示例</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=86400</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;686897696a7c876b7e&quot;</span><br></pre></td></tr></table></figure>

<p>这种设置意味着文件将被缓存一天，每天浏览器会检查一次文件是否更新。这样可以显著减少不必要的下载时间，同时保持文件的相对新鲜度。如果你的文件是用户每次都需要最新版的，可以适当减少<code>max-age</code>值，或者仅依赖ETag进行更频繁的检查。</p>
<p>通过这种方式，你可以有效利用HTTP缓存提高文件的访问速度和用户体验。</p>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>http的head有哪些</p>
<p>http协议</p>
<p>不使用递归实现中序遍历：栈</p>
<p>mysql的事务有哪些</p>
<h2 id="useMemo和useEffect的区别"><a href="#useMemo和useEffect的区别" class="headerlink" title="useMemo和useEffect的区别"></a>useMemo和useEffect的区别</h2><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><strong>主要用途：</strong></p>
<ul>
<li><strong>性能优化</strong>：避免在每次渲染时进行高开销的计算。</li>
<li><strong>记忆化复杂派生数据</strong>：基于依赖计算得到的数据，只有当依赖改变时，才重新计算。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> expensiveValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">computeExpensiveValue</span>(a, b);</span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，只有当<code>a</code>或<code>b</code>变化时，函数<code>computeExpensiveValue</code>才会被调用。</p>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><blockquote>
<p><code>useEffect</code>是用于在函数组件中执行副作用的钩子。副作用指的是那些对外部世界产生影响的操作，比如数据获取、手动修改DOM和订阅事件。<code>useEffect</code>同样接收一个函数和一个依赖数组，但它的工作方式与<code>useMemo</code>大不相同。</p>
</blockquote>
<p><strong>主要用途：</strong></p>
<ul>
<li><strong>与外部世界的交互</strong>：执行与渲染无关的操作，如API调用、订阅或定时器。</li>
<li><strong>资源清理</strong>：在组件卸载时进行清理，如取消订阅或清除定时器。</li>
<li><strong>DOM更新后的操作</strong>：在组件和DOM更新后执行操作。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = dataSource.<span class="title function_">subscribe</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清理订阅</span></span><br><span class="line">    subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [dataSource]);</span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>useEffect</code>用于订阅一个数据源，依赖数组确保只在<code>dataSource</code>变化时重新订阅。</p>
<h3 id="执行时机的区别"><a href="#执行时机的区别" class="headerlink" title="执行时机的区别"></a>执行时机的区别</h3><ul>
<li><p><strong>useMemo</strong>：</p>
<ul>
<li>在组件渲染过程中执行，即同步执行。因为它可能会影响渲染输出的内容，必须在渲染流程中完成。</li>
</ul>
</li>
<li><p><strong>useEffect</strong>：</p>
<ul>
<li>在组件渲染到屏幕之后执行，即异步执行。这意味着它不会阻塞浏览器的绘制过程，适用于那些对渲染结果无直接影响的操作。</li>
</ul>
</li>
</ul>
<p>总的来说，<code>useMemo</code>主要用于计算优化，以减少组件的重渲染成本；而<code>useEffect</code>主要用于处理副作用，实现与应用的其他部分的交互。正确的使用这两个钩子，可以提高应用的性能和响应速度。</p>
<h2 id="父子传值-useRef"><a href="#父子传值-useRef" class="headerlink" title="父子传值:useRef"></a>父子传值:useRef</h2><p>子组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  alertSomething = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;这是子组件的方法！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Child</span>;</span><br></pre></td></tr></table></figure>

<p>父组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> childRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (childRef.<span class="property">current</span>) &#123;</span><br><span class="line">      childRef.<span class="property">current</span>.<span class="title function_">alertSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;childRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>调用子组件的方法<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Parent</span>;</span><br></pre></td></tr></table></figure>



<h2 id="vue不仅仅是使用路由进行鉴权"><a href="#vue不仅仅是使用路由进行鉴权" class="headerlink" title="vue不仅仅是使用路由进行鉴权"></a>vue不仅仅是使用路由进行鉴权</h2><h2 id="promise-all如何在接受到rejected也成功返回？promise-race"><a href="#promise-all如何在接受到rejected也成功返回？promise-race" class="headerlink" title="promise.all如何在接受到rejected也成功返回？promise.race"></a>promise.all如何在接受到rejected也成功返回？promise.race</h2><p>答：通过catch</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h2 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h2><h2 id="vuex全局状态管理"><a href="#vuex全局状态管理" class="headerlink" title="vuex全局状态管理"></a>vuex全局状态管理</h2><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式和库。它以集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 非常适用于大型单页应用，它可以帮助你更好地在组件外部管理状态，让状态的变化更加可追踪和易于调试。</p>
</blockquote>
<h3 id="Vuex-的核心概念"><a href="#Vuex-的核心概念" class="headerlink" title="Vuex 的核心概念"></a>Vuex 的核心概念</h3><ol>
<li><p><strong>State</strong></p>
<ul>
<li>Vuex 使用单一状态树 —— 用一个对象就包含了全部的应用层级状态。每个应用将仅仅包含一个 store 实例。</li>
<li>状态存储是响应式的，Vue组件从 store 中读取状态，并且当状态发生变化时，相应的组件也会相应地得到高效更新。</li>
</ul>
</li>
<li><p><strong>Getters</strong></p>
<ul>
<li>类似于 Vue 的计算属性，getters 可以用于从 store 的 state 中派生出一些状态，例如过滤列表、计数等。</li>
<li>Getters 会接受 state 作为其第一个参数，也可以接受其他 getters 作为第二个参数。</li>
</ul>
</li>
<li><p><strong>Mutations</strong></p>
<ul>
<li>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型</strong> (type) 和一个 <strong>处理函数</strong> (handler)。</li>
<li>Mutation 必须是同步函数。</li>
</ul>
</li>
<li><p><strong>Actions</strong></p>
<ul>
<li>Action 类似于 mutation，不同在于：<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
</li>
<li>Action 函数接收一个与 store 实例具有相同方法和属性的 context 对象，因此可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</li>
</ul>
</li>
<li><p><strong>Modules</strong></p>
<ul>
<li>Vuex 允许我们将 store 分割成模块（module），每个模块拥有自己的 state、mutation、action、getter，甚至是嵌套子模块 —— 从而允许我们对复杂的应用进行状态管理。</li>
<li>模块内部的 mutation 和 getter 接收的第一个参数是模块的局部状态对象。</li>
</ul>
</li>
</ol>
<h3 id="Vuex-的使用场景"><a href="#Vuex-的使用场景" class="headerlink" title="Vuex 的使用场景"></a>Vuex 的使用场景</h3><ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<h3 id="Vuex-的使用示例"><a href="#Vuex-的使用示例" class="headerlink" title="Vuex 的使用示例"></a>Vuex 的使用示例</h3><p>以下是一个简单的 Vuex store 的定义示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doubleCount</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span> * <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementIfOdd</span>(<span class="params">&#123; commit, state &#125;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.<span class="property">count</span> % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>在组件中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; doubleCount &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;incrementIfOdd&quot;&gt;Increment if odd&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState, mapGetters, mapActions &#125; from &#x27;vuex&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([</span><br><span class="line">      &#x27;count&#x27;</span><br><span class="line">    ]),</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      &#x27;doubleCount&#x27;</span><br><span class="line">    ]),</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      &#x27;increment&#x27;,</span><br><span class="line">      &#x27;incrementIfOdd&#x27;</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>Vuex 提供了一个集中存储所有组件状态的方式，并以规范的方式更新状态，易于维护和监控状态变化，特别适合处理大型、复杂的应用中多个组件共享状态的情形。</p>
<h1 id="完美世界-1"><a href="#完美世界-1" class="headerlink" title="完美世界"></a>完美世界</h1><h2 id="介绍一下fiber"><a href="#介绍一下fiber" class="headerlink" title="介绍一下fiber"></a>介绍一下fiber</h2><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><p>箭头函数是在ES6中引入的，提供了一种更简洁的方式来写函数表达式。箭头函数与普通函数（如函数声明或函数表达式）相比，有几个主要区别：</p>
<ol>
<li><p><strong>语法更简洁</strong>：</p>
<ul>
<li>箭头函数提供了更短的函数语法。例如，一个普通的函数表达式 <code>function(x, y) &#123; return x + y; &#125;</code> 可以用箭头函数写为 <code>(x, y) =&gt; x + y</code>。</li>
</ul>
</li>
<li><p>**没有自己的 <code>this</code>**：</p>
<ul>
<li>在箭头函数中，<code>this</code> 关键字具有其封闭执行环境的上下文，这与普通函数不同，普通函数的 <code>this</code> 指向在运行时被调用时的上下文（如由一个对象调用）。</li>
<li>这使得箭头函数特别适合用在需要维持上下文的情况，如在回调函数和方法链中。</li>
</ul>
</li>
<li><p><strong>不绑定 <code>arguments</code> 对象</strong>：</p>
<ul>
<li>箭头函数不提供 <code>arguments</code> 对象。如果你需要访问传给函数的参数列表，应使用剩余参数语法（<code>...args</code>）代替。</li>
</ul>
</li>
<li><p><strong>不可以使用 <code>new</code> 操作符</strong>：</p>
<ul>
<li>箭头函数不能用作构造函数，不可以使用 <code>new</code> 操作符，因为它们没有 <code>[[Construct]]</code> 方法。尝试对箭头函数使用 <code>new</code> 会抛出一个错误。</li>
</ul>
</li>
<li><p>**不绑定 <code>super</code>**：</p>
<ul>
<li>箭头函数不绑定 <code>super</code> 关键字。在使用类的继承时，这一点需要注意。</li>
</ul>
</li>
<li><p><strong>不能用作生成器函数</strong>：</p>
<ul>
<li>箭头函数不能使用 <code>yield</code> 关键字，在其内部使用会导致语法错误。</li>
</ul>
</li>
</ol>
<p>总结来说，箭头函数主要用于那些不需要绑定自身 <code>this</code>、不用作构造函数、并且更注重简洁性的场合。由于它们在功能上的这些限制，它们并不总是可以替代普通函数。</p>
<h2 id="hooks可以写在if判断语句里吗"><a href="#hooks可以写在if判断语句里吗" class="headerlink" title="hooks可以写在if判断语句里吗"></a>hooks可以写在if判断语句里吗</h2><p>在React中，Hooks不能写在条件语句（如<code>if</code>）、循环、嵌套函数或任何不是React函数组件顶层的地方。这是因为Hooks必须按照相同的顺序在每次组件渲染时被调用，以保证Hooks状态的正确性。将Hooks放在条件语句中使用可能会破坏这种顺序，导致不可预测的结果。</p>
<h3 id="为什么Hooks不能放在条件语句中"><a href="#为什么Hooks不能放在条件语句中" class="headerlink" title="为什么Hooks不能放在条件语句中"></a>为什么Hooks不能放在条件语句中</h3><p>React的Hooks功能依赖于调用顺序。每次组件渲染时，React按照Hooks被调用的顺序来维护和更新状态。如果你将Hook放入一个条件语句中，那么在某些渲染时Hook可能被调用，而在另一些渲染时可能不被调用，这将破坏React对Hooks调用顺序的跟踪。</p>
<h3 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h3><p>以下是一个错误的使用示例，展示了将<code>useState</code>放在一个<code>if</code>语句中的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">&#123; condition &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>); <span class="comment">// 错误用法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种用法会导致React无法正确追踪<code>count</code>状态的变化，可能会引发运行时错误。</p>
<h3 id="正确用法"><a href="#正确用法" class="headerlink" title="正确用法"></a>正确用法</h3><p>如果你需要根据条件初始化状态或进行其他操作，你应该将条件逻辑放在Hook内部，而不是将Hook放在条件语句中。以下是一个改进的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">&#123; condition &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(condition ? <span class="number">10</span> : <span class="number">0</span>); <span class="comment">// 在Hook内部使用条件</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">      <span class="comment">// 做一些只有在条件成立时才需要做的事情</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [condition]); <span class="comment">// 将条件作为依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个改进的例子中，<code>useState</code>和<code>useEffect</code>都被放在组件的顶层，并根据条件以适当的方式使用。这保证了Hooks的调用顺序是一致的，同时也能根据不同的条件执行不同的逻辑。</p>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>总的来说，React Hooks应始终在函数组件的最顶层使用，无论是条件、循环还是嵌套函数都不应包含Hooks。遵守这一规则将帮助你避免在组件状态管理中遇到复杂和难以调试的问题。</p>
<h2 id="computed与wacth有什么区别"><a href="#computed与wacth有什么区别" class="headerlink" title="computed与wacth有什么区别"></a>computed与wacth有什么区别</h2><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>原型：prototype，在 JavaScript 中，几乎所有的对象都有一个“原型”。原型本身也是一个对象，被作为一个模板对象，它存储了可以被其他对象继承的属性和方法。当你创建一个对象时，这个对象自动引用一个原型，从中可以继承方法和属性。</p>
<p>例如，所有的 JavaScript 函数都有一个 <code>prototype</code> 属性，这个属性指向一个对象。当你使用构造函数创建一个新对象时（使用 <code>new</code> 关键字），新对象的内部 <code>[[Prototype]]</code> 属性（在大多数浏览器中可以通过 <code>__proto__</code> 访问）将被设置为构造函数的 <code>prototype</code> 对象。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alice = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alice.<span class="title function_">greet</span>()); <span class="comment">// Outputs: Hello, my name is Alice</span></span><br></pre></td></tr></table></figure>

<p>原型链：prototype chain，原型链是一个对象通过其内部 <code>[[Prototype]]</code> 属性链接到其原型，而这个原型本身也可能有自己的原型，并从中继承方法和属性，这样的链条一直向上直到一个对象的原型为 <code>null</code>。通常，原型链的终点是 <code>Object.prototype</code>，这是所有纯粹对象默认的原型。</p>
<p>当你尝试访问一个对象的属性时（包括方法），JavaScript 首先查找对象本身是否有这个属性。如果没有找到，JavaScript 将沿着原型链向上查找，直到找到该属性或到达原型链的末端。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alice = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找过程：</span></span><br><span class="line"><span class="comment">// 1. 检查 alice 对象本身是否有 greet 方法。</span></span><br><span class="line"><span class="comment">// 2. 没有找到，因此查找 alice.__proto__（即 Person.prototype）。</span></span><br><span class="line"><span class="comment">// 3. 在 Person.prototype 中找到了 greet 方法。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alice.<span class="title function_">greet</span>()); <span class="comment">// 输出: Hello, my name is Alice</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 中的继承是通过原型和原型链实现的。这种机制允许对象共享方法和属性，而无需在每个对象上重新定义它们，这提高了效率并节省了内存。理解原型和原型链是深入理解 JavaScript 对象、继承和类行为的关键。</p>
<h2 id="new的过程都干了些什么"><a href="#new的过程都干了些什么" class="headerlink" title="new的过程都干了些什么"></a>new的过程都干了些什么</h2><p>在 JavaScript 中，<code>new</code> 操作符用于创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型的实例。当你使用 <code>new</code> 操作符时，实际上会执行以下几个步骤：</p>
<ol>
<li><p><strong>创建一个新对象</strong>：</p>
<ul>
<li><code>new</code> 操作符首先会创建一个空的简单 JavaScript 对象；即一个新的空对象。</li>
</ul>
</li>
<li><p><strong>设置原型</strong>：</p>
<ul>
<li>接着，这个新对象的内部 <code>[[Prototype]]</code>（也就是 <code>__proto__</code>）属性会被赋值为构造函数的 <code>prototype</code> 属性。这意味着新对象将继承构造函数原型上的方法和属性。</li>
</ul>
</li>
<li><p><strong>执行构造函数</strong>：</p>
<ul>
<li>构造函数被调用，并将 <code>this</code> 绑定到新创建的对象上。这意味着在构造函数中你可以使用 <code>this</code> 关键字来引用新对象，并给这个新对象添加属性和方法。</li>
</ul>
</li>
<li><p><strong>返回新对象</strong>：</p>
<ul>
<li>如果构造函数返回一个对象，则 <code>new</code> 表达式结果为这个对象；如果构造函数返回的不是对象（包括 <code>undefined</code> 或任何原始类型的值），则返回新创建的对象。</li>
</ul>
</li>
</ol>
<p>通过这些步骤，<code>new</code> 操作符不仅仅创建了一个对象实例，还正确设置了对象的原型链，这对于实现基于原型的继承非常关键。这使得实例可以访问构造函数原型上定义的方法和属性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">greet</span>()); <span class="comment">// &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>new Person(&quot;Alice&quot;)</code> 创建了一个新的 <code>Person</code> 实例，并设置了 <code>name</code> 属性和 <code>greet</code> 方法。每次使用 <code>new Person</code> 时，都会按照这个模式创建一个新的对象。</p>
<h2 id="事件循环-1"><a href="#事件循环-1" class="headerlink" title="事件循环"></a>事件循环</h2><h2 id="箭头函数和普通函数有什么区别"><a href="#箭头函数和普通函数有什么区别" class="headerlink" title="箭头函数和普通函数有什么区别"></a>箭头函数和普通函数有什么区别</h2><h2 id="假设vue组件里一个ref的变量-然后再里渲染了它-然后去修改这个变量-那页面上为什么会修改这个变量呢？-介绍一下这个具体的过程"><a href="#假设vue组件里一个ref的变量-然后再里渲染了它-然后去修改这个变量-那页面上为什么会修改这个变量呢？-介绍一下这个具体的过程" class="headerlink" title="假设vue组件里一个ref的变量  然后再里渲染了它  然后去修改这个变量  那页面上为什么会修改这个变量呢？ 介绍一下这个具体的过程"></a>假设vue组件里一个ref的变量  然后再<template>里渲染了它  然后去修改这个变量  那页面上为什么会修改这个变量呢？ 介绍一下这个具体的过程</h2><p>在 Vue.js 框架中，<code>ref</code> 是一个用于创建响应式引用的函数，这是 Vue 3 中 Composition API 的一部分。当你在一个 Vue 组件中使用 <code>ref</code> 声明一个变量，并在 <code>&lt;template&gt;</code> 中使用这个变量时，Vue 设置了一个响应式系统，来确保当这个变量的值改变时，视图也会自动更新。下面是这个过程的具体说明：</p>
<ol>
<li><p><strong>创建响应式引用</strong>：<br>使用 <code>ref</code> 函数创建一个响应式变量时，Vue 会将这个变量包裹在一个响应式对象中。例如，<code>const count = ref(0);</code> 这里的 <code>count</code> 实际上是一个带有 <code>value</code> 属性的对象，<code>count.value</code> 初始化为 0。</p>
</li>
<li><p><strong>在模板中使用</strong>：<br>在 Vue 的 <code>&lt;template&gt;</code> 中使用这个响应式变量时，可以直接引用它，如 <code>&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;</code>。Vue 的渲染系统会自动处理 <code>ref</code> 并访问其 <code>value</code> 属性，因此你无需在模板中写 <code>count.value</code>。</p>
</li>
<li><p><strong>依赖跟踪</strong>：<br>当模板被渲染时，Vue 会自动跟踪所有被访问的响应式引用。这意味着 Vue 知道模板中的某部分依赖于 <code>count</code> 变量。这是通过 Vue 的响应式系统内部的依赖跟踪和收集机制完成的，通常涉及一些内部的发布者-订阅者模式。</p>
</li>
<li><p><strong>响应式更新</strong>：<br>当你更新一个响应式引用的值时，如 <code>count.value = 1</code>，Vue 的响应式系统会察觉到这个变化。因为 <code>count</code> 是响应式的，所以任何依赖于 <code>count</code> 的视图或计算值都会被 Vue 的调度系统安排重新计算和更新。</p>
</li>
<li><p><strong>视图更新</strong>：<br>改变 <code>count.value</code> 后，因为视图部分依赖于 <code>count</code> 的值，Vue 将重新渲染与之相关的 DOM 元素。Vue 的虚拟 DOM 系统会计算之前和当前虚拟 DOM 树的差异，并高效地更新真实的 DOM 以反映新的状态。</p>
</li>
</ol>
<p>通过这个过程，Vue 确保了界面的数据和视图之间的同步。这就是为什么在 Vue 组件中改变一个通过 <code>ref</code> 创建的变量的值会自动更新页面上相应部分的原因。这种模型极大地简化了动态界面的开发，使得开发者可以专注于数据逻辑而非如何操作 DOM。</p>
<h2 id="垃圾回收（面试官反问了解v8吗，新生代分为哪几块区域，这几块儿区域是用来干什么的？这两块儿区域什么时候互换呢？互换了有什么好处吗？）"><a href="#垃圾回收（面试官反问了解v8吗，新生代分为哪几块区域，这几块儿区域是用来干什么的？这两块儿区域什么时候互换呢？互换了有什么好处吗？）" class="headerlink" title="垃圾回收（面试官反问了解v8吗，新生代分为哪几块区域，这几块儿区域是用来干什么的？这两块儿区域什么时候互换呢？互换了有什么好处吗？）"></a>垃圾回收（面试官反问了解v8吗，新生代分为哪几块区域，这几块儿区域是用来干什么的？这两块儿区域什么时候互换呢？互换了有什么好处吗？）</h2><p>JavaScript 中的垃圾回收（Garbage Collection, GC）是一个自动的内存管理机制，它帮助开发者管理内存，避免内存泄露。垃圾回收的主要任务是识别并回收不再使用的内存，以便这部分内存可以被重新利用。</p>
<h3 id="垃圾回收的基本概念"><a href="#垃圾回收的基本概念" class="headerlink" title="垃圾回收的基本概念"></a>垃圾回收的基本概念</h3><p>JavaScript 的垃圾回收主要是基于“可达性”（reachability）的概念：</p>
<ul>
<li><strong>可达值</strong>：从根（root）集合（通常是在代码中直接引用的变量）出发，可以访问到的值被认为是“可达的”。这些值不会被回收，因为它们可能在未来的执行过程中还需要被使用。</li>
<li><strong>不可达值</strong>：如果一个值不可通过任何方式被根集合访问，那么这个值就被认为是“不可达的”，并可以被垃圾回收器回收。</li>
</ul>
<h3 id="V8-引擎的垃圾回收机制"><a href="#V8-引擎的垃圾回收机制" class="headerlink" title="V8 引擎的垃圾回收机制"></a>V8 引擎的垃圾回收机制</h3><p>V8 引擎是 Google 开发的 JavaScript 引擎，广泛应用于 Chrome 浏览器和 Node.js 环境。V8 的垃圾回收机制较为复杂，主要包括以下几个方面：</p>
<ol>
<li><p><strong>分代回收</strong>：</p>
<ul>
<li><strong>新生代（Young Generation）</strong>：V8 将内存分为新生代和老生代两部分。新生代存放生命周期短的小对象。这部分内存的回收频率较高，使用 Scavenge 算法进行高效的垃圾回收。</li>
<li><strong>老生代（Old Generation）</strong>：存放生命周期长或从新生代晋升过来的对象。老生代的垃圾回收使用 Mark-Sweep（标记-清除）和 Mark-Compact（标记-整理）算法，以减少内存碎片。</li>
</ul>
</li>
<li><p><strong>停顿时间优化（Stop-The-World）</strong>：</p>
<ul>
<li>垃圾回收过程中，为了安全地清除不再需要的对象，JavaScript 的执行通常会暂停，这被称为“全停顿”（Stop-The-World）。V8 努力减少垃圾回收带来的停顿时间，通过增量标记（Incremental Marking）和延迟清扫（Lazy Sweeping）等技术，将垃圾回收工作分散到多个小周期中。</li>
</ul>
</li>
<li><p><strong>并行处理和并发处理</strong>：</p>
<ul>
<li>在进行垃圾回收时，V8 尝试使用并行处理，以多线程的方式同时进行垃圾回收，以减少每次停顿时间。</li>
<li>V8 还引入了并发回收（Concurrent GC），其中某些垃圾回收任务可以在 JavaScript 运行时并行进行，进一步减少对主线程的影响。</li>
</ul>
</li>
</ol>
<p>总的来说，V8 引擎的垃圾回收策略旨在平衡内存使用和回收效率，同时最大限度地减少对程序执行的干扰。这些技术使得在 V8 上运行的应用能够更加高效地管理内存，提供更好的用户体验。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h2 id="ts：interface、type分别是什么时候使用"><a href="#ts：interface、type分别是什么时候使用" class="headerlink" title="ts：interface、type分别是什么时候使用"></a>ts：interface、type分别是什么时候使用</h2><p>都是用来定义类型的，接口和类型别名</p>
<p>在 TypeScript 中，<code>interface</code> 和 <code>type</code> 都是用来定义类型的，但它们在某些方面有所不同，并且各自适用于不同的场景。下面是它们的主要区别以及使用场景的指导。</p>
<h3 id="1-基本区别"><a href="#1-基本区别" class="headerlink" title="1. 基本区别"></a>1. 基本区别</h3><p><strong>Interface（接口）</strong>：</p>
<ul>
<li>主要用于定义对象的形状，支持继承和实现（implements）。</li>
<li>接口是一种更强大的方式来定义包括方法和属性的契约。</li>
<li>支持声明合并（Declaration Merging），即允许同名的接口自动合并其成员。</li>
</ul>
<p><strong>Type（类型别名）</strong>：</p>
<ul>
<li>类型别名可以用来定义对象类型，也可以用来定义其他类型，如基本类型、联合类型、交集类型等。</li>
<li>类型别名不支持声明合并，即同名的类型别名不能重复声明，但可以通过交集和联合类型进行扩展。</li>
<li>类型别名更适合用于复杂的类型组合。</li>
</ul>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h3><p><strong>何时使用 Interface</strong>：</p>
<ul>
<li>当你需要定义一个类或对象字面量的结构时，接口是首选。它们提供了一个清晰的方式来描述一个对象应有的形状。</li>
<li>当你在构建大型代码库或第三方类型定义（如 DefinitelyTyped）时，接口提供了一种易于扩展和重用的方式。</li>
<li>如果需要其他类或接口继承自该类型时，使用接口。接口支持多重继承。</li>
</ul>
<p><strong>何时使用 Type</strong>：</p>
<ul>
<li>当你需要使用联合或交集类型来组合现有的类型时，类型别名是更好的选择。</li>
<li>当你需要为基本类型（如字符串或数字）定义一个别名时。</li>
<li>当你需要在一个表达式中使用泛型或其他复杂操作时，类型别名提供了更大的灵活性。</li>
</ul>
<h3 id="3-实例比较"><a href="#3-实例比较" class="headerlink" title="3. 实例比较"></a>3. 实例比较</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bear</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">honey</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Type</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnimalType</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BearType</span> = <span class="title class_">AnimalType</span> &amp; &#123; </span><br><span class="line">    <span class="attr">honey</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumber</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明合并示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">    <span class="attr">ts</span>: <span class="title class_">TypeScriptAPI</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的接口自动合并为：</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">ts</span>: <span class="title class_">TypeScriptAPI</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>虽然 <code>interface</code> 和 <code>type</code> 都可以在许多场景下互换使用，但它们各自的特性使得它们在特定的使用场景下更为合适。接口更适合于定义公共的API的对象结构，而类型别名在处理复杂的类型组合时则更加灵活。选择哪一个，取决于具体的应用场景和个人或团队的偏好。</p>
<h2 id="枚举类型？"><a href="#枚举类型？" class="headerlink" title="枚举类型？"></a>枚举类型？</h2><h2 id="构建工具只用过webpack吗？有用过其他的吗？Vite的优势在哪？有没有改过它们的一些配置"><a href="#构建工具只用过webpack吗？有用过其他的吗？Vite的优势在哪？有没有改过它们的一些配置" class="headerlink" title="构建工具只用过webpack吗？有用过其他的吗？Vite的优势在哪？有没有改过它们的一些配置"></a>构建工具只用过webpack吗？有用过其他的吗？Vite的优势在哪？有没有改过它们的一些配置</h2><h2 id="webpack里的Loader与Plugin有什么区别"><a href="#webpack里的Loader与Plugin有什么区别" class="headerlink" title="webpack里的Loader与Plugin有什么区别"></a>webpack里的Loader与Plugin有什么区别</h2><p>在 Webpack 中，Loader 和 Plugin 是两种扩展 Webpack 功能的方法，它们在使用和功能上有显著的区别。理解它们的不同之处对于有效地使用 Webpack 构建项目至关重要。下面是 Loader 和 Plugin 的主要区别及其各自的作用：</p>
<h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p><strong>定义和作用</strong>：</p>
<ul>
<li>Loader 在 Webpack 中主要用于转换某些类型的模块。它们允许你在 <code>import</code> 或“加载”模块时预处理文件。因此，Loader 类似于一个“转换器”，用于处理非 JavaScript 文件（如 TypeScript, SCSS, JSX 等）。</li>
</ul>
<p><strong>工作方式</strong>：</p>
<ul>
<li>Loader 可以链式传递，每个 Loader 单独完成一项转换工作。</li>
<li>它们处理输入的源文件并产出新的源文件，这些文件可以传递给链中的下一个 Loader，或者输出到最终的 bundles 中。</li>
</ul>
<p><strong>配置方式</strong>：</p>
<ul>
<li>在 Webpack 配置中，Loader 是通过 <code>module.rules</code> 数组进行配置的，可以指定多个 Loader，并且有顺序之分。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">      <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p><strong>定义和作用</strong>：</p>
<ul>
<li>Plugin 用于扩展 Webpack 的功能。它们直接访问 Webpack 的整个编译生命周期，并且可以执行更广泛的任务，如打包优化、资源管理和环境变量注入等。</li>
</ul>
<p><strong>工作方式</strong>：</p>
<ul>
<li>Plugin 通过钩子机制工作，可以监听 Webpack 构建过程中的各种事件，然后在这些事件发生时执行特定的函数来实现功能扩展。</li>
</ul>
<p><strong>配置方式</strong>：</p>
<ul>
<li>Plugin 在 Webpack 配置中通过 <code>plugins</code> 数组配置，通常是通过实例化 Plugin 类（使用 <code>new</code> 关键字）来配置的。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Loader 和 Plugin 虽然都是 Webpack 的功能扩展方式，但它们的应用场景和实现方式大不相同：</p>
<ul>
<li><strong>Loader</strong> 更多地关注于资源模块的加载和处理，它们对文件内容进行转换。</li>
<li><strong>Plugin</strong> 提供了一种工作在构建过程更深层次的方法，能够处理更多构建流程中的广泛任务。</li>
</ul>
<p>在实际使用 Webpack 进行项目构建时，合理利用 Loader 和 Plugin 可以极大地提高构建的灵活性和功能性。</p>
<h2 id="TCP连接三次握手流程"><a href="#TCP连接三次握手流程" class="headerlink" title="TCP连接三次握手流程"></a>TCP连接三次握手流程</h2><h2 id="项目里的图片压缩是怎么做的？"><a href="#项目里的图片压缩是怎么做的？" class="headerlink" title="项目里的图片压缩是怎么做的？"></a>项目里的图片压缩是怎么做的？</h2><h2 id="删除一个单向链表的倒数第n个节点，讲一下思路"><a href="#删除一个单向链表的倒数第n个节点，讲一下思路" class="headerlink" title="删除一个单向链表的倒数第n个节点，讲一下思路"></a>删除一个单向链表的倒数第n个节点，讲一下思路</h2><h2 id="有a和b两个变量-想把a和b交换-不能用中间变量和es6的解构赋值，请你讲一下思路"><a href="#有a和b两个变量-想把a和b交换-不能用中间变量和es6的解构赋值，请你讲一下思路" class="headerlink" title="有a和b两个变量,想把a和b交换,不能用中间变量和es6的解构赋值，请你讲一下思路"></a>有a和b两个变量,想把a和b交换,不能用中间变量和es6的解构赋值，请你讲一下思路</h2><h2 id="一般通过什么方式学前端？-如果可以的话-最快什么时间到岗-能实习到什么时候"><a href="#一般通过什么方式学前端？-如果可以的话-最快什么时间到岗-能实习到什么时候" class="headerlink" title="一般通过什么方式学前端？  如果可以的话  最快什么时间到岗  能实习到什么时候"></a>一般通过什么方式学前端？  如果可以的话  最快什么时间到岗  能实习到什么时候</h2><h2 id="使用websocket"><a href="#使用websocket" class="headerlink" title="使用websocket"></a>使用websocket</h2><p>在简历中描述实时通信功能的实现，尤其是使用 WebSocket 技术，是一个很好的机会来展示你的技术能力和对现代Web技术的掌握。WebSocket 是一种在单个TCP连接上进行全双工通信的协议，允许服务器主动发送信息给客户端，非常适合需要实时数据更新的应用，如在线聊天、游戏、实时通知系统等。确实，WebSocket 能够在不刷新页面的情况下实现实时通信。</p>
<p><strong>实现原理：</strong> 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。</p>
<p><strong>Websocket 协议与 HTTP 协议没有关系</strong>，它是一个<strong>建立在 TCP 协议</strong>上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。</p>
<p>Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。</p>
<p><code>优点</code>： 双向通信。客户端和服务端双方 都可以主动发起通讯。 没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。 数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。 传输效率高。因为只需要一次连接，所以数据传输效率高。</p>
<p><code>缺点</code>： 长连接需要后端处理业务的代码更稳定，推送消息相对复杂； 兼容性，WebSocket 只支持 IE10 及其以上版本。 服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一； 【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】</p>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h4 id="技术描述"><a href="#技术描述" class="headerlink" title="技术描述"></a>技术描述</h4><p><strong>前端开发工程师</strong><br>[公司名称] | [日期]</p>
<ul>
<li><strong>实时通信实现</strong>：设计并实现了基于 WebSocket 的实时通信系统，支持无需页面刷新即时更新数据，增强用户交互体验。利用 <code>Socket.IO</code> 在多用户环境下同步状态和通知，确保信息的即时传递和显示。</li>
<li><strong>动态用户界面响应</strong>：开发了响应式通知和消息系统，通过 WebSocket 接收后端推送的实时更新，动态调整前端显示，包括警告提示、状态更新等，无需用户手动刷新页面。</li>
<li><strong>高效数据处理与优化</strong>：优化 WebSocket 数据传输和事件处理逻辑，降低了网络延迟和服务器负载，提升了系统的响应速度和可靠性。</li>
<li><strong>跨浏览器兼容性和错误处理</strong>：确保 WebSocket 实现在所有主流浏览器上稳定运行，通过优雅的错误处理和重连策略增强了应用的健壮性。</li>
</ul>
<h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>你可以进一步细化描述，如果面试官对这部分感兴趣，以下是你可以讨论的一些技术细节：</p>
<ul>
<li><strong>WebSocket vs. 传统轮询</strong>：解释为什么选择 WebSocket 而非 HTTP 长轮询或短轮询，强调 WebSocket 的低延迟和减少服务器负载的优势。</li>
<li><strong>实现细节</strong>：讨论如何使用 <code>Socket.IO</code>（如果你使用了这个库）处理连接的建立、数据的接收和发送、断线重连等。</li>
<li><strong>安全措施</strong>：描述如何保障 WebSocket 通信的安全性，例如使用 WSS（WebSocket Secure），以及如何管理和验证客户端。</li>
</ul>
<p>这样的描述不仅展示了你在实现关键功能方面的技术能力，还突出了你对提升用户体验和应用性能的关注，是求职简历中的亮点之一。</p>
<h2 id="postmessage"><a href="#postmessage" class="headerlink" title="postmessage"></a>postmessage</h2><p><code>postMessage</code> 是一个允许不同窗口之间或一个窗口与其嵌入的 <code>&lt;iframe&gt;</code> 或其他浏览器上下文之间安全地进行脚本通信的方法。这个功能是 Web HTML5 API 的一部分，特别重要在于它提供了一种方式来绕过同源策略的限制，即通常情况下，不同源的窗口不能彼此通信。</p>
<h3 id="功能和用途"><a href="#功能和用途" class="headerlink" title="功能和用途"></a>功能和用途</h3><ol>
<li><p><strong>跨源通信</strong>：<br><code>postMessage</code> 允许不同源之间的窗口（页面间或页面与嵌入的 <code>&lt;iframe&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code> 或在不同标签页中的页面）进行数据交换。这对于加载了第三方内容的网页尤为重要。</p>
</li>
<li><p><strong>数据传输</strong>：<br>通过 <code>postMessage</code>，你可以发送多种类型的数据，包括字符串、对象等。发送的数据被结构化克隆，这意味着复杂的对象结构可以在不同的窗口或框架间完整传递。</p>
</li>
<li><p><strong>安全性</strong>：<br><code>postMessage</code> 方法包括一个 <code>targetOrigin</code> 参数，指定了哪些域名可以接收到消息，这是一个重要的安全特性。如果设为 <code>&quot;*&quot;</code>，则表示接受所有域的消息，但这通常不推荐，因为这可能带来安全风险。</p>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在一个简单的应用中，假设有一个父窗口和一个嵌入的 <code>&lt;iframe&gt;</code>：</p>
<p><strong>父窗口代码</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;iframe src=<span class="string">&quot;http://example.com/page.html&quot;</span> id=<span class="string">&quot;myframe&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myframe&#x27;</span>);</span><br><span class="line">iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = &#123; <span class="attr">type</span>: <span class="string">&#x27;greeting&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;Hello from parent&#x27;</span> &#125;;</span><br><span class="line">  iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(message, <span class="string">&#x27;http://example.com&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在 <code>&lt;iframe&gt;</code> 页面中的代码</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://yourdomain.com&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 或处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">data</span>.<span class="property">type</span> === <span class="string">&#x27;greeting&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>.<span class="property">text</span>); <span class="comment">// 输出: &#x27;Hello from parent&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>postMessage</code> 是一个强大的 API，用于在浏览器上下文之间进行安全、有效的数据通信。正确使用时，它既能保证数据交换的灵活性，也能确保通信的安全。因此，在开发涉及多个源或多窗口交互的现代 Web 应用时，<code>postMessage</code> 是不可或缺的工具。</p>
<h2 id="Web-Workers-和-WebSocket-的主要区别"><a href="#Web-Workers-和-WebSocket-的主要区别" class="headerlink" title="Web Workers 和 WebSocket 的主要区别"></a>Web Workers 和 WebSocket 的主要区别</h2><h3 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h3><p>Web Workers 提供一种将计算密集或阻塞性任务从主线程（通常是 UI 线程）中移出的方法，以避免阻碍 UI 的响应性。Web Workers 运行在后台线程中，不会影响页面的性能，特别适用于执行需要大量计算的任务。</p>
<p><strong>特点和用途</strong>：</p>
<ul>
<li><strong>并行处理</strong>：Web Workers 允许在背景并行线程中运行 JavaScript，不干扰主 UI 线程。</li>
<li><strong>性能优化</strong>：适用于执行复杂计算，如图像处理、大数据分析等，从而提升应用的响应速度和用户体验。</li>
<li><strong>无 DOM 访问</strong>：Workers 运行在一个与主页面隔离的全局上下文中，不能直接操作 DOM。</li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 提供了全双工通信机制，允许客户端和服务器之间建立一个持久的连接，并通过这个连接实时地双向传输数据。这对于需要实时数据更新的应用非常重要，如在线游戏、聊天应用或实时交易平台。</p>
<p><strong>特点和用途</strong>：</p>
<ul>
<li><strong>实时通信</strong>：WebSocket 使得客户端和服务器可以在任何时候开始发送数据，支持更高效的实时数据交换。</li>
<li><strong>减少开销</strong>：与传统的 HTTP 连接相比，WebSocket 在建立后可以保持连接开放，减少了需要建立连接的频繁开销。</li>
<li><strong>双向通信</strong>：客户端和服务器都可以主动发送数据给对方，而不是仅由客户端发起请求。</li>
</ul>
<h3 id="相关性与区别"><a href="#相关性与区别" class="headerlink" title="相关性与区别"></a>相关性与区别</h3><ul>
<li><strong>处理数据的方式不同</strong>：Web Workers 用于执行在客户端进行的计算密集型或阻塞性任务，而 WebSocket 主要用于在客户端和服务器之间实时交换数据。</li>
<li><strong>用途和目的</strong>：Web Workers 是为了改善用户界面的性能和响应性，而 WebSocket 是为了实现网络应用中的实时数据传输。</li>
<li><strong>交互性</strong>：WebSocket 通过网络连接实现实时、双向的数据交流，适用于任何需要与服务器实时通信的场景；Web Workers 主要是单向的从主线程分配任务，并在任务完成后可能返回结果，主要用于处理本地的数据和任务。</li>
</ul>
<p>总的来说，虽然 Web Workers 和 WebSocket 都与数据处理有关，但它们服务的上下文和目的有很大的不同。Web Workers 解决的是计算性能问题，而 WebSocket 解决的是实时网络通信问题。</p>
<h2 id="跨域的解决办法"><a href="#跨域的解决办法" class="headerlink" title="跨域的解决办法"></a>跨域的解决办法</h2><p><strong>1. CORS（Cross-Origin Resource Sharing）：</strong> CORS是一种跨域资源共享的标准，通过服务端设置响应头中的Access-Control-Allow-Origin字段来允许跨域请求。服务端在收到跨域请求时，检查Origin字段，如果请求的源在白名单内，则在响应头中添加Access-Control-Allow-Origin字段，并设置为允许的源，从而允许跨域请求。</p>
<p><strong>2. JSONP（JSON with Padding）：</strong> JSONP是一种利用script标签的src属性没有跨域限制的特性来实现跨域请求的技术。通过动态创建script标签，将跨域请求的数据封装在一个回调函数中，然后由服务端返回，并执行回调函数，从而实现跨域数据的获取。</p>
<p><strong>3. 代理服务器：</strong> 在开发环境中，可以通过配置代理服务器来实现跨域请求。代理服务器接收前端请求，然后在后端发起真正的请求，获取数据后再返回给前端，由于请求是由后端发起的，所以不存在跨域问题。</p>
<p><strong>4. iframe跨域通信：</strong> 使用iframe标签可以实现跨域通信。父页面和iframe页面属于不同的源，但是它们之间可以通过postMessage方法来进行跨域通信，实现数据的传递和交互。</p>
<h2 id="前端缓存可以分为两种类型：浏览器缓存和-Web-Storage。"><a href="#前端缓存可以分为两种类型：浏览器缓存和-Web-Storage。" class="headerlink" title="前端缓存可以分为两种类型：浏览器缓存和 Web Storage。"></a>前端缓存可以分为两种类型：浏览器缓存和 Web Storage。</h2><ol>
<li><strong>浏览器缓存</strong>：浏览器缓存是指浏览器在本地保存一些静态资源的副本，以便在下次访问相同资源时可以直接从本地获取，而不需要再次从服务器下载。浏览器缓存主要包括以下几种类型：<ul>
<li><strong>强缓存</strong>：浏览器在请求资源时，会先检查该资源的缓存标识（如 Cache-Control 和 Expires），如果命中强缓存，则直接从缓存中获取资源，不会发送请求到服务器。</li>
<li><strong>协商缓存</strong>：如果资源的缓存标识表示资源已经过期（如 Cache-Control 中的 max-age 或者 Last-Modified 和 ETag 等），浏览器会发送请求到服务器，服务器会根据请求头中的条件判断来决定是否返回资源内容，如果返回 304 状态码表示资源未发生改变，浏览器可以使用缓存中的资源。</li>
</ul>
</li>
<li><strong>Web Storage</strong>：Web Storage 是 HTML5 提供的一种浏览器本地存储数据的方式，主要包括 localStorage 和 sessionStorage 两种。它们可以存储在浏览器中供网站使用，可以在页面会话结束后依然保留（localStorage），或者在页面会话结束后被清除（sessionStorage）。<ul>
<li><strong>localStorage</strong>：localStorage 存储的数据没有过期时间，除非手动清除，否则会一直保存在浏览器中。</li>
<li><strong>sessionStorage</strong>：sessionStorage 存储的数据在页面会话结束时被清除，即当页面被关闭时数据也会被清除。</li>
</ul>
</li>
</ol>
<p>WebSocket 是一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket 通信协议于2011年被IETF定为标准RFC 6455，并由RFC7230补充规范。WebSocket 是 HTML5 标准的一部分，可实现客户端和服务器之间的持久连接，使服务器可以实时推送数据给客户端。</p>
<p>以下是一个使用Python语言结合Flask框架创建WebSocket服务器的简单示例：</p>
<p>from flask import Flask, render_template<br>from flask_socketio import SocketIO</p>
<p>app &#x3D; Flask(<strong>name</strong>)<br>app.config[‘SECRET_KEY’] &#x3D; ‘secret!’<br>socketio &#x3D; SocketIO(app)</p>
<p>@app.route(‘&#x2F;‘)<br>def index():<br>    return render_template(‘index.html’)</p>
<p>@socketio.on(‘message’, namespace&#x3D;’&#x2F;chat’)<br>def handle_message(message):<br>    print(‘Received message: ‘ + message)<br>    socketio.emit(‘message’, message, namespace&#x3D;’&#x2F;chat’)</p>
<p>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    socketio.run(app, debug&#x3D;True)</p>
<p>在这个例子中，我们使用了Flask和Flask-SocketIO库来创建一个简单的WebSocket服务器。我们定义了一个路由&#x2F;，当用户访问这个路由时，他们会看到一个index.html页面。我们还定义了一个事件处理程序handle_message，它会在收到客户端发送的消息时触发。</p>
<p>在客户端，你可以使用JavaScript的WebSocket API或者利用类似于jQuery的JavaScript库来轻松地建立和管理WebSocket连接。</p>
<p>以下是一个使用JavaScript和jQuery创建WebSocket客户端的简单示例：</p>
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Chat</title>
</head>
<body>
    <form id="send_form">
        <input type="text" id="message" />
        <button type="submit">Send</button>
    </form>
    <script src="//code.jquery.com/jquery-3.5.1.min.js"></script>
    <script type="text/javascript">
        $(document).ready(function() {
            var socket = io.connect('http://localhost:5000/chat');
            $('#send_form').submit(function(event) {
                event.preventDefault();
                socket.emit('message', $('#message').val());
                $('#message').val('');
            });
            socket.on('message', function(message) {
                console.log('Received message: ' + message);
            });
        });
    </script>
</body>
</html>

<p>在这个HTML页面中，我们使用jQuery库来处理DOM元素，并通过WebSocket与服务器进行通信。当用户在文本输入框中输入消息并点击发送按钮时，我们通过WebSocket发送消息到服务器。同时，我们也监听来自服务器的消息，并在控制台打印出来。</p>
<p>以上就是一个简单的WebSocket服务器和客户端的实现。在实际应用中，你可能需要处理更多的逻辑，例如用户认证、错误处理、消息的可靠传递等。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT（JSON Web Tokens）是一种开放标准（RFC 7519），用于在网络应用环境间安全地传递信息。它主要以一种紧凑且自包含的方式，在各方之间作为 JSON 对象安全地传输信息。这些信息可以被验证和信任，因为它是数字签名的。JWT 常用于身份验证和信息交换，特别适用于分布式站点的单点登录（SSO）场景。</p>
<h3 id="JWT-的结构"><a href="#JWT-的结构" class="headerlink" title="JWT 的结构"></a>JWT 的结构</h3><p>JWT 通常包含三部分：头部（Header）、载荷（Payload）和签名（Signature）。</p>
<ol>
<li><p><strong>头部（Header）</strong>：</p>
<ul>
<li>头部通常由两部分组成：token 的类型（即 JWT）和所使用的签名算法（如 HMAC SHA256 或 RSA）。</li>
<li>示例：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>载荷（Payload）</strong>：</p>
<ul>
<li>载荷包含声明（Claims）。声明是关于实体（通常是用户）和其他数据的语句。</li>
<li>有三种类型的声明：注册的声明、公共的声明和私有的声明。</li>
<li>示例：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>签名（Signature）</strong>：</p>
<ul>
<li>为了创建签名部分，你必须取头部的编码、载荷的编码，然后用头部中指定的算法进行签名。</li>
<li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> + <span class="title function_">base64UrlEncode</span>(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h3><p>在身份验证的过程中，JWT 通常如下使用：</p>
<ol>
<li><p><strong>用户认证</strong>：</p>
<ul>
<li>用户通过登录凭证（用户名和密码）登录系统。</li>
<li>系统验证凭证的正确性，并创建一个 JWT，其中包含用户的一些信息，并对其进行签名，以证明该 token 在传送过程中未被篡改。</li>
</ul>
</li>
<li><p><strong>发送 JWT</strong>：</p>
<ul>
<li>Token 通常通过 Bearer schema 通过 HTTP 授权头部发送给用户，格式如下：<code>Authorization: Bearer &lt;token&gt;</code>。</li>
</ul>
</li>
<li><p><strong>服务端验证</strong>：</p>
<ul>
<li>服务端或者需要验证用户身份的应用将接收到的 token 进行解码，验证签名是否有效。</li>
<li>验证 token 是否过期或者符合其他的业务规则。</li>
</ul>
</li>
</ol>
<h3 id="JWT-的优点"><a href="#JWT-的优点" class="headerlink" title="JWT 的优点"></a>JWT 的优点</h3><ul>
<li><strong>紧凑</strong>：JWT 可以通过 URL、POST 参数或在 HTTP 头中发送，因其小巧，网络传输效率高。</li>
<li><strong>自包含</strong>：JWT 包含了所有用户需要的信息，避免了多次查询数据库。</li>
</ul>
<h3 id="JWT-的缺点"><a href="#JWT-的缺点" class="headerlink" title="JWT 的缺点"></a>JWT 的缺点</h3><ul>
<li><strong>存储问题</strong>：JWT 一旦签发在有效期内就一直有效，这可能导致一旦 JWT 被盗用，直到过期都无法废止（除非使用黑名单机制）。</li>
<li><strong>体积较大</strong>：相比于传统的 session ID，JWT 因包含较多信息，体积较大，如果包含过多信息则会影响传输效率。</li>
<li><strong>安全性问题</strong>：如果不使用 HTTPS，JWT 由于容易被截取，因此安全性会降低。此外，如果使用不当（如签名密钥泄露），也可能导致安全风险。</li>
</ul>
<p>JWT 是一种非常流行的在服务之间安全地传递信息的方式，但需要注意安全实践，如使用 HTTPS 和定期更新签名密钥，以保证信息安全。</p>
<h1 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h1><p>文件上传，localstorage保存本地</p>
<p>盒模型</p>
<p>css左右宽度固定，中间自适应，flex:1不同的属性是什么意思</p>
<p>var函数作用域</p>
<p>事件循环，看代码输出</p>
<p>树的转化，</p>
<p>useEffect函数配合return 输出顺序</p>
<p>虚拟列表的渲染？实现，视窗</p>
<p>文件上传localstorage，sessionstorage，cookie区别</p>
<p>微前端，iframe和qiankun的区别，样式隔离如何做的？别的微前端实现方式？</p>
<p>伪类和伪元素</p>
<p>string和new 创建的string一样吗？</p>
<p>apply bind call 修改this的指向如何实现？实现代码</p>
<h1 id="HTML5-CSS"><a href="#HTML5-CSS" class="headerlink" title="HTML5+CSS"></a>HTML5+CSS</h1><p>是的，Web Workers 和 WebSocket 都是 HTML5 提出的重要特性。它们各自解决了 web 应用开发中的不同问题，使得现代 web 应用能够更加高效和动态。</p>
<h2 id="Web-Workers-1"><a href="#Web-Workers-1" class="headerlink" title="Web Workers"></a>Web Workers</h2><p>Web Workers 提供了一种在浏览器后台执行脚本的方法，而不会干扰主线程的用户界面。它允许开发者创建多线程环境，用于处理计算密集或耗时的任务，从而提升应用性能和响应速度。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>并行处理</strong>：Web Workers 允许 JavaScript 运行在与主线程分离的后台线程中，这意味着可以并行处理复杂任务，不会造成界面卡顿。</li>
<li><strong>非阻塞</strong>：由于运行在独立线程，即使执行复杂的计算，也不会阻塞 UI 更新或用户交互。</li>
<li><strong>通信</strong>：主线程和 Workers 之间通过传递消息的方式进行数据交互，它们不共享同一内存空间，因此数据在互传过程中是复制的。</li>
</ul>
<h2 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket 提供了一种在客户端和服务器之间建立持久连接的方法，通过这个连接，可以实现双向实时通信。与传统的 HTTP 连接不同，一旦 WebSocket 连接建立，服务器和客户端之间可以随时互发消息，无需重新建立连接。</p>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>实时通信</strong>：WebSocket 允许服务器主动向客户端发送消息，非常适合需要实时数据更新的应用，如在线游戏、实时交易平台、协作应用等。</li>
<li><strong>减少开销</strong>：WebSocket 连接建立后，数据帧的传输开销比 HTTP 小得多，因为避免了频繁的握手和头部信息的重复传输。</li>
<li><strong>全双工通信</strong>：WebSocket 支持全双工通信，客户端和服务器可以同时发送和接收信息。</li>
</ul>
<h2 id="HTML5-和现代应用"><a href="#HTML5-和现代应用" class="headerlink" title="HTML5 和现代应用"></a>HTML5 和现代应用</h2><p>Web Workers 和 WebSocket 都是 HTML5 标准的一部分，是现代 web 应用常用的技术。它们的引入标志着 web 应用的一个重要进步，让 web 应用在性能和用户体验上更接近传统的桌面应用。</p>
<ul>
<li><strong>Web Workers</strong> 使得开发者可以创建更加平滑和响应快速的用户界面，即使在执行重任务时也不会影响到主 UI 线程。</li>
<li><strong>WebSocket</strong> 则改变了客户端与服务器交互的方式，为实时多用户功能提供了基础，大大增强了应用的互动性。</li>
</ul>
<p>这两种技术各有用武之地，选择使用哪一种，取决于应用的具体需求：是否需要后台处理能力，或是需要实时的网络通信。</p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>标准盒模型：content-box</p>
<p>怪异盒模型：border-box</p>
<h2 id="左右布局"><a href="#左右布局" class="headerlink" title="左右布局"></a>左右布局</h2><h2 id="水平垂直居中布局"><a href="#水平垂直居中布局" class="headerlink" title="水平垂直居中布局"></a>水平垂直居中布局</h2><h3 id="使用Flex布局"><a href="#使用Flex布局" class="headerlink" title="使用Flex布局"></a>使用Flex布局</h3><p><strong>实现方式：</strong> 使用CSS的Flex布局可以轻松实现水平垂直居中。通过设置容器的<code>display: flex; justify-content: center; align-items: center;</code>，即可实现容器内元素的水平垂直居中。</p>
<h3 id="使用绝对定位和transform属性"><a href="#使用绝对定位和transform属性" class="headerlink" title="使用绝对定位和transform属性"></a>使用绝对定位和transform属性</h3><p><strong>实现方式：</strong> 使用CSS的绝对定位和transform属性也可以实现水平垂直居中。通过设置元素的<code>position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);</code>，即可实现元素的水平垂直居中。</p>
<h3 id="使用表格布局"><a href="#使用表格布局" class="headerlink" title="使用表格布局"></a>使用表格布局</h3><p><strong>实现方式：</strong> 使用CSS的表格布局也可以实现水平垂直居中。通过设置容器和元素的<code>display: table; display: table-cell; vertical-align: middle; text-align: center;</code>，即可实现元素的水平垂直居中。</p>
<p><strong>实现方式：</strong> 使用Flex布局的margin:auto方法也可以实现水平垂直居中。通过设置容器的<code>display: flex;</code>，然后在需要居中的元素上添加<code>margin: auto;</code>，即可实现元素的水平垂直居中。</p>
<h3 id="使用Flex布局的margin-auto方法"><a href="#使用Flex布局的margin-auto方法" class="headerlink" title="使用Flex布局的margin:auto方法"></a>使用Flex布局的margin:auto方法</h3><h2 id="flex：1是什么属性的缩写？"><a href="#flex：1是什么属性的缩写？" class="headerlink" title="flex：1是什么属性的缩写？"></a>flex：1是什么属性的缩写？</h2><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><p>viewport</p>
<p>rem</p>
<h2 id="动画：transition、animation"><a href="#动画：transition、animation" class="headerlink" title="动画：transition、animation"></a>动画：transition、animation</h2><p>在 CSS 中，动画可以通过两种主要方式实现：<code>transition</code> 和 <code>animation</code>。这两种方法各有特点，适用于不同的场景。</p>
<h3 id="CSS-Transitions"><a href="#CSS-Transitions" class="headerlink" title="CSS Transitions"></a>CSS Transitions</h3><p>CSS <code>transition</code> 属性用于在 CSS 属性值之间创建平滑的过渡效果。当一个 CSS 属性改变时，transition 会使这个属性值的变化更加平滑和渐进。</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>适用于简单的从一种样式过渡到另一种样式的情况。</li>
<li>常用于响应用户的交互，如悬停、点击或聚焦。</li>
</ul>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: property duration timing-function delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>property</strong>：指定要过渡的 CSS 属性（如 <code>all</code> 表示所有可过渡的属性）。</li>
<li><strong>duration</strong>：过渡效果花费的时间，通常以秒或毫秒表示。</li>
<li><strong>timing-function</strong>：定义速度曲线，常用的有 <code>linear</code>、<code>ease</code>、<code>ease-in</code>、<code>ease-out</code>、<code>ease-in-out</code>。</li>
<li><strong>delay</strong>：延迟时间，即在过渡开始之前等待的时间。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">transition</span>: background <span class="number">2s</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>div</code> 的背景色会在鼠标悬停时在 2 秒内平滑地从蓝色过渡到红色。</p>
<h3 id="2-CSS-Animations"><a href="#2-CSS-Animations" class="headerlink" title="2. CSS Animations"></a>2. CSS Animations</h3><p>CSS <code>animation</code> 属性允许动画从一个样式配置过渡到另一个。与 <code>transition</code> 相比，<code>animation</code> 提供了对动画过程更细致的控制，包括多个关键帧和复杂的动画序列。</p>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>适用于复杂的动画效果，需要在多个阶段或多个样式值之间进行过渡。</li>
<li>可以在无需触发事件的情况下自动开始。</li>
</ul>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>首先，你需要定义关键帧（<code>@keyframes</code>）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> example &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;<span class="attribute">background-color</span>: red;&#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;<span class="attribute">background-color</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将动画应用于元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">animation-name</span>: example;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">4s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>animation-name</strong>：引用 <code>@keyframes</code> 名称。</li>
<li><strong>animation-duration</strong>：动画持续时间。</li>
<li><strong>animation-timing-function</strong>：速度曲线。</li>
<li><strong>animation-delay</strong>：延迟开始的时间。</li>
<li><strong>animation-iteration-count</strong>：动画重复次数。</li>
<li><strong>animation-direction</strong>：动画是否应该反向播放。</li>
<li><strong>animation-fill-mode</strong>：在动画前后如何应用样式。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> changeSize &#123;</span><br><span class="line">    <span class="number">0%</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="number">50%</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>); &#125;</span><br><span class="line">    <span class="number">100%</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: changeSize <span class="number">3s</span> infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>div</code> 将不断地在原始大小和放大 50% 之间变化。</p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>CSS Transitions</strong> 最适合用于单一状态变化的简单动画效果。</li>
<li><strong>CSS Animations</strong> 更适合于需要多个状态或更复杂动画效果的场景。</li>
</ul>
<p>使用这些工具，你可以为网页元素添加视觉上吸引人的动效，提高用户体验。</p>
<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>冒泡、目标、捕获</p>
<p>对很多个列表事件进行处理然后才需要最后的结果的时候，可以使用事件代理</p>
<h2 id="事件循环-2"><a href="#事件循环-2" class="headerlink" title="事件循环"></a>事件循环</h2><blockquote>
<p>同步任务、宏任务、微任务</p>
</blockquote>
<h2 id="浏览器内存"><a href="#浏览器内存" class="headerlink" title="浏览器内存"></a>浏览器内存</h2><p> <strong>Cookies</strong>、<strong>LocalStorage</strong> 、<strong>SessionStorage</strong></p>
<p>这些技术各自有不同的用途和限制：</p>
<h3 id="1-Cookies"><a href="#1-Cookies" class="headerlink" title="1. Cookies"></a>1. <strong>Cookies</strong></h3><p>Cookies 最初被设计用来存储少量的用户和服务器间的会话数据。它们由服务器发送到用户的浏览器，并且可以设置为在浏览器再次发起请求时被送回服务器。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>大小限制</strong>：每个 Cookie 的大小限制约为 4KB。</li>
<li><strong>数量限制</strong>：每个域的 Cookie 数量也有限制，通常为 20-50 个不等，具体取决于浏览器。</li>
<li><strong>过期时间</strong>：可以设置失效日期，过期后浏览器不再存储。</li>
<li><strong>安全性</strong>：支持设置 HttpOnly 属性，阻止 JavaScript 通过 <code>document.cookie</code> 访问，增强安全性。还可以设置 Secure 属性，使 Cookie 仅在 HTTPS 连接中被发送。</li>
</ul>
<h3 id="2-LocalStorage"><a href="#2-LocalStorage" class="headerlink" title="2. LocalStorage"></a>2. <strong>LocalStorage</strong></h3><p>LocalStorage 是 HTML5 引入的一种存储方式，用于长期存储数据，即使浏览器关闭后数据仍然保存。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>存储容量</strong>：通常提供至少 5MB 的存储空间。</li>
<li><strong>生命周期</strong>：数据存储在本地，没有过期时间，除非被用户或应用程序清除。</li>
<li><strong>作用域</strong>：数据保存在浏览器中，且仅限于同源的页面（即相同协议、域名、端口）访问。</li>
</ul>
<h3 id="3-SessionStorage"><a href="#3-SessionStorage" class="headerlink" title="3. SessionStorage"></a>3. <strong>SessionStorage</strong></h3><p>SessionStorage 与 LocalStorage 类似，也是 HTML5 提供的一种机制，但它是为了存储仅在浏览器会话期间需要保持的数据。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>存储容量</strong>：通常提供至少 5MB 的存储空间。</li>
<li><strong>生命周期</strong>：数据仅在浏览器会话期间可用（浏览器窗口打开期间）。当用户关闭浏览器窗口或标签页时，数据被清除。</li>
<li><strong>作用域</strong>：与 LocalStorage 类似，数据的访问也仅限于同源的页面。</li>
</ul>
<h3 id="比较与选择"><a href="#比较与选择" class="headerlink" title="比较与选择"></a>比较与选择</h3><ul>
<li><strong>用途</strong>：Cookies 更适合执行需要与服务器交互的身份验证任务；LocalStorage 适合长期存储大量不需要经常更改的数据，如用户偏好设置；SessionStorage 适合在单个会话中暂存数据，如表单填写状态。</li>
<li><strong>性能</strong>：与 Cookies 相比，LocalStorage 和 SessionStorage 提供了更快的数据访问速度，因为它们的数据不需要每次与服务器通信。</li>
<li><strong>安全性</strong>：考虑到安全性，应该避免在客户端存储敏感数据，尤其是未加密的情况下。如果必须使用，应该采取措施如加密数据以增强安全性。</li>
</ul>
<p>根据应用的需要，开发者可以选择最合适的浏览器存储技术来优化用户体验和应用性能。</p>
<h2 id="ES6的理解"><a href="#ES6的理解" class="headerlink" title="ES6的理解"></a>ES6的理解</h2><h2 id="数据类型和判断方式"><a href="#数据类型和判断方式" class="headerlink" title="数据类型和判断方式"></a>数据类型和判断方式</h2><h2 id="箭头函数，map、set，块级作用域，"><a href="#箭头函数，map、set，块级作用域，" class="headerlink" title="箭头函数，map、set，块级作用域，"></a>箭头函数，map、set，块级作用域，</h2><h2 id="数据遍历的方式"><a href="#数据遍历的方式" class="headerlink" title="数据遍历的方式"></a>数据遍历的方式</h2><h3 id="基本类型的遍历"><a href="#基本类型的遍历" class="headerlink" title="基本类型的遍历"></a>基本类型的遍历</h3><p>基本数据类型（如数字、字符串、布尔值等）通常不需要遍历，因为它们是单个值。不过，字符串类型可以类似于数组进行索引访问和遍历。</p>
<h4 id="字符串遍历"><a href="#字符串遍历" class="headerlink" title="字符串遍历"></a>字符串遍历</h4><ul>
<li><p>使用传统的 <code>for</code> 循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>for...of</code> 循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(char);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h3><p>对于 JavaScript 对象（包括数组和更复杂的对象类型），有多种遍历方法：</p>
<h4 id="1-for-in-循环-1"><a href="#1-for-in-循环-1" class="headerlink" title="1. for...in 循环"></a>1. <code>for...in</code> 循环</h4><ul>
<li><p>用于遍历对象的所有可枚举属性（包括继承的属性）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：使用 <code>for...in</code> 遍历对象时，最好检查属性是否是对象本身的属性（非继承属性）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-Object-keys-Object-values-Object-entries"><a href="#2-Object-keys-Object-values-Object-entries" class="headerlink" title="2. Object.keys(), Object.values(), Object.entries()"></a>2. <code>Object.keys()</code>, <code>Object.values()</code>, <code>Object.entries()</code></h4><p>这些 ES6 方法提供了返回对象属性的数组，可以与 <code>forEach()</code> 或其他迭代方法配合使用：</p>
<ul>
<li><p><code>Object.keys()</code> 返回一个包含对象自身所有可枚举属性键的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.values()</code> 返回一个包含对象自身所有可枚举属性值的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.entries()</code> 返回一个给定对象自身可枚举属性的键值对数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-for-of-循环与-Object-entries"><a href="#3-for-of-循环与-Object-entries" class="headerlink" title="3. for...of 循环与 Object.entries()"></a>3. <code>for...of</code> 循环与 <code>Object.entries()</code></h4><ul>
<li><p>使用 <code>for...of</code> 遍历 <code>Object.entries()</code> 返回的键值对数组是遍历对象属性的另一种实用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>遍历数据的方法应根据数据的类型和需要操作的数据结构来选择。字符串虽然是基本类型，但可以像数组一样遍历。对象的遍历则可以使用 <code>for...in</code> 循环，但要注意只遍历对象自身的属性。ES6 的 <code>Object.keys()</code>, <code>Object.values()</code>, <code>Object.entries()</code> 提供了更现代的遍历对象的方法。选择合适的遍历方式可以使代码更简洁、更有效率。</p>
<h2 id="new的过程"><a href="#new的过程" class="headerlink" title="new的过程"></a>new的过程</h2><p>在 JavaScript 中，<code>new</code> 操作符是用来创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型的实例。<code>new</code> 做的事情可以分解为以下几个步骤：</p>
<h3 id="1-创建一个新对象"><a href="#1-创建一个新对象" class="headerlink" title="1. 创建一个新对象"></a>1. 创建一个新对象</h3><p>当你使用 <code>new</code> 操作符时，JavaScript 首先会创建一个空的对象。</p>
<h3 id="2-设置原型链"><a href="#2-设置原型链" class="headerlink" title="2. 设置原型链"></a>2. 设置原型链</h3><p>接着，这个新对象的内部 <code>[[Prototype]]</code> （也就是 <code>__proto__</code>）会被赋值为构造函数的 <code>prototype</code> 属性。这意味着新对象可以访问构造函数原型上的属性和方法。</p>
<h3 id="3-绑定-this-关键字"><a href="#3-绑定-this-关键字" class="headerlink" title="3. 绑定 this 关键字"></a>3. 绑定 <code>this</code> 关键字</h3><p>在构造函数内部，<code>this</code> 关键字引用的是刚刚创建的新对象。如果构造函数中有代码修改了 <code>this</code>，它会修改新对象的属性。</p>
<h3 id="4-执行构造函数的代码"><a href="#4-执行构造函数的代码" class="headerlink" title="4. 执行构造函数的代码"></a>4. 执行构造函数的代码</h3><p>构造函数内部的代码将会执行。通常情况下，构造函数会初始化对象的属性，也可能会调用其它方法。</p>
<h3 id="5-返回新对象"><a href="#5-返回新对象" class="headerlink" title="5. 返回新对象"></a>5. 返回新对象</h3><p>在构造函数执行完毕后，如果构造函数返回一个对象，那么这个对象会成为 <code>new</code> 表达式的结果，如果构造函数没有显式返回一个对象，则默认返回 <code>this</code>，即新创建的对象。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, my name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; and I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&#x27; years old.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>, <span class="number">30</span>);</span><br><span class="line">john.<span class="title function_">greet</span>(); <span class="comment">// 输出: Hello, my name is John and I am 30 years old.</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>new Person(&#39;John&#39;, 30)</code> 做了以下事情：</p>
<ol>
<li>创建了一个新对象。</li>
<li>将新对象的 <code>__proto__</code> 指向了 <code>Person.prototype</code>。</li>
<li>将 <code>this</code> 绑定到新对象上。</li>
<li>执行 <code>Person</code> 函数体内的代码，将 ‘John’ 赋值给 <code>this.name</code>，将 30 赋值给 <code>this.age</code> 并定义了 <code>this.greet</code> 方法。</li>
<li>返回了这个新对象，赋值给了 <code>john</code> 变量。</li>
</ol>
<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p><code>new</code> 操作符在 JavaScript 中是一个强大的特性，它允许开发者基于构造函数创建复杂的对象。了解 <code>new</code> 的内部工作原理是理解 JavaScript 面向对象编程的一个重要部分。</p>
<h2 id="promise的理解和静态方法"><a href="#promise的理解和静态方法" class="headerlink" title="promise的理解和静态方法"></a>promise的理解和静态方法</h2><p>在 JavaScript 中，<code>Promise</code> 是一种用于异步编程的重要构造函数。它允许你组织和管理异步操作更加简洁和易于理解。Promise 代表了一个最终可能完成或失败的操作和其结果值。</p>
<p>一个 <code>Promise</code> 对象代表了一个异步操作的最终完成（或失败）及其结果值。一个 Promise 有以下三种状态：</p>
<ul>
<li><strong>Pending（等待态）</strong>：初始状态，既不是成功，也不是失败状态。</li>
<li><strong>Fulfilled（已成功）</strong>：意味着操作成功完成。</li>
<li><strong>Rejected（已失败）</strong>：意味着操作失败。</li>
</ul>
<p>Promise 提供了一种逃避地狱回调（Callback Hell，即多层嵌套的回调函数）的方式，使异步代码更容易写和理解。</p>
<h3 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h3><p>创建一个 Promise并模拟异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 异步操作代码</span></span><br><span class="line">    <span class="keyword">const</span> success=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value); <span class="comment">// 将 promise 的状态改为 fulfilled</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(error); <span class="comment">// 将 promise 的状态改为 rejected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="comment">/* 处理成功的结果 */</span> &#125;,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="comment">/* 处理错误 */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-的静态方法"><a href="#Promise-的静态方法" class="headerlink" title="Promise 的静态方法"></a>Promise 的静态方法</h3><p>Promise 提供了几个静态方法，这些方法有助于控制多个异步操作。</p>
<ol>
<li><p><strong>Promise.resolve(value)</strong></p>
<ul>
<li>返回一个状态由给定值解析后的 Promise 对象。如果该值是 thenable（即有 <code>then</code> 方法），返回的 Promise 将“跟随”这个 thenable 的状态；否则返回的 Promise 将以此值完成。</li>
</ul>
</li>
<li><p><strong>Promise.reject(reason)</strong></p>
<ul>
<li>返回一个状态为拒绝的 Promise 对象。</li>
</ul>
</li>
<li><p><strong>Promise.all(iterable)</strong></p>
<ul>
<li>此方法通常用于处理多个 Promise 对象的情况。它返回一个新的 Promise 实例，该实例在 iterable 参数内的所有 Promise 都成功完成时完成。如果任意一个 Promise 失败，返回的 Promise 便立即失败。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title class_">Promise1</span>, <span class="title class_">Promise2</span>]).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>) &#123;</span><br><span class="line">    <span class="comment">// 所有 Promise 都成功</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// 有一个 Promise 失败</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Promise.race(iterable)</strong></p>
<ul>
<li>当 iterable 参数里的任意一个子 Promise 被成功或失败后，父 Promise 立即也会用子 Promise 的成功返回值或失败详情作为参数调用父 Promise 绑定的相应句柄，并返回该 Promise 对象。</li>
</ul>
</li>
<li><p><strong>Promise.allSettled(iterable)</strong></p>
<ul>
<li>返回一个在所有给定的 Promise 已被决议或拒绝后的 Promise，并带有一个对象数组，每个对象表示对应的 Promise 结果。</li>
</ul>
</li>
</ol>
<p>使用这些方法可以有效地组合和管理多个异步操作，提高代码的可读性和易维护性。</p>
<h3 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h3><p>Promise 是现代 JavaScript 中处理异步操作的核心组件之一。通过使用 Promise 和其静态方法，你可以写出更清晰、更可维护的异步代码。理解和掌握 Promise 是成为一名效率高、代码质量好的 JavaScript 开发者的关键步骤。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol>
<li><p>CORS（Cross-Origin Resource Sharing）： CORS是一种跨域资源共享的标准，通过服务端设置响应头中的Access-Control-Allow-Origin字段来允许跨域请求。服务端在收到跨域请求时，检查Origin字段，如果请求的源在白名单内，则在响应头中添加Access-Control-Allow-Origin字段，并设置为允许的源，从而允许跨域请求。</p>
</li>
<li><p>JSONP（JSON with Padding）： JSONP是一种利用script标签的src属性没有跨域限制的特性来实现跨域请求的技术。通过动态创建script标签，将跨域请求的数据封装在一个回调函数中，然后由服务端返回，并执行回调函数，从而实现跨域数据的获取。</p>
</li>
<li><p>代理服务器： 在开发环境中，可以通过配置代理服务器来实现跨域请求。代理服务器接收前端请求，然后在后端发起真正的请求，获取数据后再返回给前端，由于请求是由后端发起的，所以不存在跨域问题。</p>
</li>
<li><p>iframe跨域通信： 使用iframe标签可以实现跨域通信。父页面和iframe页面属于不同的源，但是它们之间可以通过postMessage方法来进行跨域通信，实现数据的传递和交互。</p>
</li>
<li><p>WebSocket协议： WebSocket是一种全双工通信协议，能够在不受同源策略限制的情况下实现跨域通信。通过WebSocket协议，客户端和服务端可以建立持久的连接，实现实时数据的传输和交互。</p>
</li>
<li><p>nginx</p>
</li>
<li><p>postmessage</p>
</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>标记清除、引用计数</p>
<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><p>interface、type和泛型</p>
<p>在 TypeScript 中，<code>interface</code> 和 <code>type</code> 都是定义类型的重要工具，它们在很多情况下可以互换使用，但也有一些关键的区别。了解这些区别有助于你在实际开发中更好地选择适合的语法。</p>
<h3 id="相似点"><a href="#相似点" class="headerlink" title="相似点"></a>相似点</h3><ol>
<li><strong>定义形状</strong>：<code>interface</code> 和 <code>type</code> 都可以用来定义对象的形状，即指定对象应该有哪些属性以及属性的类型。</li>
<li><strong>扩展其他类型</strong>：两者都可以扩展其他类型，<code>interface</code> 使用 <code>extends</code> 关键字，而 <code>type</code> 使用交叉类型（<code>&amp;</code>）。</li>
</ol>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol>
<li><p><strong>扩展机制</strong>：</p>
<ul>
<li><strong>interface</strong>：可以声明多次，并且会被自动合并。这允许你在不同的地方扩展同一个接口。</li>
<li><strong>type</strong>：不能声明多次（即一旦被声明，不能再被重新声明来添加新的属性），但它可以通过交叉类型来扩展其他类型或别名。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface 自动合并</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// User 现在有 name 和 age 属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 不可以重复声明，但可以通过 &amp; 扩展</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">species</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bear</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">    <span class="attr">honey</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用<code>type</code>可以声明基本类型别名，联合类型，元组等</strong>：</p>
<ul>
<li><code>type</code> 不仅仅限于对象类型。它可以用来声明几乎所有类型，包括基本类型别名、联合类型、元组等。</li>
<li><code>interface</code> 主要用于声明对象类型或函数类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumber</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TupleType</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现细节</strong>：</p>
<ul>
<li><strong>interface</strong>：更加面向对象的编程风格，支持实现（implements）和扩展（extends）。</li>
<li><strong>type</strong>：更灵活，支持使用联合、元组等更复杂的类型结构。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IAnimal</span> &#123;</span><br><span class="line">    <span class="attr">species</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">IAnimal</span> &#123;</span><br><span class="line">    species = <span class="string">&quot;Canis&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">drawPoint</span> = (<span class="params">point: Point</span>) =&gt; &#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>扩展&#x2F;合并限制</strong>：</p>
<ul>
<li><strong>interface</strong>：允许开放结束的扩展，因为你可以在程序的任何地方添加到现有接口。</li>
<li><strong>type</strong>：定义是封闭的，一次声明定义全部完成。</li>
</ul>
</li>
</ol>
<h3 id="选择使用哪一个？"><a href="#选择使用哪一个？" class="headerlink" title="选择使用哪一个？"></a>选择使用哪一个？</h3><ul>
<li>使用 <code>interface</code> 当你需要一个对象类型或者在面向对象风格的代码库中（如当与类一起使用时）。</li>
<li>使用 <code>type</code> 当你需要利用联合类型或元组类型等复杂类型，或者需要对类型进行条件选择。</li>
</ul>
<p>在实践中，如果两者都可以满足需求，推荐优先选择 <code>interface</code>，因为它的扩展性更好，更适合在大型项目中使用，能够提供更好的代码组织和更清晰的错误信息。然而，<code>type</code> 的灵活性在处理复杂的类型组合时是无可替代的。</p>
<h2 id="对泛型属性约束："><a href="#对泛型属性约束：" class="headerlink" title="对泛型属性约束："></a>对泛型属性约束：</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> logLength&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);  <span class="comment">// 现在我们知道它有 `.length` 属性，因为它符合 Lengthwise 约束</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">logLength</span>(&#123; <span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;);  <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">logLength</span>(<span class="number">3</span>);  <span class="comment">// 错误, 数字没有 `.length` 属性</span></span><br></pre></td></tr></table></figure>

<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="2和3双向数据绑定的区别理解"><a href="#2和3双向数据绑定的区别理解" class="headerlink" title="2和3双向数据绑定的区别理解"></a>2和3双向数据绑定的区别理解</h2><p>object.propert</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="watch和computed"><a href="#watch和computed" class="headerlink" title="watch和computed"></a>watch和computed</h2><p>watch：不缓存，实时更新</p>
<p>computed：缓存</p>
<h2 id="v-if、v-show"><a href="#v-if、v-show" class="headerlink" title="v-if、v-show"></a>v-if、v-show</h2><p>if是条件渲染</p>
<p>show是通过css的display</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>props和$emit，provide和inject，Event Bus，vuex，</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><blockquote>
<p><strong>state、getters、mutations、actions、modules</strong></p>
</blockquote>
<h3 id="1-State"><a href="#1-State" class="headerlink" title="1. State"></a>1. <strong>State</strong></h3><p>State 是 Vuex 存储的基础，是存储在 Vuex 中的数据。它是单一状态树 —— 所有组件的状态都被集中到一个共享的对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在组件内部，你可以通过 <code>this.$store.state</code> 访问 Vuex state。</p>
<h3 id="2-Getters"><a href="#2-Getters" class="headerlink" title="2. Getters"></a>2. <strong>Getters</strong></h3><p>Getters 类似于 Vue 的计算属性，主要用于基于 Vuex store 的 state 计算出新的状态。Getters 可以被多个组件复用，且当它依赖的 state 变化时，会自动重新计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">todos</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">todos</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">todo</span> =&gt;</span> todo.<span class="property">done</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在组件内部，可以通过 <code>this.$store.getters.doneTodos</code> 访问到这个 getter。</p>
<h3 id="3-Mutations"><a href="#3-Mutations" class="headerlink" title="3. Mutations"></a>3. <strong>Mutations</strong></h3><p>Mutations 是改变 Vuex store 中 state 的唯一方法。Mutation 必须是同步函数，这样能够确保每次状态变化都能被调试工具追踪到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在组件中使用 <code>this.$store.commit(&#39;increment&#39;)</code> 来触发 mutation。</p>
<h3 id="4-Actions"><a href="#4-Actions" class="headerlink" title="4. Actions"></a>4. <strong>Actions</strong></h3><p>Actions 类似于 mutations，但是不同于 mutations 的是，actions 可以包含任意异步操作。Actions 提交的是 mutation，而不是直接变更状态。Actions 可以包含任意异步操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在组件中使用 <code>this.$store.dispatch(&#39;incrementAsync&#39;)</code> 来触发 action。</p>
<h3 id="5-Modules"><a href="#5-Modules" class="headerlink" title="5. Modules"></a>5. <strong>Modules</strong></h3><p>当 Vuex 应用变得非常复杂时，store 对象可能变得非常臃肿。Modules 可以将 store 分割成模块，每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>每个 Vuex 模块的 state 会被合并到 Vuex 的全局 state 中，并根据模块注册的路径分割命名空间。</p>
<p>这些核心概念共同定义了 Vuex 的结构和机制，使得状态管理更加清晰、高效，并且更易于维护和扩展。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>history和哈希模式</p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h1 id="Webpack-1"><a href="#Webpack-1" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="loader和plugin的区别"><a href="#loader和plugin的区别" class="headerlink" title="loader和plugin的区别"></a>loader和plugin的区别</h2><h3 id="Loader-1"><a href="#Loader-1" class="headerlink" title="Loader"></a>Loader</h3><p>Loader 用于转换特定类型的模块或文件。Webpack 本身只理解 JavaScript，Loader 可以让 Webpack 有能力去处理其他类型的文件，并将它们转换为有效的模块，以供应用程序使用以及被添加到依赖图中。</p>
<p><strong>主要特点</strong>：</p>
<ul>
<li><strong>文件转换</strong>：Loader 可以把文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。Loader 甚至允许你直接在 JavaScript 模块中 import CSS文件。</li>
<li><strong>链式调用</strong>：Loader 可以链式调用。意味着可以应用多个 loader，它们会按顺序从右到左（或从下到上）应用。</li>
<li><strong>每个文件单独处理</strong>：Webpack 为每个文件根据配置的 loader 规则进行处理。</li>
</ul>
<p><strong>示例</strong>：使用 <code>css-loader</code> 和 <code>style-loader</code> 处理 CSS 文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">        <span class="string">&#x27;css-loader&#x27;</span>  <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Plugin-1"><a href="#Plugin-1" class="headerlink" title="Plugin"></a>Plugin</h3><p>Plugin 用于扩展 Webpack 的功能。它们直接作用于整个构建过程，可以执行范围更广的任务，如打包优化、资源管理和环境变量注入等。</p>
<p><strong>主要特点</strong>：</p>
<ul>
<li><strong>扩展性强</strong>：插件可以用于执行几乎任何任务，包括打包优化、定义环境变量、压缩、等等。</li>
<li><strong>直接作用于整个构建流程</strong>：Plugin 可以在构建的任何阶段执行操作，提供了完整的构建流程控制。</li>
<li><strong>自定义功能</strong>：开发者可以编写自己的 Webpack 插件，以实现更具体的需求。</li>
</ul>
<p><strong>示例</strong>：使用 <code>HtmlWebpackPlugin</code>，它可以生成一个 HTML 文件，或者利用模板生成 HTML 文件，并自动注入生成的资源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Custom template&#x27;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;my-index.html&#x27;</span> <span class="comment">// 自定义模板路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul>
<li><strong>Loader</strong> 主要用于对模块的源代码进行转换。Loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于“任务”是文件级别的处理工具。</li>
<li><strong>Plugin</strong> 影响的是整个构建流程。Plugin 可以用于执行广泛的任务，比如打包优化、资源管理和环境变量注入等，影响构建结果。</li>
</ul>
<p>在实际应用中，理解 Loader 和 Plugin 的工作方式及其区别，可以帮助你更好地控制 Webpack 的行为，优化构建过程，提高应用性能。</p>
<h2 id="Vite和webpack的区别"><a href="#Vite和webpack的区别" class="headerlink" title="Vite和webpack的区别"></a>Vite和webpack的区别</h2><p>在现代前端开发中，构建工具扮演着至关重要的角色，它们帮助开发者处理模块化、编译、打包、优化等任务。<code>Webpack</code> 是最流行的构建工具之一，但除此之外还有许多其他的工具，如 <code>Vite</code>、<code>Parcel</code>、<code>Rollup</code> 等。每种工具都有其特定的用途和优势。下面我将简要介绍这些工具，并突出 <code>Vite</code> 的优势。</p>
<h3 id="Webpack-2"><a href="#Webpack-2" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 是一个模块打包器（bundler）。它适用于大型复杂的网页应用，通过 loader 和 plugins 提供了强大的整合能力。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>处理依赖：可以将几乎任何类型的文件作为模块处理。</li>
<li>丰富的插件系统：通过插件，可以扩展 webpack 的功能。</li>
<li>DevServer：提供一个简单的 web 服务器和实现热重载（HMR）。</li>
<li>Splitting：代码分割支持，有助于优化加载时间。</li>
</ul>
<h3 id="Vite-1"><a href="#Vite-1" class="headerlink" title="Vite"></a>Vite</h3><p>Vite 是一种新兴的前端构建工具，由 Vue.js 的创作者开发。它利用现代浏览器的原生 ES 模块导入（ESM）功能来提供快速的开发环境启动。</p>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>快速的冷启动</strong>：不需要打包操作，可以快速启动开发环境。</li>
<li><strong>即时的模块热更新（HMR）</strong>：相比传统的打包系统，HMR 更快，因为没有打包过程。</li>
<li><strong>按需编译</strong>：只有当请求时才编译模块，没有额外的开销。</li>
<li><strong>内置的优化</strong>：构建生产环境时，Vite 使用 Rollup 打包，有效利用了 Rollup 的高效代码分割和动态导入功能。</li>
</ul>
<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p>Parcel 是另一种构建工具，以其零配置为特色，非常适合简单的项目和快速原型开发。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>零配置：默认配置处理广泛的开发场景。</li>
<li>自动转换：支持许多文件类型，自动安装需要的转换器。</li>
</ul>
<h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p>Rollup 是专注于 JavaScript 库的打包，强调的是输出更少的代码和更有效的摇树优化（Tree-shaking）。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>高效的 Tree-shaking：减少冗余代码，输出更小的文件。</li>
<li>适合库的打包：输出的文件更适合作为库分发。</li>
</ul>
<h3 id="改动配置"><a href="#改动配置" class="headerlink" title="改动配置"></a>改动配置</h3><p>对于这些构建工具，实际开发中通常需要修改其默认配置以适应特定项目的需求。例如：</p>
<ul>
<li><strong>Webpack</strong>：可能需要添加 loader 处理新的文件类型，或修改 plugins 来优化打包结果。</li>
<li><strong>Vite</strong>：可能需要配置基础公共路径（base），或者插件支持更多框架和文件处理。</li>
<li><strong>Parcel &amp; Rollup</strong>：虽然 Parcel 通常不需要配置，但有时可能需要指定打包方式或代理配置；Rollup 则可能需要配置插件来支持 CommonJS 模块转换或其他语言特性。</li>
</ul>
<h3 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h3><p>选择哪个构建工具取决于项目的需求、团队的熟悉度以及期望从工具中获得的支持。Vite 的优势在于其极速的开发启动时间和按需编译，特别适合用在现代 web 开发环境中。而传统的工具如 Webpack 仍然在功能丰富性和适用于大型复杂项目方面占有一席之地。</p>
<p>vue的template如何进行转化成dom节点的？</p>
<p>给定许多个button如何设置只选择一个节点，当我点击一个按钮的时候，上一个按钮的事件消失，这个按钮触发点击事件</p>
<p>如何虚拟优化</p>
<p>如何查看窗口的大小</p>
<p>如何获取div窗口的大小</p>
<p>ts：interface、type，enum的转化是什么？</p>
<p>ES6知道什么</p>
<p>new</p>
<p>箭头函数</p>
<p>原型和原型链</p>
<p>promise的状态</p>
<p>事件循环的理解</p>
<p>$nexttick</p>
<p>diff算法</p>
<p>watch和computed</p>
<p>数据的双向绑定理解跨域</p>
<p>template渲染的过程？</p>
<p>vue3的setup，ref和reactive</p>
<p>js的垃圾回收，v8的垃圾回收</p>
<p>JavaScript 的 V8 引擎是谷歌开发的开源 JavaScript 引擎，主要用于 Chrome 浏览器和 Node.js 环境中。V8 引擎的内存回收机制是理解其性能管理的关键部分。这种机制帮助确保非活动的或不再需要的对象能够被有效地清除，从而释放内存资源。以下是 V8 内存回收的几个关键概念：</p>
<ol>
<li><p><strong>垃圾收集器的工作原理</strong>：</p>
<ul>
<li>V8 使用了一种名为“分代式垃圾回收”（Generational Garbage Collection）的方法。这种方法基于一个观察：大多数对象在内存中存活的时间很短。</li>
<li>V8 将内存分为两个主要区域：新生代（New Space）和老生代（Old Space）。新生代存放生命周期短的对象，而老生代则存放生命周期长或从新生代中晋升的对象。</li>
</ul>
</li>
<li><p><strong>新生代的垃圾回收</strong>：</p>
<ul>
<li>新生代区域相对较小，通常只占总内存的一小部分。V8 使用 Scavenge 算法来进行新生代的垃圾回收，这是一种简单高效的复制算法。</li>
<li>当进行新生代垃圾回收时，V8 把新生代内存分为两半：活动半区和闲置半区。活动的对象被复制到闲置半区，而非活动的对象则被释放。</li>
</ul>
</li>
<li><p><strong>老生代的垃圾回收</strong>：</p>
<ul>
<li>老生代的垃圾回收更复杂，因为这些对象通常更大，且数量也更多。</li>
<li>V8 主要使用 Mark-Sweep（标记-清除）和 Mark-Compact（标记-整理）算法来进行老生代的垃圾回收。标记-清除算法用于标记活动的对象并清除未标记的对象，而标记-整理算法在此基础上还会移动对象，以减少内存碎片。</li>
</ul>
</li>
<li><p><strong>增量标记</strong>：</p>
<ul>
<li>为了避免长时间的垃圾回收导致的应用停顿，V8 实现了增量标记（Incremental Marking）。在这种模式下，垃圾回收的标记过程会被分割成多个小部分，穿插在 JavaScript 应用逻辑的执行中。</li>
</ul>
</li>
<li><p><strong>延迟清理和并行回收</strong>：</p>
<ul>
<li>V8 也引入了延迟清理（Lazy Sweeping）和并行回收，这样可以在多个后台线程中进行垃圾回收，进一步减少对主线程的影响。</li>
</ul>
</li>
</ol>
<p>了解这些内存回收的机制可以帮助开发者优化 JavaScript 应用的内存使用，避免内存泄漏，并提高应用的性能和响应速度。在编写高性能的应用时，理解和适应 V8 的内存回收策略是非常重要的。</p>
<p>webpack和vite</p>
<p>快排</p>
<p>链表</p>
<p>如何不使用递归实现斐波那契数：迭代</p>
<h1 id="内存–分配、使用、回收-引用计数、标记清除–标记清楚、标记整理、增量标记"><a href="#内存–分配、使用、回收-引用计数、标记清除–标记清楚、标记整理、增量标记" class="headerlink" title="内存–分配、使用、回收-引用计数、标记清除–标记清楚、标记整理、增量标记"></a>内存–分配、使用、回收-引用计数、标记清除–标记清楚、标记整理、增量标记</h1><p>理解计算机内存涉及多个层面，包括硬件级别的物理内存和操作系统以及应用程序（如浏览器）在软件级别对内存的管理。下面详细解释这些层面。</p>
<h3 id="物理内存（硬件）"><a href="#物理内存（硬件）" class="headerlink" title="物理内存（硬件）"></a>物理内存（硬件）</h3><p>物理内存，通常称为随机存取存储器（RAM），是计算机的主要存储媒介之一。它用于临时存储正在运行的程序和当前使用的数据。内存是易失性的，意味着当计算机关闭电源时，存储在内存中的数据会丢失。</p>
<h3 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h3><p>操作系统的内存管理是确保有效、高效利用物理内存的关键机制。它包括以下几个方面：</p>
<ol>
<li><p><strong>内存分配</strong>：</p>
<blockquote>
<p>操作系统负责为每个运行的程序分配内存空间，操作系统需要在多个程序之间分配有限的物理内存。</p>
</blockquote>
<ul>
<li><p><strong>静态分配</strong>：在程序运行前就分配固定的内存空间，这种方式简单，但不够灵活。</p>
</li>
<li><p><strong>动态分配</strong>：允许程序在运行时根据需要申请和释放内存。动态分配方法包括：</p>
<ul>
<li><strong>堆分配</strong>：由操作系统维护一块内存区域（堆），程序可以动态地从中申请和释放内存。</li>
<li><strong>栈分配</strong>：操作系统为每个线程维护一个栈，用于存储局部变量和函数调用信息。栈的大小可能是固定的，或者有限度地动态增长。</li>
</ul>
</li>
<li><p>静态分配和动态分配：这包括为程序代码、数据和堆栈分配内存。</p>
</li>
</ul>
</li>
<li><p><strong>虚拟内存</strong>：</p>
<blockquote>
<p>虚拟内存是一种内存管理技术，它通过使用硬盘空间来扩展物理内存。操作系统创建一个文件（通常称为交换文件或分页文件），用于存储临时从内存中移出的数据。</p>
</blockquote>
<p>虚拟内存是现代操作系统用来扩展可用物理内存的技术。它允许程序使用比实际物理内存更多的地址空间，通过以下机制实现：</p>
<ul>
<li><strong>分页</strong>：将虚拟内存分成固定大小的页，独立于物理内存的大小。操作系统维护一个页表，将虚拟页映射到物理页。</li>
<li><strong>分段</strong>：将内存分为逻辑上的段，如代码段、数据段等。分段可以基于程序的逻辑结构优化内存使用。</li>
</ul>
<blockquote>
<p>操作系统通常通过分页机制管理内存。系统内存被分割成固定大小的页。分页允许操作系统只加载程序需要的内存页，减少内存消耗。分页是虚拟内存实现的核心，具体包括：</p>
</blockquote>
<ul>
<li><p><strong>页表</strong>：维护虚拟地址到物理地址的映射。每个进程都有自己的页表。</p>
</li>
<li><p><strong>TLB（Translation Lookaside Buffer）</strong>：是一种缓存，用于加速虚拟地址到物理地址的转换过程。</p>
</li>
<li><p><strong>页替换算法</strong>：当内存满时，如何选择一个页来替换，常见算法有LRU（<strong>最近最少使用</strong>）、FIFO（<strong>先进先出</strong>）和OPT（<strong>最优替换</strong>）。</p>
</li>
<li><p>分段是另一种内存管理技术，它允许程序和数据被分割成逻辑上的段。</p>
</li>
</ul>
</li>
<li><p><strong>内存保护</strong>：</p>
<blockquote>
<p>作系统通过内存保护确保一个程序不会干扰其他程序的内存空间。这通过以下方式实现：</p>
</blockquote>
<ul>
<li><strong>访问控制</strong>：页表中的每一项可以包含访问权限标记，如可读、可写和可执行。</li>
<li><strong>基址和界限寄存器</strong>：用于检查每个内存访问是否在允许的地址范围内。</li>
</ul>
</li>
<li><p><strong>内存碎片</strong></p>
</li>
</ol>
<blockquote>
<p>内存碎片分为两类：</p>
</blockquote>
<p><strong>内部碎片</strong>：分配给程序的内存块比需要的大，剩下的部分未被使用。<br><strong>外部碎片</strong>：随着时间推移，内存的释放和分配导致空闲内存块之间散布着未使用的小块内存。</p>
<ol start="6">
<li><strong>内存压缩</strong></li>
</ol>
<blockquote>
<p>内存压缩是解决内存碎片问题的一种方法，通过移动已分配的内存块，来整合连续的空闲内存块，从而优化内存的使用。</p>
</blockquote>
<ol start="7">
<li><strong>大页支持</strong></li>
</ol>
<blockquote>
<p>一些操作系统提供大页支持（如HugePages in Linux），允许应用程序使用比标准更大的页尺寸。这减少了页表项的数量，降低了TLB miss的概率，提高了内存访问的效率。</p>
</blockquote>
<h3 id="浏览器的内存管理"><a href="#浏览器的内存管理" class="headerlink" title="浏览器的内存管理"></a>浏览器的内存管理</h3><p>浏览器作为应用程序，也需要进行内存管理，以确保快速响应和有效利用系统资源。浏览器的内存管理包括：</p>
<ol>
<li><p><strong>JavaScript 内存管理</strong>：</p>
<ul>
<li>JavaScript 在浏览器中通过自动垃圾回收机制来管理内存。垃圾回收器定期检查那些不再被应用程序代码引用的对象，并释放它们的内存。</li>
</ul>
</li>
<li><p><strong>内存隔离</strong>：</p>
<ul>
<li>现代浏览器采用进程和线程的隔离策略，确保一个标签页或插件崩溃不会影响到其他标签页。这意味着每个标签页都可以有自己独立的内存空间。</li>
</ul>
</li>
<li><p><strong>内存限制</strong>：</p>
<ul>
<li>浏览器对每个标签页或插件的内存使用进行限制，以防单个网页消耗过多内存影响整个系统的性能。</li>
</ul>
</li>
<li><p><strong>性能监控和优化</strong>：</p>
<ul>
<li>开发者可以使用浏览器提供的开发者工具（如 Chrome 的 DevTools）来监控网页的内存使用情况，识别内存泄漏等问题，并进行优化。</li>
</ul>
</li>
</ol>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>计算机内存的管理是一个复杂的过程，涉及硬件资源的直接管理和通过操作系统及应用程序（如浏览器）的高级管理。有效的内存管理策略可以提高计算机的性能和响应速度，确保系统的稳定运行。对于开发者来说，理解和优化内存的使用是提高应用性能的关键。</p>
<p>虚拟内存是一种计算机系统内存管理的技术，它使得应用程序认为它拥有连续的可用内存，而实际上这些内存可能会被分散存储在物理内存和磁盘存储（通常是硬盘上的交换空间或分页文件）中。虚拟内存的引入主要是为了解决物理内存容量有限的问题，它通过有效地利用磁盘空间来扩展可用内存，从而提供更大的内存空间给程序使用。</p>
<h3 id="虚拟内存的工作原理"><a href="#虚拟内存的工作原理" class="headerlink" title="虚拟内存的工作原理"></a>虚拟内存的工作原理</h3><ol>
<li><p><strong>内存分页</strong>：虚拟内存将内存分成称为“页”的小块数据。操作系统维护一个页表来记录虚拟页和物理页之间的映射关系。</p>
</li>
<li><p><strong>页替换算法</strong>：当程序访问的数据不在物理内存中时，会发生“缺页中断”（Page Fault）。操作系统选择一个物理内存中的页来替换，将需要的数据从磁盘读入物理内存。选择哪个页来替换，是由页替换算法决定的，如最近最少使用（LRU）算法、先进先出（FIFO）算法等。</p>
</li>
<li><p><strong>交换空间</strong>：交换空间是硬盘上预留的一部分，用于存放被换出的页。这个空间可以是一个专门的交换分区或一个文件。</p>
</li>
<li><p><strong>地址转换</strong>：每当应用程序访问内存时，它使用的是虚拟地址。CPU中的内存管理单元（MMU）将这些虚拟地址转换为物理地址。如果所需的虚拟页在物理内存中，转换就很快完成；如果不在，操作系统将从磁盘中调入数据，更新页表，然后继续地址转换。</p>
</li>
</ol>
<h3 id="虚拟内存的优点"><a href="#虚拟内存的优点" class="headerlink" title="虚拟内存的优点"></a>虚拟内存的优点</h3><ul>
<li><strong>扩展内存</strong>：允许程序使用比实际物理内存更多的内存。</li>
<li><strong>安全和隔离</strong>：每个程序都有自己的虚拟地址空间，这意味着一个程序无法访问或干扰另一个程序的数据。</li>
<li><strong>内存管理简化</strong>：程序员可以认为每个程序都有一大块连续的内存，而无需担心物理内存的分配问题。</li>
</ul>
<h3 id="虚拟内存的缺点"><a href="#虚拟内存的缺点" class="headerlink" title="虚拟内存的缺点"></a>虚拟内存的缺点</h3><ul>
<li><strong>性能开销</strong>：虚拟内存的使用会引入额外的性能开销，因为涉及到磁盘I&#x2F;O操作和地址转换。特别是当系统频繁进行页交换时，性能会显著下降，这种现象称为“抖动”（Thrashing）。</li>
<li><strong>管理复杂性</strong>：虽然对程序员来说内存管理简化了，但操作系统需要处理更复杂的内存管理任务，如页替换、缺页中断处理等。</li>
</ul>
<p>虚拟内存是现代计算机系统中不可或缺的一部分，尤其在多任务操作系统和需要运行大型应用程序的环境中尤为重要。</p>
<p>在现代浏览器中，是否将每个标签页作为一个独立进程处理取决于浏览器的架构。Google Chrome 是最早采用每个标签页一个进程策略的主流浏览器之一，这种设计被称为“多进程架构”。</p>
<h3 id="多进程架构的优点"><a href="#多进程架构的优点" class="headerlink" title="多进程架构的优点"></a>多进程架构的优点</h3><ol>
<li><strong>隔离性</strong>：每个标签页在各自的进程中运行，这意味着一个标签页的崩溃不会影响到其他标签页。这提高了浏览器的稳定性和安全性。</li>
<li><strong>安全性</strong>：通过进程隔离，可以更有效地实施安全策略，防止恶意网站或脚本影响其他标签页或整个系统。</li>
<li><strong>响应性</strong>：多进程模型可以利用现代多核处理器的能力，通过并行处理提高响应速度。</li>
</ol>
<h3 id="多进程架构的缺点"><a href="#多进程架构的缺点" class="headerlink" title="多进程架构的缺点"></a>多进程架构的缺点</h3><ol>
<li><strong>内存使用</strong>：每个进程都会有一定的内存开销，因此多进程架构的浏览器通常会消耗更多的内存。</li>
<li><strong>资源管理</strong>：需要更复杂的进程管理和通信机制，特别是在进程之间共享和同步数据时。</li>
</ol>
<h3 id="浏览器的实际实现"><a href="#浏览器的实际实现" class="headerlink" title="浏览器的实际实现"></a>浏览器的实际实现</h3><ul>
<li><strong>Google Chrome</strong>：采用了一种名为“每个站点一个进程”的策略，即通常情况下每个标签页运行在单独的进程中，但来自同一站点的标签页可能共享一个进程。</li>
<li><strong>Mozilla Firefox</strong>：Firefox 采用了“Electrolysis”（简称e10s）架构，它同样支持多进程，但其默认策略并非为每个标签页分配独立进程。Firefox可以配置为运行多个内容进程，这些内容进程中可以承载一个或多个标签页。</li>
<li><strong>Microsoft Edge</strong>：最新版的Edge基于Chromium，与Chrome类似，采用多进程架构。</li>
<li><strong>Safari</strong>：也支持多进程架构，但其进程管理的具体策略可能与Chrome和Firefox有所不同。</li>
</ul>
<p>总的来说，现代浏览器趋向于使用多进程架构以提高安全性和稳定性，尽管这可能导致更高的内存消耗。每个浏览器的具体实现可能会根据性能、内存使用和安全性之间的权衡做出不同的设计选择。</p>
<p>对于JavaScript及其在浏览器中的内存管理和存储机制的理解，可以从几个方面详细进行分析和总结：</p>
<h3 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1. 浏览器缓存"></a>1. 浏览器缓存</h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存不会向服务器发送请求，直接从缓存中读取资源。可以通过设置HTTP响应头<code>Cache-Control</code>和<code>Expires</code>来控制。<code>Cache-Control: max-age=3600</code>表示资源可以被缓存，并且是有效的，直到3600秒后。<code>Expires</code>则提供一个具体的时间点，告诉浏览器资源有效期。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>当强缓存失效后，浏览器会向服务器发送请求，通过<code>Last-Modified</code>&#x2F;<code>If-Modified-Since</code>或<code>ETag</code>&#x2F;<code>If-None-Match</code>来检查资源是否更新。如果资源未更新，服务器返回304状态码，告诉浏览器继续使用缓存。</p>
<h3 id="3-JavaScript内存管理"><a href="#3-JavaScript内存管理" class="headerlink" title="3. JavaScript内存管理"></a>3. JavaScript内存管理</h3><p>JavaScript的内存管理是自动的，主要通过垃圾回收机制来实现。</p>
<h4 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul>
<li><strong>标记清除</strong>：这是最常用的垃圾回收算法。当变量进入环境时标记为“进入环境”，当变量离开环境时标记为“离开环境”。标记为“离开环境”的变量将被视为垃圾，并被收集和回收。</li>
<li><strong>引用计数</strong>：这种方法跟踪每个值被引用的次数。当引用次数变为0时，值会被标记为可回收。然而，引用计数方法不能解决循环引用的问题。</li>
</ul>
<h3 id="4-V8引擎的垃圾回收"><a href="#4-V8引擎的垃圾回收" class="headerlink" title="4. V8引擎的垃圾回收"></a>4. V8引擎的垃圾回收</h3><p>V8引擎用于Google Chrome浏览器，使用了更复杂的垃圾回收策略，包括新生代和老生代的分代回收：</p>
<ul>
<li><strong>新生代</strong>：from、to存放生命周期短的小对象，使用Scavenge算法，其中主要用到复制方式，将活动对象从一个区域复制到另一个区域。</li>
<li><strong>老生代</strong>：存放生命周期长或常驻内存的对象，使用标记-清除和标记-整理算法来减少碎片。</li>
</ul>
<h3 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h3><p>JavaScript的内存管理和浏览器存储是现代web开发中不可或缺的一部分，了解这些机制可以帮助开发者更好地优化其应用性能和用户体验。通过合理使用各种存储方式，并理解垃圾回收的工作原理，可以有效地管理应用的内存使用，避免内存泄漏和过度占用资源的问题。</p>
<p>关于JavaScript和浏览器存储及内存管理，还有一些其他重要的方面可以补充，这些包括内存泄漏的识别与预防，Web Workers的使用，以及内存性能监控工具的应用。</p>
<h3 id="5-内存泄漏的识别与预防"><a href="#5-内存泄漏的识别与预防" class="headerlink" title="5. 内存泄漏的识别与预防"></a>5. 内存泄漏的识别与预防</h3><p>内存泄漏在JavaScript中是一种常见的性能问题，通常由未被垃圾回收机制清除的持续占用内存的对象引起。一些常见的内存泄漏原因包括：</p>
<ul>
<li><strong>全局变量</strong>：无意中创建的全局变量可能不会被回收。</li>
<li><strong>定时器和回调函数</strong>：未被清除的定时器或回调函数可以持续占用内存。</li>
<li><strong>DOM 引用</strong>：被删除的DOM元素如果仍被JavaScript引用，也会导致内存泄漏。</li>
<li><strong>闭包</strong>：不恰当的闭包使用可能导致父函数作用域内的变量无法被释放。</li>
</ul>
<p>预防内存泄漏的策略包括：</p>
<ul>
<li><strong>限制全局变量的使用</strong>：使用严格模式(<code>use strict</code>)来避免意外创建全局变量。</li>
<li><strong>及时清理</strong>：定时器应当在不需要时清除，事件监听器在元素被移除前应当被移除。</li>
<li><strong>使用弱引用</strong>：如<code>WeakMap</code>和<code>WeakSet</code>允许其内容在没有其他引用时被垃圾回收。</li>
</ul>
<h3 id="6-Web-Workers的使用"><a href="#6-Web-Workers的使用" class="headerlink" title="6. Web Workers的使用"></a>6. Web Workers的使用</h3><p>Web Workers提供了一种将执行过程从主线程中分离出来的方法，使得可以在后台线程中执行复杂计算，避免阻塞UI。这对于提升大数据处理或复杂计算的应用的响应性非常有帮助。使用Web Workers时，需要注意数据是通过复制而非共享方式传递，这意味着原始数据和Worker之间不会相互影响。</p>
<h3 id="7-内存性能监控工具"><a href="#7-内存性能监控工具" class="headerlink" title="7. 内存性能监控工具"></a>7. 内存性能监控工具</h3><p>为了有效地监控和分析JavaScript的内存使用情况，可以使用以下工具：</p>
<ul>
<li><strong>Chrome DevTools</strong>：提供了强大的内存分析工具，包括堆快照(Heap Snapshot)、记录堆分配(Record Heap Allocations)和时间线(Timeline)视图等，可以帮助开发者识别内存泄漏和优化性能。</li>
<li><strong>Performance API</strong>：这是一个浏览器API，允许收集和分析在应用运行时的性能数据。</li>
</ul>
<h3 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a>结论</h3><p>通过以上的详细介绍，我们可以更全面地理解JavaScript的内存管理、浏览器缓存和本地存储机制。适当地应用这些知识和工具，可以显著提高Web应用的性能和用户体验。同时，防止内存泄漏和合理利用多线程计算资源也是提升现代Web应用质量的重要策略。</p>
<p>当谈到在Web开发中监控JavaScript性能的实例数据，我们通常关注以下几个关键指标：</p>
<h3 id="1-时间线数据-Timeline-Data"><a href="#1-时间线数据-Timeline-Data" class="headerlink" title="1. 时间线数据 (Timeline Data)"></a>1. <strong>时间线数据 (Timeline Data)</strong></h3><p>在Chrome DevTools中，时间线工具可以记录和展示一个页面在加载和运行过程中的详细活动。这包括了JavaScript执行时间、样式计算、布局、绘制等。一个示例性的时间线数据可能如下：</p>
<ul>
<li><strong>加载事件</strong>：页面开始加载到onLoad事件触发的时间。</li>
<li><strong>DOMContentLoaded</strong>：DOM解析完成的时间。</li>
<li><strong>脚本执行时间</strong>：单个脚本或脚本总和的执行时间。</li>
<li><strong>渲染时间</strong>：页面进行渲染的时间点和持续时间。</li>
<li><strong>帧速率</strong>：动画或页面滚动的帧速率。</li>
</ul>
<h3 id="2-堆快照-Heap-Snapshot-–控制台的memory"><a href="#2-堆快照-Heap-Snapshot-–控制台的memory" class="headerlink" title="2. 堆快照 (Heap Snapshot)–控制台的memory"></a>2. <strong>堆快照 (Heap Snapshot)</strong>–控制台的memory</h3><p>heap snapshot</p>
<p>堆快照显示了在某一时刻JavaScript的所有对象及其关系的内存分布情况。这可以帮助开发者发现内存泄漏。示例数据可能包括：</p>
<ul>
<li><strong>对象数</strong>：当前内存中存在的对象总数。</li>
<li><strong>分配大小</strong>：每种对象类型占用的内存大小。</li>
<li><strong>保留大小</strong>：对象及其依赖对象总共占用的内存大小。</li>
<li><strong>垃圾可回收</strong>：已被标记为可回收但尚未清理的内存。</li>
</ul>
<h3 id="3-性能记录-Performance-Record"><a href="#3-性能记录-Performance-Record" class="headerlink" title="3. 性能记录 (Performance Record)"></a>3. <strong>性能记录 (Performance Record)</strong></h3><p>使用Chrome DevTools的Performance panel可以记录一段时间内页面的运行情况，包括JS执行、样式计算、布局、绘制等。性能记录的数据可能包括：</p>
<ul>
<li><strong>函数调用</strong>：函数调用的次数和耗时。</li>
<li>**FPS (帧率)**：在记录期间的帧率，理想状态下接近60fps。</li>
<li><strong>CPU利用率</strong>：JavaScript执行对CPU的占用情况。</li>
</ul>
<h3 id="4-网络请求-Network-Requests"><a href="#4-网络请求-Network-Requests" class="headerlink" title="4. 网络请求 (Network Requests)"></a>4. <strong>网络请求 (Network Requests)</strong></h3><p>监控网络请求可以帮助识别加载资源的瓶颈。性能监控数据可能包括：</p>
<ul>
<li><strong>请求时间</strong>：每个资源从请求到完成的时间。</li>
<li><strong>资源大小</strong>：下载的每个文件的大小。</li>
<li><strong>缓存状态</strong>：资源是否被缓存。</li>
</ul>
<h3 id="示例：性能监控报告"><a href="#示例：性能监控报告" class="headerlink" title="示例：性能监控报告"></a>示例：性能监控报告</h3><p>假设有一个页面加载分析报告，内容可能如下：</p>
<ul>
<li><strong>总加载时间</strong>：5秒</li>
<li><strong>脚本执行总时间</strong>：1.2秒</li>
<li><strong>最大DOM深度</strong>：22层</li>
<li><strong>重绘次数</strong>：15次</li>
<li><strong>内存使用峰值</strong>：150MB</li>
<li><strong>网络请求</strong>：50个请求，总共传输数据1MB</li>
</ul>
<h3 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a>结论</h3><p>这些性能监控数据帮助开发者深入理解Web应用的行为和性能瓶颈。通过定期检查这些指标，可以持续优化应用，改善用户体验。在现代Web开发中，有效地利用这些工具和数据是至关重要的。</p>
<p>进程和线程的区别</p>
<p>kmp算法</p>
<h1 id="微前端路由拦截"><a href="#微前端路由拦截" class="headerlink" title="微前端路由拦截"></a>微前端路由拦截</h1><h3 id="拦截的浏览器路由API"><a href="#拦截的浏览器路由API" class="headerlink" title="拦截的浏览器路由API"></a>拦截的浏览器路由API</h3><ol>
<li><p><strong>History API</strong>: </p>
<ul>
<li><code>history.pushState()</code></li>
<li><code>history.replaceState()</code></li>
<li><code>history.go()</code></li>
<li><code>history.back()</code></li>
<li><code>history.forward()</code></li>
</ul>
<p>这些方法是HTML5 History API的一部分，用于在不重新加载页面的情况下操作浏览器的历史记录和路由状态。</p>
</li>
<li><p><strong>Hash Changes</strong>:</p>
<ul>
<li>监听 <code>hashchange</code> 事件</li>
</ul>
<p>对于基于哈希的路由（通常在旧的单页应用中使用），监听 <code>hashchange</code> 事件是必要的，以便在URL的哈希部分变化时触发路由逻辑。</p>
</li>
</ol>
<h3 id="如何进行路由拦截"><a href="#如何进行路由拦截" class="headerlink" title="如何进行路由拦截"></a>如何进行路由拦截</h3><p>在微前端架构中，通常会有一个中心化的路由管理器或框架负责处理这些拦截。以下是一些常见的实现方法和技术：</p>
<ol>
<li><p><strong>使用 single-spa</strong>:</p>
<ul>
<li>Single-spa 提供了一个路由前缀的概念，通过配置哪些前缀或路径激活特定的子应用。它通过监听浏览器的 <code>popstate</code> 事件和拦截 <code>pushState</code> 和 <code>replaceState</code> 方法来实现。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, handlePopState);</span><br><span class="line"><span class="keyword">const</span> originalPushState = history.<span class="property">pushState</span>;</span><br><span class="line">history.<span class="property">pushState</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    originalPushState.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="title function_">handleRouteChange</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动拦截 History API</strong>:</p>
<ul>
<li>在主应用的入口文件中，可以手动覆盖 <code>history.pushState</code> 和 <code>history.replaceState</code> 方法，以便在路由改变时执行额外的逻辑，比如加载或卸载子应用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalPushState = history.<span class="property">pushState</span>;</span><br><span class="line">history.<span class="property">pushState</span> = <span class="keyword">function</span>(<span class="params">state, title, url</span>) &#123;</span><br><span class="line">    originalPushState.<span class="title function_">call</span>(history, state, title, url);</span><br><span class="line">    <span class="title function_">dispatchRouteChange</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">dispatchRouteChange</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchRouteChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理子应用的加载和卸载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>框架特定的路由守卫</strong>:</p>
<ul>
<li>对于使用 Vue 或 React 等框架的应用，可以利用框架提供的路由守卫功能（如 Vue 的 <code>beforeEach</code> 路由守卫或 React Router 的 <code>history.listen</code>）。</li>
</ul>
<p>在 Vue 中使用 <code>vue-router</code> 的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里根据路由切换逻辑加载或卸载子应用</span></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在 React 中使用 React Router 的示例：<br>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useRouteChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> history = <span class="title function_">useHistory</span>();</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> unlisten = history.<span class="title function_">listen</span>(<span class="function">(<span class="params">location, action</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 在这里处理路由变化</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">unlisten</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="结论-9"><a href="#结论-9" class="headerlink" title="结论"></a>结论</h3><p>微前端的路由拦截主要是通过拦截和管理浏览器的 History API 实现的，确保在主应用和子应用之间正确地管理和协调路由状态。这要求在设计微前端架构时，要有一个清晰的路由管理策略，以保证应用的整体性和用户体验的流畅性。</p>
<h1 id="9-20-阳光能源"><a href="#9-20-阳光能源" class="headerlink" title="9-20-阳光能源"></a>9-20-阳光能源</h1><p>数据类型</p>
<p>栈和队列</p>
<p>强缓存设置的max-age为一年，现在不使用强缓存，如何获取最新的数据</p>
<p>防抖和节流</p>
<p>bigint</p>
<p>后端返回json为空如何判断</p>
<p>如何判断对象的属性相等</p>
<p>块级作用域</p>
<p>MVVM是什么？如果在input触发事件，这是哪个层面</p>
<p>发布订阅</p>
<h1 id="商汤科技"><a href="#商汤科技" class="headerlink" title="商汤科技"></a>商汤科技</h1><p>Map和object的区别</p>
<h1 id="小米-1"><a href="#小米-1" class="headerlink" title="小米"></a>小米</h1><p>项目</p>
<p>微前端的选型，有遇到什么问题吗</p>
<p>项目的权限</p>
<p>pinia</p>
<p>内容的持久化存储</p>
<p>分片上传和断点续传</p>
<p>性能优化：图片预加载+懒加载，CDN，</p>
<p>算法题<br>一个以字符串表示的非负整数 num 和一个整数k，移除这个数中的k位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。<br>示例1:<br>输入:num&#x3D;”1432219”,k&#x3D;3<br>输出:”1219”<br>解释:移除掉三个数字 4,3,和 2 形成一个新的最小的数字 1219<br>示例 2:<br>输入:num&#x3D;”10200”，k&#x3D;1<br>输出:”200”<br>解释:移掉首位的1剩下的数字为 200.注意输出不能有任何前导零<br>示例 3<br>输入:num&#x3D;”10”,k&#x3D;2<br>输出:”O”<br>解释:从原数字移除所有的数字，剩余为空就是0</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeKDigits</span>(<span class="params">num, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> digit = num[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前数字小于栈顶数字，并且还有删除次数 k ，则弹出栈顶元素</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; stack.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] &gt; digit) &#123;</span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把当前数字加入栈</span></span><br><span class="line">        stack.<span class="title function_">push</span>(digit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果还有未删除的 k 位数，继续从栈顶删除</span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        stack.<span class="title function_">pop</span>();</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导零</span></span><br><span class="line">    <span class="keyword">let</span> result = stack.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/^0+/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果结果为空，则返回 &quot;0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> result === <span class="string">&#x27;&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">removeKDigits</span>(<span class="string">&quot;1432219&quot;</span>, <span class="number">3</span>)); <span class="comment">// 输出 &quot;1219&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">removeKDigits</span>(<span class="string">&quot;10200&quot;</span>, <span class="number">1</span>));   <span class="comment">// 输出 &quot;200&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">removeKDigits</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>));      <span class="comment">// 输出 &quot;0&quot;</span></span><br></pre></td></tr></table></figure>


<p>题目描述给定一个经过编码的字符串，返回它解码后的字符串.编码规则为: k[encoded string]，表示其中方括号内部的encoded string 正好重复k次。注意k保证为正整数。你可以认为输入字符串总是有效的;输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数k，例如不会出现像 3a 或 2[4]的输入。示例 1: 输入:s&#x3D;”3[a]2[bc] 输出:”aaabcbc” 示例 2: 输入:s &#x3D;”3[a2[c]]’ 输出:”accaccacc 示例 3: 输入:s&#x3D;”2[abc]3[cd]ef” 出:”abcabccdcdcdef’ 示例 4: 输入:s&#x3D;”abc3[cd]xyz 输出:”abccdcdcdxyz” 请用js进行代码的编写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decodeString</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> numStack = []; <span class="comment">// 用来存储数字</span></span><br><span class="line">    <span class="keyword">let</span> strStack = []; <span class="comment">// 用来存储当前的字符串</span></span><br><span class="line">    <span class="keyword">let</span> currentStr = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 当前构建的字符串</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>; <span class="comment">// 当前构建的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> char = s[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(char)) &#123;</span><br><span class="line">            <span class="comment">// 如果是数字，构建当前数字（可能有多位数的情况）</span></span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">parseInt</span>(char);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到 &#x27;[&#x27; 时，将当前的数字和字符串压入栈中，开始新的构建</span></span><br><span class="line">            numStack.<span class="title function_">push</span>(num);</span><br><span class="line">            strStack.<span class="title function_">push</span>(currentStr);</span><br><span class="line">            currentStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            num = <span class="number">0</span>; <span class="comment">// 重置数字</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到 &#x27;]&#x27; 时，解码字符串</span></span><br><span class="line">            <span class="keyword">let</span> repeatTimes = numStack.<span class="title function_">pop</span>(); <span class="comment">// 取出数字</span></span><br><span class="line">            <span class="keyword">let</span> previousStr = strStack.<span class="title function_">pop</span>(); <span class="comment">// 取出之前构建的字符串</span></span><br><span class="line">            currentStr = previousStr + currentStr.<span class="title function_">repeat</span>(repeatTimes); <span class="comment">// 重复当前字符串并与之前的拼接</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是字母，直接添加到当前字符串中</span></span><br><span class="line">            currentStr += char;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">decodeString</span>(<span class="string">&quot;3[a]2[bc]&quot;</span>));      <span class="comment">// 输出 &quot;aaabcbc&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">decodeString</span>(<span class="string">&quot;3[a2[c]]&quot;</span>));       <span class="comment">// 输出 &quot;accaccacc&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">decodeString</span>(<span class="string">&quot;2[abc]3[cd]ef&quot;</span>));  <span class="comment">// 输出 &quot;abcabccdcdcdef&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">decodeString</span>(<span class="string">&quot;abc3[cd]xyz&quot;</span>));    <span class="comment">// 输出 &quot;abccdcdcdxyz&quot;</span></span><br></pre></td></tr></table></figure>

<p>sandbox</p>
<p>组件通信</p>
<p>白屏怎么处理</p>
<p>http状态码</p>
<p>虚拟列表</p>
<h1 id="得物"><a href="#得物" class="headerlink" title="得物"></a>得物</h1><p>微前端的比较难的问题，性能优化</p>
<p>前端性能优化中，如果有10mb的图片，使用懒加载怎么更好？</p>
<p>dns</p>
<p>对称加密和非对称加密的区别</p>
<p>怎么避免中间人攻击，非对称加密？</p>
<h2 id="Etag生成的策略？"><a href="#Etag生成的策略？" class="headerlink" title="Etag生成的策略？"></a>Etag生成的策略？</h2><p>Etag（Entity Tag）是HTTP协议中的一个机制，用于标识资源的版本或状态。它通常被用来进行缓存控制和并发控制，帮助服务器判断资源是否已经发生了变化，从而决定是否返回新的数据或使用缓存。Etag的生成策略可以根据具体的需求和应用场景有所不同，下面是几种常见的生成Etag的策略。</p>
<h3 id="1-基于文件内容的哈希值"><a href="#1-基于文件内容的哈希值" class="headerlink" title="1. 基于文件内容的哈希值"></a>1. <strong>基于文件内容的哈希值</strong></h3><p>最常见的Etag生成策略是通过对资源的内容进行哈希计算来生成唯一标识符。当资源内容发生变化时，其哈希值也会随之变化，这样就能确保Etag始终反映最新的资源状态。</p>
<ul>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li>可以使用MD5、SHA-1、SHA-256等哈希算法对资源内容进行计算。</li>
<li>生成的哈希值可以是一个固定长度的字符串，用作Etag。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>当资源的内容发生任何细微变化时，Etag都会更新，非常准确。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>对于大文件或大数据资源，每次生成哈希值时的计算开销可能较大，特别是在资源经常更新的情况下。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: &quot;5d41402abc4b2a76b9719d911017c592&quot;  (基于文件内容生成的MD5哈希值)</span><br></pre></td></tr></table></figure>

<h3 id="2-基于资源的版本号"><a href="#2-基于资源的版本号" class="headerlink" title="2. 基于资源的版本号"></a>2. <strong>基于资源的版本号</strong></h3><p>另一种常见策略是通过为资源分配一个版本号，当资源发生变化时，增加或更新版本号。这个版本号可以作为Etag的内容。</p>
<ul>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li>每当资源更新时，版本号递增。例如数据库记录更新时，自动生成一个新的版本号。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>实现简单，不需要计算哈希，适合那些可以明确跟踪资源版本的场景。</li>
<li>计算开销小，特别适合动态生成内容的场景。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>版本号只反映资源的逻辑变化，不能精确描述内容的实际变化。如果更新未导致内容实际变化，版本号仍然会变化。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: &quot;v123456&quot;  (基于资源的版本号)</span><br></pre></td></tr></table></figure>

<h3 id="3-基于文件的最后修改时间"><a href="#3-基于文件的最后修改时间" class="headerlink" title="3. 基于文件的最后修改时间"></a>3. <strong>基于文件的最后修改时间</strong></h3><p>Etag也可以根据资源的最后修改时间生成。通过时间戳来表示资源的最后更新时间，如果资源发生变化，其时间戳也会更新。</p>
<ul>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li>读取资源的最后修改时间，使用该时间作为Etag的内容。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>简单高效，特别适用于文件系统中的静态资源。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>可能不够精确，如果修改时间精度不够高，可能无法检测出一些细微的变化。</li>
<li>如果修改时间被手动更改，可能导致Etag失效。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: &quot;W/\&quot;1633036800\&quot;&quot;  (基于Unix时间戳的Etag)</span><br></pre></td></tr></table></figure>

<h3 id="4-强Etag与弱Etag"><a href="#4-强Etag与弱Etag" class="headerlink" title="4. 强Etag与弱Etag"></a>4. <strong>强Etag与弱Etag</strong></h3><ul>
<li><p><strong>强Etag</strong>：强Etag要求资源的每一个字节都精确一致，任何细微变化都会生成不同的Etag。例如基于内容哈希值生成的Etag是强Etag的一种。</p>
</li>
<li><p><strong>弱Etag</strong>：弱Etag允许某些小的资源变化不影响Etag，例如不同的服务器时间、不同的文件系统属性变化等。弱Etag在值前面会带有<code>W/</code>前缀，表示它是弱校验。</p>
<ul>
<li>弱Etag常常用于那些对资源精确度要求不高的场景，例如网页的样式表等。如果只是一些格式变化或者无关紧要的元数据变化，弱Etag不会更新。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: W/&quot;5d41402abc4b2a76b9719d911017c592&quot;  (弱Etag)</span><br></pre></td></tr></table></figure>

<h3 id="5-基于资源大小和最后修改时间的组合"><a href="#5-基于资源大小和最后修改时间的组合" class="headerlink" title="5. 基于资源大小和最后修改时间的组合"></a>5. <strong>基于资源大小和最后修改时间的组合</strong></h3><p>在某些情况下，服务器可能会采用文件大小和最后修改时间的组合来生成Etag。比如，文件大小没有变化，而最后修改时间发生了变化，则Etag可能不变，反之亦然。这种方法有助于平衡计算开销和准确性。</p>
<ul>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li>获取资源的大小和最后修改时间，然后将它们组合成一个字符串或使用它们生成哈希值作为Etag。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>性能较好，因为无需对内容进行复杂的哈希运算。</li>
<li>可用于检测资源是否进行了实际修改。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>如果资源大小和修改时间相同，但内容不同，则无法检测变化。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: &quot;1000-1633036800&quot;  (基于大小和时间戳组合)</span><br></pre></td></tr></table></figure>

<h3 id="6-自定义生成策略"><a href="#6-自定义生成策略" class="headerlink" title="6. 自定义生成策略"></a>6. <strong>自定义生成策略</strong></h3><p>对于一些复杂应用，Etag可以基于应用的特定逻辑生成。例如，某些动态生成的内容可能基于数据库的查询结果或某些用户特定的信息生成。这时，Etag可以基于数据的标识符、查询条件等动态元素来生成。</p>
<ul>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li>根据应用的逻辑，生成与内容变化相关的Etag，例如：用户ID + 数据更新时间。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>更加灵活，适应应用的特定需求。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>实现复杂，可能需要额外的逻辑来确保Etag的准确性。</li>
</ul>
</li>
</ul>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>Etag的生成策略取决于应用场景和性能要求，以下是几种常用策略的对比：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基于内容哈希</strong></td>
<td>高精度，任何细微变化都会更新Etag</td>
<td>计算开销较大，尤其是对于大文件或复杂资源</td>
<td>静态文件、需确保内容完全一致的场景</td>
</tr>
<tr>
<td><strong>基于版本号</strong></td>
<td>简单，开销小</td>
<td>无法精确反映实际内容的变化</td>
<td>动态生成的内容、版本管理的资源</td>
</tr>
<tr>
<td><strong>基于修改时间</strong></td>
<td>高效，适用于文件系统中的静态资源</td>
<td>时间精度问题，无法捕捉细微的内容变化</td>
<td>静态文件或不频繁更新的文件</td>
</tr>
<tr>
<td><strong>强Etag vs 弱Etag</strong></td>
<td>强Etag适合精确变化跟踪，弱Etag适合性能优化</td>
<td>弱Etag无法检测所有变化，强Etag计算量大</td>
<td>精确或容许小变动的场景</td>
</tr>
<tr>
<td><strong>大小 + 修改时间组合</strong></td>
<td>性能较好，精确度适中</td>
<td>不能检测大小和时间相同时的内容变化</td>
<td>文件较大且更新频繁的资源</td>
</tr>
<tr>
<td><strong>自定义策略</strong></td>
<td>灵活适应特定应用需求</td>
<td>实现复杂，需要额外的逻辑处理</td>
<td>复杂动态内容或特定业务逻辑的资源管理场景</td>
</tr>
</tbody></table>
<p>最终，选择哪种Etag生成策略，取决于<strong>性能需求</strong>、<strong>资源更新频率</strong>、以及<strong>内容一致性的重要性</strong>等因素。在实际应用中，结合缓存策略来优化资源的传输效率也是十分重要的。</p>
<p>如果内容有静态资源，怎么去进行优化？</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Lavender321.github.com">流泪猫猫头</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lavender321.github.com/2023/02/17/%E8%8F%9C%E9%B8%9F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95U%C2%B7%E3%82%A7%C2%B7U/">http://lavender321.github.com/2023/02/17/%E8%8F%9C%E9%B8%9F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95U%C2%B7%E3%82%A7%C2%B7U/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Lavender321.github.com" target="_blank">Lavender's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">React面试题</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/" title="前端面试之道"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端面试之道</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/27/JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="JavaScript数组常用方法总结"><img class="cover" src="https://s2.loli.net/2022/12/31/HYB9fKZPknOqSLz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-27</div><div class="title">JavaScript数组常用方法总结</div></div></a></div><div><a href="/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/" title="CSS面试记录"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-22</div><div class="title">CSS面试记录</div></div></a></div><div><a href="/2024/04/19/Javascript%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/" title="Javascript手写代码"><img class="cover" src="https://s2.loli.net/2022/12/31/HYB9fKZPknOqSLz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-19</div><div class="title">Javascript手写代码</div></div></a></div><div><a href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">React面试题</div></div></a></div><div><a href="/2023/02/13/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="TypeScript面试题"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-13</div><div class="title">TypeScript面试题</div></div></a></div><div><a href="/2023/01/19/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Vue面试题总结"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-19</div><div class="title">Vue面试题总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">流泪猫猫头</div><div class="author-info__description">THE TORTURED POETS DEPARTMENT</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lavender321"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lavender321" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:r1727439300@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E8%87%AA%E5%B7%B1"><span class="toc-number">1.</span> <span class="toc-text">介绍自己</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C"><span class="toc-number">1.1.</span> <span class="toc-text">完美世界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AI-Partner"><span class="toc-number">1.1.1.</span> <span class="toc-text">AI-Partner</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%B7%E6%AD%8C%E6%B3%A8%E5%86%8C-OAuth2-0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">谷歌注册-OAuth2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0-Google-%E7%99%BB%E5%BD%95%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">如何在前端实现 Google 登录的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8E%E7%AB%AF%E5%A4%84%E7%90%86-Google-%E7%99%BB%E5%BD%95%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text">如何在后端处理 Google 登录的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E5%92%8C%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text">用户体验和界面设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95-Google-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%9A%84%EF%BC%9F%E9%83%A8%E7%BD%B2%E6%97%B6%E8%80%83%E8%99%91%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.1.1.1.4.</span> <span class="toc-text">如何测试 Google 登录功能的？部署时考虑了哪些问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.1.1.1.5.</span> <span class="toc-text">这个过程如何保证数据的安全？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%AE%BE%E5%A4%87%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">如何判断设备是什么平台</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text">主题切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8A%E5%A4%A9%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E2%80%93%E5%9F%BA%E4%BA%8E%E5%8E%9F%E7%94%9Fcss%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A8%E7%94%BB%E8%BF%87%E7%A8%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">聊天页面跳转动画实现–基于原生css实现的动画过程-单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8setTimeout%EF%BC%9F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">为什么不使用setTimeout？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#requestAnimationFrame"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">requestAnimationFrame</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#setTimeout"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">setTimeout</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-SSE-%E5%92%8C-WebSocket-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">为什么需要使用 SSE 和 WebSocket 两种方法进行流式传输？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E9%9C%80%E6%B1%82%EF%BC%9A"><span class="toc-number">1.1.4.0.1.</span> <span class="toc-text">不同的应用场景需求：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.1.4.0.2.</span> <span class="toc-text">实现和维护的复杂度：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA%E7%BB%93%E5%90%88webSocket%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">流式输出结合webSocket心跳机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#webSocket%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">webSocket心跳机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSE%E5%92%8Cwebsocket%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.5.</span> <span class="toc-text">SSE和websocket的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%9A%E4%BF%A1%E6%96%B9%E5%90%91"><span class="toc-number">1.1.6.</span> <span class="toc-text">1. 通信方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%8F%E8%AE%AE%E5%B1%82%E9%9D%A2"><span class="toc-number">1.1.7.</span> <span class="toc-text">2. 协议层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%9E%E6%8E%A5%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.8.</span> <span class="toc-text">3. 连接特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.9.</span> <span class="toc-text">4. 性能与复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81"><span class="toc-number">1.1.10.</span> <span class="toc-text">5. 浏览器支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.11.</span> <span class="toc-text">6. 使用场景总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.1.12.</span> <span class="toc-text">7. 连接数量的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B5%8F%E8%A7%88%E5%99%A8-API"><span class="toc-number">1.1.13.</span> <span class="toc-text">8. 浏览器 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">1.1.14.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85"><span class="toc-number">1.1.15.</span> <span class="toc-text">网络请求封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%8B%E7%82%B9-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.16.</span> <span class="toc-text">埋点-日志记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.17.</span> <span class="toc-text">项目的性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD%EF%BC%9F"><span class="toc-number">1.1.17.1.</span> <span class="toc-text">预加载图片资源时有哪些性能优化措施？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%9B%BE%E7%89%87%E9%9D%9E%E5%B8%B8%E5%A4%9A%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-number">1.1.17.2.</span> <span class="toc-text">如果预加载的图片非常多，可能会产生什么性能问题？如何改进？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%92%8C%E5%A4%84%E7%90%86%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E5%92%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="toc-number">1.1.17.3.</span> <span class="toc-text">如何检测和处理预加载失败的图片？有什么方法可以确保加载的图片质量和加载的可靠性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%B7%B2%E7%BB%8F%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%9B%BE%E7%89%87%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%8F%AF%E4%BB%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">1.1.17.4.</span> <span class="toc-text">你如何判断已经加载的图片是否需要重新加载？可以如何进一步避免重复加载？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%9B%B4%E5%BE%80%E4%B8%8B%E6%BB%91%E5%88%B0%E5%BA%95%E9%83%A8%EF%BC%8C%E5%9B%BE%E7%89%87%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">1.1.17.5.</span> <span class="toc-text">一直往下滑到底部，图片会不会加载？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%EF%BC%88Virtual-Scrolling%EF%BC%89"><span class="toc-number">1.1.17.5.1.</span> <span class="toc-text">虚拟列表（Virtual Scrolling）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E9%9C%80%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.17.5.2.</span> <span class="toc-text">按需数据加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-number">1.1.17.5.3.</span> <span class="toc-text">图片懒加载与资源回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96"><span class="toc-number">1.1.17.5.4.</span> <span class="toc-text">节流与防抖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E9%94%80%E6%AF%81%E6%9C%80%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%9F"><span class="toc-number">1.1.17.5.5.</span> <span class="toc-text">是否需要销毁最开始的图片？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E7%90%86%E7%9A%84%E5%9B%BE%E7%89%87%E9%94%80%E6%AF%81%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">1.1.17.6.</span> <span class="toc-text">合理的图片销毁策略：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.17.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEAD%E5%8F%96%E4%BB%A3Get%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.17.8.</span> <span class="toc-text">HEAD取代Get方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%81%9A%E5%90%88%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.2.</span> <span class="toc-text">完美聚合平台</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B5%81%E5%BC%8F%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">如何处理流式请求？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fetchEventSource%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">fetchEventSource配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E5%BC%8F"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">处理流式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%9A%84%E6%B5%81%E5%BC%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">关键的流式稳定性优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">优化建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">取消请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Martix%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BC%80%E5%8F%91"><span class="toc-number">1.3.</span> <span class="toc-text">Martix一站式开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E2%80%93qiankun"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">微前端–qiankun</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">性能优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">轻任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">如何实现数据同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E5%88%87%E6%8D%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">如何实现视图切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%8D%E6%9D%82%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.3.</span> <span class="toc-text">实现复杂的查询功能，如何处理性能问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%9A%E7%94%A8%E6%88%B7%E7%9A%84%E5%AE%9E%E6%97%B6%E5%8D%8F%E5%90%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.4.4.</span> <span class="toc-text">如何多用户的实时协同时的数据一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E9%9A%90%E7%A7%81%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.4.5.</span> <span class="toc-text">如何保证数据的安全性和隐私性的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%E2%80%93%E6%8C%91%E6%88%98"><span class="toc-number">1.4.6.</span> <span class="toc-text">遇到最大的问题–挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.7.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%9A%84%E6%B5%81%E5%BC%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96-1"><span class="toc-number">1.4.8.</span> <span class="toc-text">关键的流式稳定性优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Martix%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0"><span class="toc-number">2.</span> <span class="toc-text">Martix项目管理平台</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF"><span class="toc-number">2.1.</span> <span class="toc-text">微前端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#qiankun%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%9C%A8%E5%AD%90%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">qiankun生命周期，在子应用中使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bootstrap%E3%80%81mount%E3%80%81unmount%E3%80%81update"><span class="toc-number">2.1.2.</span> <span class="toc-text">bootstrap、mount、unmount、update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">实现注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%89%B4%E6%9D%83"><span class="toc-number">2.2.</span> <span class="toc-text">路由鉴权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%80%BB%E8%BE%91"><span class="toc-number">2.2.2.</span> <span class="toc-text">函数逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.3.</span> <span class="toc-text">示例使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.2.4.</span> <span class="toc-text">代码改进建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-09%E5%8C%97%E4%BA%AC%E6%B5%B7%E8%87%B4%E7%A7%91%E6%8A%80%E9%9B%86%E5%9B%A2"><span class="toc-number">3.</span> <span class="toc-text">04-09北京海致科技集团</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">遍历数据方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.1.1.</span> <span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-of%EF%BC%9AES6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E4%BC%9A%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%B8%8D%E8%83%BD%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E6%95%B0%E7%BB%84%EF%BC%8C%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.1.2.</span> <span class="toc-text">for of：ES6中的方法，不会遍历数组的私有属性，不能遍历对象，可以遍历字符串，数组，有返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E4%B9%9F%E4%BC%9A%E9%81%8D%E5%8E%86%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%80%E8%88%AC%E7%94%A8%E6%9D%A5%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.3.</span> <span class="toc-text">for in：数组的私有属性也会遍历，所以一般用来遍历对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foreach%EF%BC%9AforEach-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%BB%99%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E3%80%82"><span class="toc-number">3.2.</span> <span class="toc-text">foreach：forEach() 方法对数组的每个元素执行一次给定的函数。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E5%88%86%E5%88%AB%E8%AF%B4%E4%BA%94%E4%B8%AA"><span class="toc-number">3.2.1.</span> <span class="toc-text">遍历对象的方法和遍历数组的方法分别说五个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-for-in-%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.2.2.</span> <span class="toc-text">1. for...in 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Object-keys-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">2. Object.keys() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Object-values-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.4.</span> <span class="toc-text">3. Object.values() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Object-entries-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">4. Object.entries() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Object-getOwnPropertyNames-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.6.</span> <span class="toc-text">5. Object.getOwnPropertyNames() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8-for-of-%E5%BE%AA%E7%8E%AF%EF%BC%88%E9%85%8D%E5%90%88-Object-entries-%EF%BC%89"><span class="toc-number">3.2.7.</span> <span class="toc-text">6. 使用 for...of 循环（配合 Object.entries()）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Reflect-ownKeys-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.8.</span> <span class="toc-text">7. Reflect.ownKeys() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E9%80%89%E6%8B%A9"><span class="toc-number">3.2.9.</span> <span class="toc-text">使用场景选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%EF%BC%9A"><span class="toc-number">3.2.10.</span> <span class="toc-text">遍历数组的方法有：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-11-%E6%BB%B4%E6%BB%B4%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0"><span class="toc-number">4.</span> <span class="toc-text">04-11-滴滴日常实习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.1.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qiankun%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">4.2.</span> <span class="toc-text">qiankun机制是怎样的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B3%A8%E5%86%8C"><span class="toc-number">4.2.1.</span> <span class="toc-text">初始化和注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text">沙箱机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.3.</span> <span class="toc-text">生命周期管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1"><span class="toc-number">4.2.4.</span> <span class="toc-text">通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-1"><span class="toc-number">4.2.5.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nextjs%E5%81%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">4.3.</span> <span class="toc-text">nextjs做服务端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88SSR%EF%BC%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.1.</span> <span class="toc-text">服务端渲染（SSR）的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Next-js%E4%B8%AD%E4%BD%BF%E7%94%A8SSR"><span class="toc-number">4.3.2.</span> <span class="toc-text">如何在Next.js中使用SSR</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BB%84%E4%BB%B6"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">页面组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">数据获取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">4.3.3.</span> <span class="toc-text">优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E9%A2%98%E8%BE%93%E5%87%BA%E2%80%93this"><span class="toc-number">4.4.</span> <span class="toc-text">看题输出–this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.5.</span> <span class="toc-text">宏任务和微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">Promise的常用方法有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-all-iterable"><span class="toc-number">4.6.1.</span> <span class="toc-text">Promise.all(iterable)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-allSettled-iterable"><span class="toc-number">4.6.2.</span> <span class="toc-text">Promise.allSettled(iterable)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-race-iterable"><span class="toc-number">4.6.3.</span> <span class="toc-text">Promise.race(iterable)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-resolve-valve"><span class="toc-number">4.6.4.</span> <span class="toc-text">Promise.resolve(valve)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-reject-reason"><span class="toc-number">4.6.5.</span> <span class="toc-text">Promise.reject(reason)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-prototype-then-onFulfilled-onRejected"><span class="toc-number">4.6.6.</span> <span class="toc-text">Promise.prototype.then(onFulfilled,onRejected)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-prototype-catch-onRejected"><span class="toc-number">4.6.7.</span> <span class="toc-text">Promise.prototype.catch(onRejected)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-prototype-finally-onFinally"><span class="toc-number">4.6.8.</span> <span class="toc-text">Promise.prototype.finally(onFinally)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commonjs%E5%92%8CES-Module"><span class="toc-number">4.7.</span> <span class="toc-text">Commonjs和ES Module</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-11%E8%B6%A3%E9%93%BE%E7%A7%91%E6%8A%80"><span class="toc-number">5.</span> <span class="toc-text">04-11趣链科技</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE"><span class="toc-number">5.1.</span> <span class="toc-text">介绍实习项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E5%BE%AE%E5%89%8D%E7%AB%AF"><span class="toc-number">5.2.</span> <span class="toc-text">介绍微前端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#qiankun-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">qiankun 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%BA%94%E7%94%A8%E5%92%8C%E5%AD%90%E5%BA%94%E7%94%A8%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">主应用和子应用通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Qiankun-%E5%AD%90%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.3.</span> <span class="toc-text">Qiankun 子应用的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.4.</span> <span class="toc-text">生命周期的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.2.5.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS%E7%9A%84%E5%8A%A8%E7%94%BB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9A%E6%AF%94%E5%A6%82transition"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">CSS的动画了解吗：比如transition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">事件循环机制：宏任务和微任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8Ccookie%EF%BC%8Clocalstorage%EF%BC%8Csessionstorage"><span class="toc-number">5.2.5.3.</span> <span class="toc-text">浏览器的存储，cookie，localstorage，sessionstorage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BWebsocket"><span class="toc-number">5.2.5.4.</span> <span class="toc-text">说一下Websocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%8C%E9%97%AD%E5%8C%85"><span class="toc-number">5.2.5.5.</span> <span class="toc-text">节流和防抖的使用场景，闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%9Acache-control-Expires-%EF%BC%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%9AE-Tag%EF%BC%8CLast-Modified"><span class="toc-number">5.2.5.6.</span> <span class="toc-text">强缓存和协商缓存：cache-control+Expires ，协商缓存：E-Tag，Last-Modified</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise%E5%92%8C%E4%B8%80%E4%BA%9B%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88promise-all%EF%BC%8Cpromise%EF%BC%8Crace%E7%AD%89%EF%BC%89"><span class="toc-number">5.2.5.7.</span> <span class="toc-text">Promise和一些静态方法（promise.all，promise，race等）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">Promise的静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.4.</span> <span class="toc-text">Vue2的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">5.5.</span> <span class="toc-text">组件通信的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%89%B4%E6%9D%83-1"><span class="toc-number">5.6.</span> <span class="toc-text">路由鉴权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">5.7.</span> <span class="toc-text">微前端生命周期钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dom%E8%8A%82%E7%82%B9%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.8.</span> <span class="toc-text">dom节点事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5%EF%BC%88Capturing-Phase%EF%BC%89"><span class="toc-number">5.8.1.</span> <span class="toc-text">1. 捕获阶段（Capturing Phase）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%9B%AE%E6%A0%87%E9%98%B6%E6%AE%B5%EF%BC%88Target-Phase%EF%BC%89"><span class="toc-number">5.8.2.</span> <span class="toc-text">2. 目标阶段（Target Phase）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%EF%BC%88Bubbling-Phase%EF%BC%89"><span class="toc-number">5.8.3.</span> <span class="toc-text">3. 冒泡阶段（Bubbling Phase）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">5.8.4.</span> <span class="toc-text">使用事件流的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-number">5.8.5.</span> <span class="toc-text">设置事件监听的阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-2-%E5%92%8C-Vue-3-%E5%9C%A8%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD%E4%B8%8A%E6%9C%89%E8%AE%B8%E5%A4%9A%E9%87%8D%E8%A6%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%8C%BA%E5%88%AB%E6%97%A8%E5%9C%A8%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E5%A2%9E%E5%8A%A0%E7%81%B5%E6%B4%BB%E6%80%A7%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C%E3%80%82%E4%B8%8B%E9%9D%A2%E6%98%AF-Vue-2-%E5%92%8C-Vue-3-%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">5.9.</span> <span class="toc-text">Vue 2 和 Vue 3 在设计和功能上有许多重要的区别，这些区别旨在提高性能、增加灵活性，以及改进开发体验。下面是 Vue 2 和 Vue 3 之间的一些主要区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-number">5.9.1.</span> <span class="toc-text">1. 性能提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Composition-API"><span class="toc-number">5.9.2.</span> <span class="toc-text">2. Composition API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9B%B4%E5%A5%BD%E7%9A%84-TypeScript-%E6%94%AF%E6%8C%81"><span class="toc-number">5.9.3.</span> <span class="toc-text">3. 更好的 TypeScript 支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Fragment%E3%80%81Teleport-%E5%92%8C-Suspense"><span class="toc-number">5.9.4.</span> <span class="toc-text">4. Fragment、Teleport 和 Suspense</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">5.9.5.</span> <span class="toc-text">5. 响应式系统的重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9B%B4%E8%BD%BB%E9%87%8F%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">5.9.6.</span> <span class="toc-text">6. 更轻量和模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%92%8C%E5%85%A8%E5%B1%80-API-%E6%9B%B4%E6%94%B9"><span class="toc-number">5.9.7.</span> <span class="toc-text">7. 新的组件挂载方式和全局 API 更改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="toc-number">5.10.</span> <span class="toc-text">代码输出：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vite-%E5%92%8C-webpack-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.11.</span> <span class="toc-text">Vite 和 webpack 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vite"><span class="toc-number">5.11.1.</span> <span class="toc-text">Vite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack"><span class="toc-number">5.11.2.</span> <span class="toc-text">Webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">5.11.3.</span> <span class="toc-text">主要区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2-%E5%8D%87%E7%BA%A7-Vue3-%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="toc-number">5.12.</span> <span class="toc-text">Vue2 升级 Vue3 需要注意什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">5.13.</span> <span class="toc-text">数组去重有哪些方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-Set-%E5%92%8C%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.13.1.</span> <span class="toc-text">1. 使用 Set 和展开运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-Set-%E5%92%8C-Array-from"><span class="toc-number">5.13.2.</span> <span class="toc-text">2. 使用 Set 和 Array.from()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-filter-%E6%96%B9%E6%B3%95"><span class="toc-number">5.13.3.</span> <span class="toc-text">3. 使用 filter 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-reduce-%E6%96%B9%E6%B3%95"><span class="toc-number">5.13.4.</span> <span class="toc-text">4. 使用 reduce 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8-Map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.13.5.</span> <span class="toc-text">5. 使用 Map 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BE%AA%E7%8E%AF%E6%AF%94%E8%BE%83%EF%BC%88%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">5.13.6.</span> <span class="toc-text">6. 循环比较（传统方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.13.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0412%E7%BD%91%E6%98%93"><span class="toc-number">6.</span> <span class="toc-text">0412网易</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE%EF%BC%8C%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%80%82%E9%85%8D%E4%B8%8D%E6%98%AF%E5%9F%BA%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E9%80%82%E9%85%8D%EF%BC%8C%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E7%94%B5%E8%84%91"><span class="toc-number">6.1.</span> <span class="toc-text">介绍项目，项目的适配不是基于移动端的适配，针对不同的电脑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E7%BB%84%E6%88%90"><span class="toc-number">6.2.</span> <span class="toc-text">盒模型以及组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81-%E6%8D%95%E8%8E%B7%E3%80%81%E7%9B%AE%E6%A0%87%E3%80%81%E5%86%92%E6%B3%A1%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%891000%E4%B8%AA%E4%BA%8B%E4%BB%B6%E9%9C%80%E8%A6%81%E8%A7%A6%E5%8F%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E2%80%93%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E9%97%AE%E5%BE%97%E5%A4%9A"><span class="toc-number">6.3.</span> <span class="toc-text">事件流:捕获、目标、冒泡，如果有1000个事件需要触发，如何解决？–事件代理，原生事件问得多</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9Fflex-1%E2%80%93flex-grow-flex-basis-flex-shrink"><span class="toc-number">6.4.</span> <span class="toc-text">css如何布局？flex:1–flex-grow,flex-basis,flex-shrink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E7%9A%84%E5%8A%A8%E7%94%BB-transition-%E5%92%8Canimation"><span class="toc-number">6.5.</span> <span class="toc-text">css的动画,transition 和animation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E3%80%81vite%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">6.6.</span> <span class="toc-text">webpack、vite，代码中如何配置，举例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ts%E7%9A%84%E6%B3%9B%E5%9E%8B%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9E%9A%E4%B8%BE"><span class="toc-number">6.7.</span> <span class="toc-text">ts的泛型、接口、枚举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2"><span class="toc-number">7.</span> <span class="toc-text">美团</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E8%B7%A8%E5%9F%9F"><span class="toc-number">7.1.</span> <span class="toc-text">cookie如何设置跨域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0415DeepLang"><span class="toc-number">8.</span> <span class="toc-text">0415DeepLang</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#postmessage%E5%92%8Chttp%E9%80%9A%E4%BF%A1"><span class="toc-number">8.1.</span> <span class="toc-text">postmessage和http通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8Curl%EF%BC%8C"><span class="toc-number">8.2.</span> <span class="toc-text">浏览器原理，事件循环和url，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E5%88%9B%E5%BB%BA%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%91%E4%B8%8D%E6%83%B3%E4%BB%96%E8%A2%ABnew%E5%88%9B%E9%80%A0%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.3.</span> <span class="toc-text">ES6创建的函数我不想他被new创造新的实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9es6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.4.</span> <span class="toc-text">对es6的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">8.5.</span> <span class="toc-text">强缓存和协商缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B71%E4%BF%AE%E6%94%B9%E4%BA%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%94%A8%E6%88%B72%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E6%9F%A5%E7%9C%8B%EF%BC%8C%E4%BD%A0%E4%BB%AC%E6%98%AF%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%EF%BC%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%B8%8D%E8%AF%B7%E6%B1%82http%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0"><span class="toc-number">8.6.</span> <span class="toc-text">用户1修改了数据，用户2及时更新查看，你们是用的是什么方式？请求的数据如何不请求http的方式进行更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-WebSocket"><span class="toc-number">8.6.1.</span> <span class="toc-text">1. WebSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Server-Sent-Events-SSE"><span class="toc-number">8.6.2.</span> <span class="toc-text">2. Server-Sent Events (SSE)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E8%BD%AE%E8%AF%A2%E6%88%96%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-number">8.6.3.</span> <span class="toc-text">3. 使用轮询或长轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8Pub-x2F-Sub%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">8.6.4.</span> <span class="toc-text">4. 使用Pub&#x2F;Sub模型的服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">8.6.5.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAhooks"><span class="toc-number">8.7.</span> <span class="toc-text">封装一个hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%8B%E8%BD%BD%E9%9C%80%E8%A6%818s%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%92%8C%E5%BC%BA%E7%BC%93%E5%AD%98%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">现在我有一个文件，下载需要8s，如何使用协商缓存和强缓存进行优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98-Strong-Caching"><span class="toc-number">8.8.1.</span> <span class="toc-text">强缓存 (Strong Caching)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98-Negotiation-Caching"><span class="toc-number">8.8.2.</span> <span class="toc-text">协商缓存 (Negotiation Caching)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">8.8.3.</span> <span class="toc-text">选择适合的缓存策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%96%BD%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.8.4.</span> <span class="toc-text">实施示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E9%9D%A2"><span class="toc-number">9.</span> <span class="toc-text">二面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#useMemo%E5%92%8CuseEffect%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.</span> <span class="toc-text">useMemo和useEffect的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#useMemo"><span class="toc-number">9.1.1.</span> <span class="toc-text">useMemo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEffect"><span class="toc-number">9.1.2.</span> <span class="toc-text">useEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.3.</span> <span class="toc-text">执行时机的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E4%BC%A0%E5%80%BC-useRef"><span class="toc-number">9.2.</span> <span class="toc-text">父子传值:useRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E8%BF%9B%E8%A1%8C%E9%89%B4%E6%9D%83"><span class="toc-number">9.3.</span> <span class="toc-text">vue不仅仅是使用路由进行鉴权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise-all%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8E%A5%E5%8F%97%E5%88%B0rejected%E4%B9%9F%E6%88%90%E5%8A%9F%E8%BF%94%E5%9B%9E%EF%BC%9Fpromise-race"><span class="toc-number">9.4.</span> <span class="toc-text">promise.all如何在接受到rejected也成功返回？promise.race</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">9.5.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-const"><span class="toc-number">9.6.</span> <span class="toc-text">let const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">9.7.</span> <span class="toc-text">vuex全局状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">9.7.1.</span> <span class="toc-text">Vuex 的核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.7.2.</span> <span class="toc-text">Vuex 的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.7.3.</span> <span class="toc-text">Vuex 的使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="toc-number">9.7.4.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C-1"><span class="toc-number">10.</span> <span class="toc-text">完美世界</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bfiber"><span class="toc-number">10.1.</span> <span class="toc-text">介绍一下fiber</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.2.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hooks%E5%8F%AF%E4%BB%A5%E5%86%99%E5%9C%A8if%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E9%87%8C%E5%90%97"><span class="toc-number">10.3.</span> <span class="toc-text">hooks可以写在if判断语句里吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Hooks%E4%B8%8D%E8%83%BD%E6%94%BE%E5%9C%A8%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E4%B8%AD"><span class="toc-number">10.3.1.</span> <span class="toc-text">为什么Hooks不能放在条件语句中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.3.2.</span> <span class="toc-text">错误示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95"><span class="toc-number">10.3.3.</span> <span class="toc-text">正确用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-2"><span class="toc-number">10.3.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed%E4%B8%8Ewacth%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.4.</span> <span class="toc-text">computed与wacth有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6"><span class="toc-number">10.5.</span> <span class="toc-text">ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">10.6.</span> <span class="toc-text">原型和原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E7%9A%84%E8%BF%87%E7%A8%8B%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="toc-number">10.7.</span> <span class="toc-text">new的过程都干了些什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-1"><span class="toc-number">10.8.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.9.</span> <span class="toc-text">箭头函数和普通函数有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%AE%BEvue%E7%BB%84%E4%BB%B6%E9%87%8C%E4%B8%80%E4%B8%AAref%E7%9A%84%E5%8F%98%E9%87%8F-%E7%84%B6%E5%90%8E%E5%86%8D%E9%87%8C%E6%B8%B2%E6%9F%93%E4%BA%86%E5%AE%83-%E7%84%B6%E5%90%8E%E5%8E%BB%E4%BF%AE%E6%94%B9%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F-%E9%82%A3%E9%A1%B5%E9%9D%A2%E4%B8%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BF%AE%E6%94%B9%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">10.10.</span> <span class="toc-text">假设vue组件里一个ref的变量  然后再里渲染了它  然后去修改这个变量  那页面上为什么会修改这个变量呢？ 介绍一下这个具体的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%8D%E9%97%AE%E4%BA%86%E8%A7%A3v8%E5%90%97%EF%BC%8C%E6%96%B0%E7%94%9F%E4%BB%A3%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E5%9D%97%E5%8C%BA%E5%9F%9F%EF%BC%8C%E8%BF%99%E5%87%A0%E5%9D%97%E5%84%BF%E5%8C%BA%E5%9F%9F%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E8%BF%99%E4%B8%A4%E5%9D%97%E5%84%BF%E5%8C%BA%E5%9F%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BA%92%E6%8D%A2%E5%91%A2%EF%BC%9F%E4%BA%92%E6%8D%A2%E4%BA%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%90%97%EF%BC%9F%EF%BC%89"><span class="toc-number">10.11.</span> <span class="toc-text">垃圾回收（面试官反问了解v8吗，新生代分为哪几块区域，这几块儿区域是用来干什么的？这两块儿区域什么时候互换呢？互换了有什么好处吗？）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">10.11.1.</span> <span class="toc-text">垃圾回收的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">10.11.2.</span> <span class="toc-text">V8 引擎的垃圾回收机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">10.12.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ts%EF%BC%9Ainterface%E3%80%81type%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8"><span class="toc-number">10.13.</span> <span class="toc-text">ts：interface、type分别是什么时候使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%BA%E5%88%AB"><span class="toc-number">10.13.1.</span> <span class="toc-text">1. 基本区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.13.2.</span> <span class="toc-text">2. 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B%E6%AF%94%E8%BE%83"><span class="toc-number">10.13.3.</span> <span class="toc-text">3. 实例比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">10.13.4.</span> <span class="toc-text">4. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">10.14.</span> <span class="toc-text">枚举类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8F%AA%E7%94%A8%E8%BF%87webpack%E5%90%97%EF%BC%9F%E6%9C%89%E7%94%A8%E8%BF%87%E5%85%B6%E4%BB%96%E7%9A%84%E5%90%97%EF%BC%9FVite%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E6%94%B9%E8%BF%87%E5%AE%83%E4%BB%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE"><span class="toc-number">10.15.</span> <span class="toc-text">构建工具只用过webpack吗？有用过其他的吗？Vite的优势在哪？有没有改过它们的一些配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E9%87%8C%E7%9A%84Loader%E4%B8%8EPlugin%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.16.</span> <span class="toc-text">webpack里的Loader与Plugin有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader"><span class="toc-number">10.16.1.</span> <span class="toc-text">Loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Plugin"><span class="toc-number">10.16.2.</span> <span class="toc-text">Plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">10.16.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">10.17.</span> <span class="toc-text">TCP连接三次握手流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">10.18.</span> <span class="toc-text">项目里的图片压缩是怎么做的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%80%9D%E8%B7%AF"><span class="toc-number">10.19.</span> <span class="toc-text">删除一个单向链表的倒数第n个节点，讲一下思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89a%E5%92%8Cb%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F-%E6%83%B3%E6%8A%8Aa%E5%92%8Cb%E4%BA%A4%E6%8D%A2-%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%E5%92%8Ces6%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%8C%E8%AF%B7%E4%BD%A0%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%80%9D%E8%B7%AF"><span class="toc-number">10.20.</span> <span class="toc-text">有a和b两个变量,想把a和b交换,不能用中间变量和es6的解构赋值，请你讲一下思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%9F-%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5%E7%9A%84%E8%AF%9D-%E6%9C%80%E5%BF%AB%E4%BB%80%E4%B9%88%E6%97%B6%E9%97%B4%E5%88%B0%E5%B2%97-%E8%83%BD%E5%AE%9E%E4%B9%A0%E5%88%B0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99"><span class="toc-number">10.21.</span> <span class="toc-text">一般通过什么方式学前端？  如果可以的话  最快什么时间到岗  能实习到什么时候</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8websocket"><span class="toc-number">10.22.</span> <span class="toc-text">使用websocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC"><span class="toc-number">10.23.</span> <span class="toc-text">BFC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%8F%8F%E8%BF%B0"><span class="toc-number">10.23.0.1.</span> <span class="toc-text">技术描述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82"><span class="toc-number">10.23.1.</span> <span class="toc-text">技术细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#postmessage"><span class="toc-number">10.24.</span> <span class="toc-text">postmessage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%92%8C%E7%94%A8%E9%80%94"><span class="toc-number">10.24.1.</span> <span class="toc-text">功能和用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.24.2.</span> <span class="toc-text">使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">10.24.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Workers-%E5%92%8C-WebSocket-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">10.25.</span> <span class="toc-text">Web Workers 和 WebSocket 的主要区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-Workers"><span class="toc-number">10.25.1.</span> <span class="toc-text">Web Workers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-number">10.25.2.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">10.25.3.</span> <span class="toc-text">相关性与区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">10.26.</span> <span class="toc-text">跨域的解决办法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%92%8C-Web-Storage%E3%80%82"><span class="toc-number">10.27.</span> <span class="toc-text">前端缓存可以分为两种类型：浏览器缓存和 Web Storage。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JWT"><span class="toc-number">10.28.</span> <span class="toc-text">JWT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">10.28.1.</span> <span class="toc-text">JWT 的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">10.28.2.</span> <span class="toc-text">JWT 的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">10.28.3.</span> <span class="toc-text">JWT 的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">10.28.4.</span> <span class="toc-text">JWT 的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%B1%B3"><span class="toc-number">11.</span> <span class="toc-text">小米</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML5-CSS"><span class="toc-number">12.</span> <span class="toc-text">HTML5+CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Workers-1"><span class="toc-number">12.1.</span> <span class="toc-text">Web Workers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">12.1.0.1.</span> <span class="toc-text">特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket-1"><span class="toc-number">12.2.</span> <span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">12.2.0.1.</span> <span class="toc-text">特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML5-%E5%92%8C%E7%8E%B0%E4%BB%A3%E5%BA%94%E7%94%A8"><span class="toc-number">12.3.</span> <span class="toc-text">HTML5 和现代应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.4.</span> <span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80"><span class="toc-number">12.5.</span> <span class="toc-text">左右布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80"><span class="toc-number">12.6.</span> <span class="toc-text">水平垂直居中布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Flex%E5%B8%83%E5%B1%80"><span class="toc-number">12.6.1.</span> <span class="toc-text">使用Flex布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%92%8Ctransform%E5%B1%9E%E6%80%A7"><span class="toc-number">12.6.2.</span> <span class="toc-text">使用绝对定位和transform属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80"><span class="toc-number">12.6.3.</span> <span class="toc-text">使用表格布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Flex%E5%B8%83%E5%B1%80%E7%9A%84margin-auto%E6%96%B9%E6%B3%95"><span class="toc-number">12.6.4.</span> <span class="toc-text">使用Flex布局的margin:auto方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flex%EF%BC%9A1%E6%98%AF%E4%BB%80%E4%B9%88%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BC%A9%E5%86%99%EF%BC%9F"><span class="toc-number">12.7.</span> <span class="toc-text">flex：1是什么属性的缩写？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D"><span class="toc-number">12.8.</span> <span class="toc-text">移动端适配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%EF%BC%9Atransition%E3%80%81animation"><span class="toc-number">12.9.</span> <span class="toc-text">动画：transition、animation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-Transitions"><span class="toc-number">12.9.1.</span> <span class="toc-text">CSS Transitions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">12.9.1.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">12.9.1.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.9.1.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CSS-Animations"><span class="toc-number">12.9.2.</span> <span class="toc-text">2. CSS Animations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">12.9.2.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">12.9.2.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">12.9.2.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">12.9.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Javascript"><span class="toc-number">13.</span> <span class="toc-text">Javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">13.1.</span> <span class="toc-text">事件代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-2"><span class="toc-number">13.2.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%AD%98"><span class="toc-number">13.3.</span> <span class="toc-text">浏览器内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Cookies"><span class="toc-number">13.3.1.</span> <span class="toc-text">1. Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-LocalStorage"><span class="toc-number">13.3.2.</span> <span class="toc-text">2. LocalStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SessionStorage"><span class="toc-number">13.3.3.</span> <span class="toc-text">3. SessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-number">13.3.4.</span> <span class="toc-text">比较与选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">13.4.</span> <span class="toc-text">ES6的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%A4%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">13.5.</span> <span class="toc-text">数据类型和判断方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%8Cmap%E3%80%81set%EF%BC%8C%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C"><span class="toc-number">13.6.</span> <span class="toc-text">箭头函数，map、set，块级作用域，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">13.7.</span> <span class="toc-text">数据遍历的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">13.7.1.</span> <span class="toc-text">基本类型的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86"><span class="toc-number">13.7.1.1.</span> <span class="toc-text">字符串遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86"><span class="toc-number">13.7.2.</span> <span class="toc-text">对象遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-for-in-%E5%BE%AA%E7%8E%AF-1"><span class="toc-number">13.7.2.1.</span> <span class="toc-text">1. for...in 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Object-keys-Object-values-Object-entries"><span class="toc-number">13.7.2.2.</span> <span class="toc-text">2. Object.keys(), Object.values(), Object.entries()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-for-of-%E5%BE%AA%E7%8E%AF%E4%B8%8E-Object-entries"><span class="toc-number">13.7.2.3.</span> <span class="toc-text">3. for...of 循环与 Object.entries()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">13.7.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">13.8.</span> <span class="toc-text">new的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.8.1.</span> <span class="toc-text">1. 创建一个新对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">13.8.2.</span> <span class="toc-text">2. 设置原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%91%E5%AE%9A-this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">13.8.3.</span> <span class="toc-text">3. 绑定 this 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%89%A7%E8%A1%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">13.8.4.</span> <span class="toc-text">4. 执行构造函数的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BF%94%E5%9B%9E%E6%96%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.8.5.</span> <span class="toc-text">5. 返回新对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-3"><span class="toc-number">13.8.6.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">13.9.</span> <span class="toc-text">promise的理解和静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Promise"><span class="toc-number">13.9.1.</span> <span class="toc-text">使用 Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">13.9.2.</span> <span class="toc-text">Promise 的静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-4"><span class="toc-number">13.9.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">13.10.</span> <span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">13.11.</span> <span class="toc-text">垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Typescript"><span class="toc-number">14.</span> <span class="toc-text">Typescript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E7%82%B9"><span class="toc-number">14.0.1.</span> <span class="toc-text">相似点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">14.0.2.</span> <span class="toc-text">不同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA%EF%BC%9F"><span class="toc-number">14.0.3.</span> <span class="toc-text">选择使用哪一个？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%B3%9B%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%BA%A6%E6%9D%9F%EF%BC%9A"><span class="toc-number">14.1.</span> <span class="toc-text">对泛型属性约束：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-number">15.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%92%8C3%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8C%BA%E5%88%AB%E7%90%86%E8%A7%A3"><span class="toc-number">15.1.</span> <span class="toc-text">2和3双向数据绑定的区别理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">15.2.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch%E5%92%8Ccomputed"><span class="toc-number">15.3.</span> <span class="toc-text">watch和computed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E3%80%81v-show"><span class="toc-number">15.4.</span> <span class="toc-text">v-if、v-show</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">15.5.</span> <span class="toc-text">组件通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex"><span class="toc-number">15.6.</span> <span class="toc-text">vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-State"><span class="toc-number">15.6.1.</span> <span class="toc-text">1. State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Getters"><span class="toc-number">15.6.2.</span> <span class="toc-text">2. Getters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Mutations"><span class="toc-number">15.6.3.</span> <span class="toc-text">3. Mutations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Actions"><span class="toc-number">15.6.4.</span> <span class="toc-text">4. Actions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Modules"><span class="toc-number">15.6.5.</span> <span class="toc-text">5. Modules</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">15.7.</span> <span class="toc-text">路由</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React"><span class="toc-number">16.</span> <span class="toc-text">React</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Webpack-1"><span class="toc-number">17.</span> <span class="toc-text">Webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#loader%E5%92%8Cplugin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.1.</span> <span class="toc-text">loader和plugin的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader-1"><span class="toc-number">17.1.1.</span> <span class="toc-text">Loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Plugin-1"><span class="toc-number">17.1.2.</span> <span class="toc-text">Plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">17.1.3.</span> <span class="toc-text">区别总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vite%E5%92%8Cwebpack%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.2.</span> <span class="toc-text">Vite和webpack的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack-2"><span class="toc-number">17.2.1.</span> <span class="toc-text">Webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vite-1"><span class="toc-number">17.2.2.</span> <span class="toc-text">Vite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parcel"><span class="toc-number">17.2.3.</span> <span class="toc-text">Parcel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rollup"><span class="toc-number">17.2.4.</span> <span class="toc-text">Rollup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">17.2.5.</span> <span class="toc-text">改动配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-5"><span class="toc-number">17.2.6.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E2%80%93%E5%88%86%E9%85%8D%E3%80%81%E4%BD%BF%E7%94%A8%E3%80%81%E5%9B%9E%E6%94%B6-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E3%80%81%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E2%80%93%E6%A0%87%E8%AE%B0%E6%B8%85%E6%A5%9A%E3%80%81%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E3%80%81%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0"><span class="toc-number">18.</span> <span class="toc-text">内存–分配、使用、回收-引用计数、标记清除–标记清楚、标记整理、增量标记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%EF%BC%88%E7%A1%AC%E4%BB%B6%EF%BC%89"><span class="toc-number">18.0.1.</span> <span class="toc-text">物理内存（硬件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">18.0.2.</span> <span class="toc-text">操作系统的内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">18.0.3.</span> <span class="toc-text">浏览器的内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">18.0.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">18.0.5.</span> <span class="toc-text">虚拟内存的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">18.0.6.</span> <span class="toc-text">虚拟内存的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">18.0.7.</span> <span class="toc-text">虚拟内存的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">18.0.8.</span> <span class="toc-text">多进程架构的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">18.0.9.</span> <span class="toc-text">多进程架构的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%AE%9E%E9%99%85%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.0.10.</span> <span class="toc-text">浏览器的实际实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">18.0.11.</span> <span class="toc-text">1. 浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-number">18.0.11.1.</span> <span class="toc-text">强缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">18.0.11.2.</span> <span class="toc-text">协商缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">18.0.12.</span> <span class="toc-text">3. JavaScript内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-1"><span class="toc-number">18.0.12.1.</span> <span class="toc-text">垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-V8%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">18.0.13.</span> <span class="toc-text">4. V8引擎的垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-6"><span class="toc-number">18.0.14.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E8%AF%86%E5%88%AB%E4%B8%8E%E9%A2%84%E9%98%B2"><span class="toc-number">18.0.15.</span> <span class="toc-text">5. 内存泄漏的识别与预防</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Web-Workers%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">18.0.16.</span> <span class="toc-text">6. Web Workers的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="toc-number">18.0.17.</span> <span class="toc-text">7. 内存性能监控工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-7"><span class="toc-number">18.0.18.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E7%BA%BF%E6%95%B0%E6%8D%AE-Timeline-Data"><span class="toc-number">18.0.19.</span> <span class="toc-text">1. 时间线数据 (Timeline Data)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E5%BF%AB%E7%85%A7-Heap-Snapshot-%E2%80%93%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84memory"><span class="toc-number">18.0.20.</span> <span class="toc-text">2. 堆快照 (Heap Snapshot)–控制台的memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%A7%E8%83%BD%E8%AE%B0%E5%BD%95-Performance-Record"><span class="toc-number">18.0.21.</span> <span class="toc-text">3. 性能记录 (Performance Record)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-Network-Requests"><span class="toc-number">18.0.22.</span> <span class="toc-text">4. 网络请求 (Network Requests)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8A%A5%E5%91%8A"><span class="toc-number">18.0.23.</span> <span class="toc-text">示例：性能监控报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-8"><span class="toc-number">18.0.24.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA"><span class="toc-number">19.</span> <span class="toc-text">微前端路由拦截</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%AF%E7%94%B1API"><span class="toc-number">19.0.1.</span> <span class="toc-text">拦截的浏览器路由API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA"><span class="toc-number">19.0.2.</span> <span class="toc-text">如何进行路由拦截</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-9"><span class="toc-number">19.0.3.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-20-%E9%98%B3%E5%85%89%E8%83%BD%E6%BA%90"><span class="toc-number">20.</span> <span class="toc-text">9-20-阳光能源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%95%86%E6%B1%A4%E7%A7%91%E6%8A%80"><span class="toc-number">21.</span> <span class="toc-text">商汤科技</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%B1%B3-1"><span class="toc-number">22.</span> <span class="toc-text">小米</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%97%E7%89%A9"><span class="toc-number">23.</span> <span class="toc-text">得物</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Etag%E7%94%9F%E6%88%90%E7%9A%84%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">23.1.</span> <span class="toc-text">Etag生成的策略？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">23.1.1.</span> <span class="toc-text">1. 基于文件内容的哈希值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">23.1.2.</span> <span class="toc-text">2. 基于资源的版本号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4"><span class="toc-number">23.1.3.</span> <span class="toc-text">3. 基于文件的最后修改时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BC%BAEtag%E4%B8%8E%E5%BC%B1Etag"><span class="toc-number">23.1.4.</span> <span class="toc-text">4. 强Etag与弱Etag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">23.1.5.</span> <span class="toc-text">5. 基于资源大小和最后修改时间的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5"><span class="toc-number">23.1.6.</span> <span class="toc-text">6. 自定义生成策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">23.1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/%E9%93%B6%E8%A1%8C/" title="银行"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="银行"/></a><div class="content"><a class="title" href="/2024/10/22/%E9%93%B6%E8%A1%8C/" title="银行">银行</a><time datetime="2024-10-22T02:15:44.000Z" title="发表于 2024-10-22 10:15:44">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/16/nodejs%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="nodejs面试笔记"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nodejs面试笔记"/></a><div class="content"><a class="title" href="/2024/10/16/nodejs%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="nodejs面试笔记">nodejs面试笔记</a><time datetime="2024-10-16T02:23:20.000Z" title="发表于 2024-10-16 10:23:20">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/16/%E5%B0%8F%E7%B1%B3/" title="小米"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小米"/></a><div class="content"><a class="title" href="/2024/10/16/%E5%B0%8F%E7%B1%B3/" title="小米">小米</a><time datetime="2024-10-16T02:12:12.000Z" title="发表于 2024-10-16 10:12:12">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/" title="华为前端面试合集"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="华为前端面试合集"/></a><div class="content"><a class="title" href="/2024/10/15/%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/" title="华为前端面试合集">华为前端面试合集</a><time datetime="2024-10-15T08:35:34.000Z" title="发表于 2024-10-15 16:35:34">2024-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/14/%E6%95%B0%E5%AD%97/" title="数字"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数字"/></a><div class="content"><a class="title" href="/2024/10/14/%E6%95%B0%E5%AD%97/" title="数字">数字</a><time datetime="2024-10-14T08:44:56.000Z" title="发表于 2024-10-14 16:44:56">2024-10-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 流泪猫猫头</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>