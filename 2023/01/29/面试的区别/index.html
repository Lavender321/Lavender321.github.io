<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>面试的区别 | Lavender's blog</title><meta name="author" content="流泪猫猫头"><meta name="copyright" content="流泪猫猫头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="箭头函数和普通函数的区别a. 箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是&#x3D;&gt;定义函数,普通函数是function定义函数。   b. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了。   c. 箭头函数不能作为构造函数使用，也不能使用new关键字(因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的">
<meta property="og:type" content="article">
<meta property="og:title" content="面试的区别">
<meta property="og:url" content="http://lavender321.github.com/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/index.html">
<meta property="og:site_name" content="Lavender&#39;s blog">
<meta property="og:description" content="箭头函数和普通函数的区别a. 箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是&#x3D;&gt;定义函数,普通函数是function定义函数。   b. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了。   c. 箭头函数不能作为构造函数使用，也不能使用new关键字(因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg">
<meta property="article:published_time" content="2023-01-29T03:14:58.000Z">
<meta property="article:modified_time" content="2024-09-15T14:02:22.653Z">
<meta property="article:author" content="流泪猫猫头">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2022/10/08/k5M7H1NdmnZgtlY.png"><link rel="canonical" href="http://lavender321.github.com/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 流泪猫猫头","link":"链接: ","source":"来源: Lavender's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试的区别',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-15 22:02:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Lavender's blog"><span class="site-name">Lavender's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试的区别</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-29T03:14:58.000Z" title="发表于 2023-01-29 11:14:58">2023-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-15T14:02:22.653Z" title="更新于 2024-09-15 22:02:22">2024-09-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试的区别"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h1><p>a. 箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是<code>=&gt;</code>定义函数,普通函数是<code>function</code>定义函数。  </p>
<p>b. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了。  </p>
<p>c. 箭头函数不能作为构造函数使用，也不能使用new关键字(<code>因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会改变,作为构造函数其的this要是指向创建的新对象</code>)。  </p>
<p>d. 箭头函数没有自己的arguments。在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。  </p>
<p>e. call、apply、bind 并不会影响其 this 的指向。  </p>
<p>f. 箭头函数没有原型prototype。  </p>
<p>g. 箭头函数不能当作 Generator 函数，不能使用 yield 关键字。  </p>
<h1 id="var，let和const之间的区别"><a href="#var，let和const之间的区别" class="headerlink" title="var，let和const之间的区别"></a>var，let和const之间的区别</h1><p>从以下<code>三个方面</code>说。  </p>
<p><strong>变量提升方面</strong>：var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined。<br>let和const不存在变量提升问题(<code>注意这个‘问题’后缀，其实是有提升的，只不过是let和const具有一个暂时性死区的概念，即没有到其赋值时，之前就不能用</code>)，即它们所声明的变量一定要在声明后使用，否则报错。  </p>
<p><strong>块级作用域方面</strong>：var不存在块级作用域,let和const存在块级作用域  </p>
<p><strong>声明方面</strong>：var允许重复声明变量,let和const在同一作用域不允许重复声明变量。其中const声明一个只读的常量(因为如此，其声明时就一定要赋值，不然报错)。一旦声明，常量的值就不能改变。  </p>
<p><strong>如何使const声明的对象内属性不可变，只可读呢？</strong><br>如果const声明了一个对象，对象里的属性是可以改变的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;<span class="attr">name</span>:<span class="string">&#x27;蟹黄&#x27;</span>&#125;;</span><br><span class="line">obj.<span class="property">name</span>=<span class="string">&#x27;同学&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">//同学</span></span><br></pre></td></tr></table></figure>

<p>因为const声明的obj只是保存着其对象的<strong>引用地址</strong>，只要地址不变，就不会出错。  </p>
<p>使用<code>Object.freeze(obj)</code> 冻结obj,就能使其内的属性不可变,但它有局限，就是obj对象中要是有属性是对象，该对象内属性还能改变，要全不可变，就需要使用递归等方式一层一层全部冻结。</p>
<h1 id="Bigint和Number的区别"><a href="#Bigint和Number的区别" class="headerlink" title="Bigint和Number的区别"></a>Bigint和Number的区别</h1><p>Number类型的数字<strong>有精度限制</strong>，数值的精度只能到 53 个二进制位（相当于 16 个十进制位, <code>正负9007199254740992</code>），大于这个范围的整数，就无法精确表示了。  </p>
<p>Bigint<strong>没有位数的限制，任何位数的整数都可以精确表示</strong>。但是其只能用于表示整数，且为了与Number进行区分，BigInt 类型的数据必须添加后缀n。BigInt 可以使用负号（-），但是不能使用正号（+）。  </p>
<p>另外number类型的数字和Bigint类型的数字<strong>不能</strong>混合计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`12n+12;//报错`</span></span><br></pre></td></tr></table></figure>

<h1 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a>基本数据类型和引用数据类型的区别</h1><h2 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a><strong>基本数据类型：</strong></h2><p>a. 基本数据类型的值是不可变的(重新赋值属于改变属性名的指向了，而不是对值进行操作)，这里你就可以联想到，<code>是不是所有关于字符串和数字的方法</code>都是带有<code>返回值</code>的，而不是改变原字符串或数字。<br>例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//abc</span></span><br></pre></td></tr></table></figure>

<p>b. 基本数据类型不可以添加属性和方法，虽然不会报错，但也只是一瞬间转为了相应包装对象，操作完又转化回原基本数据类型，不会保存结果。  </p>
<p>c. 基本数据类型的赋值是简单赋值,基本数据类型的比较是值的比较。  </p>
<p>d. 基本数据类型是存放在栈区的  </p>
<h2 id="引用数据类型："><a href="#引用数据类型：" class="headerlink" title="引用数据类型："></a><strong>引用数据类型：</strong></h2><p>a. 引用类型的值是可以改变的,例如对象就可以通过修改对象属性值更改对象。  </p>
<p>b. 引用类型可以添加属性和方法。  </p>
<p>c. 引用类型的赋值是对象引用,即声明的变量标识符，存储的只是对象的指针地址。  </p>
<p>d. 引用类型的比较是引用(<code>指针地址</code>)的比较。  </p>
<p>e. 引用类型是同时保存在栈区和堆区中的,栈区保存变量标识符和指向堆内存的地址。  </p>
<h1 id="defer和async的区别"><a href="#defer和async的区别" class="headerlink" title="defer和async的区别"></a>defer和async的区别</h1><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><strong>defer</strong>：中文意思是延迟。用途是表示脚本会被延迟到整个页面都解析完毕后再运行。因此，在<code>&lt;script&gt;</code>元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。<br>HTML5规范要求脚本按照它们出现的<code>先后顺序执行</code>，因此第一个延迟脚本会先于第二个延迟脚本执行,但执行脚本之间<code>存在依赖，需要有执行的先后顺序时</code>，就可以使用<code>defer</code>,延迟执行。我觉得把script脚本放在body底部和defer差不多。</p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p><strong>async</strong>：中文意思是异步，这个属性与defer类似，都用于改变处理脚本的行为。同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。当页面继续进行解析时，脚本将被执行。与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。<br>指定async属性的目的是不让页面等待两个脚本下载和执行，从而<code>异步加载页面</code>其他内容,这使用于之间<code>互不依赖</code>的各脚本。</p>
<p>当网页交给浏览器的HTML解析器转变成一系列的词语（Token）。解释器根据词语构建节点（Node），形成DOM树。因为JavaScript代码可能会修改DOM树的结构，所以节点是JavaScript代码的话，就需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。<br>这里就会产生<strong>阻塞</strong>，出现<strong>白屏问题</strong>(白屏问题优化有很多方面，这里就脚本阻塞这一小点)，我们就可以使用<code>async和defer</code>属性来解决JavaScript脚本阻塞问题。  </p>
<p>当然最稳妥的办法还是把script标签放置在body的底部，没有兼容性问题，不会因此产生白屏问题，没有执行顺序问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>如果 async&#x3D;”async”：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）</li>
<li>如果不使用 async 且 defer&#x3D;”defer”：脚本将在页面完成解析时执行</li>
<li>如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本</li>
</ul>
<h1 id="async-await对比promise的优缺点"><a href="#async-await对比promise的优缺点" class="headerlink" title="async await对比promise的优缺点"></a>async await对比promise的优缺点</h1><h2 id="async-x2F-await优点："><a href="#async-x2F-await优点：" class="headerlink" title="async&#x2F;await优点："></a><strong>async&#x2F;await优点</strong>：</h2><p>a. 它做到了真正的串行的同步写法，代码阅读相对容易  </p>
<p>b. 对于条件语句和其他流程语句比较友好，可以直接写到判断条件里面  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(222)</span><br><span class="line">      &#125;, 2222)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">async function f() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if ( await a() === 222) &#123;</span><br><span class="line">        console.log(&#x27;yes, it is!&#x27;) // 会打印</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>c. 处理复杂流程时，在代码清晰度方面有优势  </p>
<h2 id="async-x2F-await缺点："><a href="#async-x2F-await缺点：" class="headerlink" title="async&#x2F;await缺点："></a><strong>async&#x2F;await缺点</strong>：</h2><p>a. 无法处理promise返回的reject对象，要借助try…catch…  </p>
<p>b. 用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//promise</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">ajax1</span>(), <span class="title function_">ajax2</span>()])</span><br></pre></td></tr></table></figure>

<p>c. try…catch…内部的变量无法传递给下一个try…catch…,Promise和then&#x2F;catch内部定义的变量，能通过then链条的参数传递到下一个then&#x2F;catch，但是async&#x2F;await的try内部的变量，如果用let和const定义则无法传递到下一个try…catch…，只能在外层作用域先定义好。</p>
<p><strong>但async&#x2F;await确确实实是解决了promise一些问题的。更加灵活的处理异步</strong>  </p>
<h2 id="promise的一些问题："><a href="#promise的一些问题：" class="headerlink" title="promise的一些问题："></a><strong>promise的一些问题：</strong></h2><ol>
<li><p>一旦执行，无法中途取消，链式调用多个then中间不能随便跳出来；</p>
</li>
<li><p>错误无法在外部被捕捉到，只能在内部进行预判处理，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 </p>
</li>
<li><p>Promise内部如何执行，监测起来很难，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p>
</li>
</ol>
<h1 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h1><p>a. GET 是将参数写在 <code>URL 中 ?</code> 的后面，并用 <code>&amp;</code> 分隔不同参数；而 POST 是将信息存放在 <code>Message Body</code> 中传送，参数‘不会’显示在 URL 中(Restful规范中是这样，但post在有需要时可以把参数放URL里)。GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。  </p>
<p>b. GET请求提交的数据有长度限制（<strong>HTTP 协议本身没有限制 URL 及正文长度</strong>,对 URL 的限制大多是浏览器和服务器的原因），POST请求没有内容长度限制。  </p>
<p>c. GET请求返回的内容会被浏览器缓存起来。而每次提交POST请求，浏览器不会缓存POST请求返回的内容。  </p>
<p>d. GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。  </p>
<p>e. 关于安全性，GET 请求方式从浏览器的 URL 地址就可以看到参数；所以post更安全，其实无论是 GET 还是 POST 其实<strong>都是不安全的</strong>，因为 HTTP 协议是明文传输，只要拦截封包便能轻易获取重要资讯。想要安全传输资料，必须使用 SSL&#x2F;TLS来加密封包，也就是 HTTPS。  </p>
<p><strong>那为什么推崇使用post来处理敏感数据呢？</strong><br>因为get的记录会保存在浏览器，上网日志中，而使用Post，因为数据不会记录存储在浏览器的记录和网址访问记录中，这样会有更大的<strong>安全性</strong>。  </p>
<p>f.<strong>一个误区</strong> 说GET产生一个TCP数据包；POST产生两个TCP数据包<br><strong>其说法</strong>：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。  </p>
<p>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。  </p>
<p><strong>为其正名</strong>:上面所说的post会比get多一个tcp包其实不太严谨。多发的那个expect 100 continue header报文，是<code>由客户端对http的post和get的请求策略决定</code>的，目的是为了避免浪费资源，如带宽，数据传输消耗的时间等等。所以客户端会在发送header的时候添加expect 100去探探路，如果失败了就不用继续发送data，从而减少了资源的浪费。所以是否再发送一个包取决了客户端的实现策略，和get&#x2F;post并没什么关系。有的客户端比如fireFox就只发送一个包。  </p>
<h1 id="用框架和不用框架的区别，vue和react的区别"><a href="#用框架和不用框架的区别，vue和react的区别" class="headerlink" title="用框架和不用框架的区别，vue和react的区别"></a>用框架和不用框架的区别，vue和react的区别</h1><p>Vue</p>
<p>React组件的编译过程涉及将JSX转换为JavaScript，然后创建虚拟DOM，再将虚拟DOM转换为真实DOM并进行有效的更新。这整个过程优化了DOM操作，减少了性能开销，使得React能够高效地处理大型和复杂的应用界面。</p>
<p>vue：template-渲染函数-虚拟DOM-真实DOM</p>
<p>react：JSX-javascript-虚拟FDOM-真实DOM-批处理和更新DOM</p>
<h2 id="用框架和不用框架的区别：（以使用框架的角度看）"><a href="#用框架和不用框架的区别：（以使用框架的角度看）" class="headerlink" title="用框架和不用框架的区别：（以使用框架的角度看）"></a><strong>用框架和不用框架的区别：（以使用框架的角度看）</strong></h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>a. 使用框架工具写项目，在浏览器中代码依然是原生的HTML CSS JS。而框架帮开发者做了很多事情，开发者只关注业务逻辑就可以,极大的加快了开发速度。<br>例如前端框架根本上是解决了<code>UI 与状态同步问题</code>,<code>频繁操作 DOM 性能低下</code>.<code>中间步骤过多,易产生 bug且不易维护</code>,而且<code>心智要求较高不利于开发效率</code>的一系列阻碍。</p>
<p>b. <code>组件化</code>: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。  </p>
<p>c. <code>天然分层</code>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</p>
<p>d. <code>生态</code>: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案；</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>a. 代码臃肿，使用者使用框架的时候会将整个框架引入，而框架封装了很多功能和组件，使用者必须按照它的规则使用，而实际开发中很多功能和组件是用不到的。  </p>
<p>b. 框架迭代更新速度非常快，需要时间熟悉它。  </p>
<p>c. 待补充。。。(<strong>希望评论区能提出宝贵见解</strong>)</p>
<h2 id="说说Vue和React的区别："><a href="#说说Vue和React的区别：" class="headerlink" title="说说Vue和React的区别："></a><strong>说说Vue和React的区别：</strong></h2><p>这里就说说其思想差异(毕竟面试时不一定就要把两个框架差异说清楚，理解核心就好)：  </p>
<p><code>react整体是函数式的思想</code>，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；  </p>
<p><code>vue的思想是响应式的</code>，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。  </p>
<p>其他的细节差异可以看看这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904040564785159" title="https://juejin.cn/post/6844904040564785159">关于Vue和React的一些对比</a></p>
<h2 id="用框架的虚拟DOM一定比真实DOM节点好吗"><a href="#用框架的虚拟DOM一定比真实DOM节点好吗" class="headerlink" title="用框架的虚拟DOM一定比真实DOM节点好吗"></a>用框架的虚拟DOM一定比真实DOM节点好吗</h2><p>使用虚拟DOM是否一定比直接操作真实DOM更好，并非绝对。这取决于具体的应用场景、性能要求以及项目的复杂性。以下是虚拟DOM和真实DOM的一些比较，以及它们各自的优缺点。</p>
<h3 id="虚拟DOM的优点"><a href="#虚拟DOM的优点" class="headerlink" title="虚拟DOM的优点"></a>虚拟DOM的优点</h3><ol>
<li><p><strong>性能优化</strong>：虚拟DOM可以减少直接操作真实DOM的次数，因为真实的DOM操作是昂贵的（从性能角度来看）。虚拟DOM允许我们在内存中进行DOM比较，只把实际变更的部分应用到真实DOM上，这通常可以减少重绘（repaint）和回流（reflow）的次数。</p>
</li>
<li><p><strong>声明式编程</strong>：虚拟DOM的使用允许开发者通过声明式地更新视图的状态，而不是命令式地操作DOM。这种方式简化了代码逻辑，提高了开发效率，并有助于减少错误。</p>
</li>
<li><p><strong>跨平台能力</strong>：虚拟DOM不依赖于浏览器API，它是一个纯粹的JavaScript对象表示。这使得同一个组件能够在不同的环境中运行，如浏览器、服务器（SSR）、甚至原生应用（React Native）。</p>
</li>
</ol>
<h3 id="虚拟DOM的缺点"><a href="#虚拟DOM的缺点" class="headerlink" title="虚拟DOM的缺点"></a>虚拟DOM的缺点</h3><ol>
<li><p><strong>额外的资源消耗</strong>：虚拟DOM需要在内存中维护一份DOM的副本，这会增加内存使用。同时，虚拟DOM的比较和更新算法虽然优化了DOM操作，但也引入了额外的计算开销。</p>
</li>
<li><p><strong>初次加载成本</strong>：对于虚拟DOM的首次渲染，由于需要构建整个虚拟DOM树，可能会比直接使用真实DOM慢。</p>
</li>
<li><p><strong>复杂度</strong>：虽然虚拟DOM简化了开发，但在一些简单的应用中，引入虚拟DOM可能是一个过度设计。对于一些小型或不太复杂的项目，直接操作DOM可能会更简单、更直接。</p>
</li>
</ol>
<h3 id="真实DOM的情况"><a href="#真实DOM的情况" class="headerlink" title="真实DOM的情况"></a>真实DOM的情况</h3><p>直接操作真实DOM在某些情况下是有优势的：</p>
<ol>
<li><p><strong>简单场景</strong>：对于简单的动态内容更新，直接使用原生DOM操作可能更快，因为它不涉及虚拟DOM层的额外开销。</p>
</li>
<li><p><strong>精细控制</strong>：在需要精确控制DOM行为的场景下，直接操作DOM可以更精确地处理细节，如动画的精细调整。</p>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>虚拟DOM并不是一种“一定好”的解决方案，而是根据具体情况选择最适合项目需求的工具。对于大型、复杂的单页应用（SPA），使用虚拟DOM的框架可以带来显著的开发效率提升和性能优化。而对于小型或性能要求极高的项目，直接操作真实DOM可能更加合适。开发者应根据应用的具体需求和性能瓶颈来选择最合适的技术方案。</p>
<h1 id="cookies和session的区别"><a href="#cookies和session的区别" class="headerlink" title="cookies和session的区别"></a>cookies和session的区别</h1><p> <strong>localStorage和sessionStorage保存的5MB都是同一个域下面存的内容</strong></p>
<p>a. <code>存储位置不同:</code>cookie的数据信息存放在客户端浏览器上，session的数据信息存放在服务器上。  </p>
<p>b. <code>存储容量不同:</code>单个cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个Cookie，而对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。  </p>
<p>c. <code>存储方式不同:</code>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。  </p>
<p>d. <code>隐私策略不同:</code>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的，而session存储在服务器上，对客户端是透明的，不存在敏感信息泄漏的风险。  </p>
<p>e. <code>有效期上不同:</code>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。  </p>
<p>f. <code>服务器压力不同:</code>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。  </p>
<p>g. <code>跨域支持上不同:</code>cookie支持跨域名访问(二级域名是可以共享cookie的)。session不支持跨域名访问。  </p>
<h1 id="宏任务和微任务有什么区别"><a href="#宏任务和微任务有什么区别" class="headerlink" title="宏任务和微任务有什么区别"></a>宏任务和微任务有什么区别</h1><p>微任务和宏任务皆为异步任务，它们都属于一个队列，主要<strong>区别在于他们的执行顺序，Event Loop的走向和取值</strong>。  </p>
<p><strong>宏任务和微任务的一些分配</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">         宏任务          浏览器         Node</span><br><span class="line">I/O      ✅✅</span><br><span class="line">setTimeout✅✅</span><br><span class="line">setInterval✅✅</span><br><span class="line">setImmediate    ❌✅</span><br><span class="line">requestAnimationFrame           ✅✅</span><br><span class="line"></span><br><span class="line">         微任务</span><br><span class="line">process.nextTick        ❌✅</span><br><span class="line">MutationObserver        ✅❌</span><br><span class="line">Promise.then catch finally              ✅✅</span><br></pre></td></tr></table></figure>

<p><strong>宏任务与微任务之间的执行顺序</strong>(同步任务-&gt;微任务-&gt;宏任务)<br>下面说说执行到宏任务后是怎么继续运行的<br>(这里声明下，整段js代码就是第一个大的宏任务，事件循环是由这第一个宏任务开始的，然后分出微任务，这里是为了理解微任务宏任务的执行区别就先跳过这第一层)  </p>
<p><code>说一个很有名的银行例子</code>：银行柜台前排着一条队伍，都是存钱的人，存钱属于宏任务，这条队伍就是宏任务队列，当一个‘宏大爷’被叫到了自己的号码，就上前去–被处理，处理存钱业务时，‘宏大爷’<strong>突然</strong>想给自己的存款办个微理财(<code>微任务</code>)，那么银行职员就将他的需求添加到自己的微任务队列，大爷就不用再排队了，直接在存钱宏任务进行完后就处理衍生出来的微任务理财，办理财时大爷又说办个信用卡，那就又排到微任务队列里。<strong>但要是</strong>在此次存钱时‘宏大爷’说他还要存钱，且是他老伴要存钱，也是<code>宏任务</code>，但不好意思，需要取号到宏任务队列的后面排队（这里就是在宏任务进行时产生微任务和宏任务的处理方式）。  </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b68f33891a3e418696c2258e96441d7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"></p>
<p>结合下面的题目理解理解（这里先不介绍node环境的事件循环的特殊地方，主要以浏览器环境，最好看看底下推荐的文章）：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//宏任务1</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);<span class="comment">//同步任务1</span></span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//微任务1</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);<span class="comment">//同步任务2</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//宏任务2</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>);<span class="comment">//宏任务2中的同步任务</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);<span class="comment">//宏任务2中的同步任务</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;<span class="comment">//宏任务2中的微任务</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x1&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">          &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;X2&#x27;</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//宏任务2中的宏任务</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;X3&#x27;</span>);</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;<span class="comment">//宏任务2中的宏任务中的同步任务</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;X4&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">          &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//宏任务2中的宏任务中的微任务</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;X5&#x27;</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">      &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//宏任务2中的微任务</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//宏任务3</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//（对于这段代码node环境和浏览器环境输出一致）</span></span><br><span class="line">    <span class="comment">//输出答案：2,4,3,1,5,6,x1,x2,7,8,x3,x4,x5</span></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903657264136200#heading-3" title="https://juejin.cn/post/6844903657264136200#heading-3">更多eventloop详细可看这篇文章</a></p>
<h1 id="fetch，Ajax，axios区别"><a href="#fetch，Ajax，axios区别" class="headerlink" title="fetch，Ajax，axios区别"></a>fetch，Ajax，axios区别</h1><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax是（Asynchronous JavaScript and XML）的缩写。现在，允许浏览器与服务器通信而无须刷新当前页面的技术都被叫做Ajax。核心使用<code>XMLHttpRequest</code>对象。  </p>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上<code>也是对原生XHR</code>的封装，只不过它是Promise的实现版本，符合最新的ES规范。  </p>
<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>Fetch被称为下一代Ajax技术，采用Promise方式来处理数据。是一种简洁明了的API，比XMLHttpRequest更加简单易用。  </p>
<p>所以其主要区别是 axios、fetch请求后都支持Promise对象API，ajax只能用回调函数。  </p>
<p>具体了解可看此文章<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/89089088" title="https://zhuanlan.zhihu.com/p/89089088">一文秒懂 ajax, fetch, axios</a></p>
<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><blockquote>
<p>都是传输层的协议</p>
</blockquote>
<ol>
<li><p>TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。  </p>
</li>
<li><p>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换。  </p>
</li>
<li><p>TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因 此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。  </p>
</li>
<li><p>TCP 只能是 1 对 1 的，而UDP 支持 1 对 1，1 对多。  </p>
</li>
<li><p>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。  </p>
</li>
<li><p>TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。</p>
</li>
</ol>
<h1 id="JS中的堆和栈，栈和队列有什么区别"><a href="#JS中的堆和栈，栈和队列有什么区别" class="headerlink" title="JS中的堆和栈，栈和队列有什么区别"></a>JS中的堆和栈，栈和队列有什么区别</h1><p><strong>堆(heap)和栈(stack)的区别:</strong>  </p>
<p>堆：队列优先,<strong>先进先出</strong>；由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  </p>
<p>栈：<strong>先进后出</strong>；动态分配的空间 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。  </p>
<p><strong>栈和队列的区别：</strong>  </p>
<p>a. 栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除。  </p>
<p>b. 栈是先进后出，队列是先进先出。  </p>
<h1 id="WebSocket和HTTP有什么区别"><a href="#WebSocket和HTTP有什么区别" class="headerlink" title="WebSocket和HTTP有什么区别"></a>WebSocket和HTTP有什么区别</h1><p>websocket出现的原因</p>
<blockquote>
<ul>
<li>因为 HTTP 协议有一个缺陷：通信只能由客户端发起</li>
<li>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）, 因此websocket应运而生。</li>
</ul>
</blockquote>
<p><strong>相同点</strong><br>a. 都是一样基于TCP的，都是可靠性传输协议。  </p>
<p>b. 都是应用层协议。  </p>
<p><strong>不同点</strong><br>a. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。  </p>
<p>b. WebSocket是需要握手进行建立连接的(相对HTTP来说，WebSocket是一种持久化的协议。它会基于HTTP协议，来完成一部分握手，HTTP握手部分完成，协议升级为WebSocket)。  </p>
<p>可以学习这篇文章<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/74326818" title="https://zhuanlan.zhihu.com/p/74326818">WebSocket其实没那么难</a></p>
<h2 id="15-http和https的区别"><a href="#15-http和https的区别" class="headerlink" title="15. http和https的区别"></a>15. http和https的区别</h2><p>a. HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。  </p>
<p>b. 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而<strong>需要一定费用</strong>。  </p>
<p>c. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。 </p>
<p>d. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
<p>e. HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p>
<h2 id="16-px，em，rem，vw，vh区别"><a href="#16-px，em，rem，vw，vh区别" class="headerlink" title="16. px，em，rem，vw，vh区别"></a>16. px，em，rem，vw，vh区别</h2><p>px: 像素单位，px就是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的。</p>
<p>em: <strong>参考物是父元素</strong>的font-size，具有继承的特点。如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</p>
<p>rem: css3新单位，<strong>相对于根元素html</strong>（网页）的font-size，不会像em那样，依赖于父元素的字体大小，而造成混乱。</p>
<p>vw: css3新单位，viewpoint width的缩写，<strong>视窗宽度</strong>，1vw等于视窗宽度的1%。<br>举个例子：浏览器宽度1200px, 1 vw &#x3D; 1200px&#x2F;100 &#x3D; 12 px。</p>
<p>vh: css3新单位，viewpoint height的缩写，<strong>视窗高度</strong>，1vh等于视窗高度的1%。<br>举个例子：浏览器高度900px, 1 vh &#x3D; 900px&#x2F;100 &#x3D; 9 px。</p>
<h1 id="Webpack中loader和plugin的区别"><a href="#Webpack中loader和plugin的区别" class="headerlink" title="Webpack中loader和plugin的区别"></a>Webpack中loader和plugin的区别</h1><p>在Webpack中，<strong>loader</strong>和<strong>plugin</strong>都是非常核心的概念，它们共同支持Webpack的强大和灵活性，但它们在功能和用途上有明显的区别。理解这些区别对于有效地使用Webpack进行项目构建是非常重要的。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中  </p>
<p><strong>作用</strong>：</p>
<ul>
<li>Loader用于对模块的源代码进行转换。Loader可以让Webpack处理那些非JavaScript文件（Webpack本身只理解JavaScript）。例如，通过不同的Loader，Webpack可以加载和转译CSS、images、TypeScript等。</li>
</ul>
<p><strong>工作方式</strong>：</p>
<ul>
<li>Loader在Webpack的模块加载过程中运行，通过链式传递的方式应用于源文件。一个文件可以依次经过多个Loader处理。例如，可以先使用<code>sass-loader</code>将SASS文件转换为CSS，然后使用<code>css-loader</code>加载CSS，并使用<code>style-loader</code>将CSS注入到JavaScript中，从而在运行时动态创建style标签。</li>
</ul>
<p><strong>配置方式</strong>：</p>
<ul>
<li>在Webpack配置中，Loader是在<code>module.rules</code>数组中配置的，通过正则表达式来匹配文件类型，指定需要应用的Loader列表。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。  </p>
<p><strong>作用</strong>：</p>
<ul>
<li>Plugin用于扩展Webpack的功能。它们直接访问Webpack的整个编译生命周期，可以在生命周期的任何阶段执行广泛的任务，如打包优化、资源管理和环境变量注入等。</li>
</ul>
<p><strong>工作方式</strong>：</p>
<ul>
<li>Plugin通过钩子机制工作，Webpack的编译流程中有许多钩子，Plugin可以在特定的时刻执行特定的任务。比如，<code>HtmlWebpackPlugin</code>可以生成一个HTML文件，并自动将打包后的JavaScript注入到这个HTML文件中。</li>
</ul>
<p><strong>配置方式</strong>：</p>
<ul>
<li>在Webpack配置中，Plugin在<code>plugins</code>数组中实例化并配置。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="comment">// Loader 配置</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><strong>目的和用途</strong>：Loader主要用于转换特定类型的模块，比如将A.scss转换成A.css，而Plugin影响整个构建流程，具有更广泛的用途。</li>
<li><strong>配置位置</strong>：Loader在<code>module.rules</code>中配置，针对不同文件类型定义转换规则；Plugin在<code>plugins</code>数组中配置，通常用于执行更复杂的任务。</li>
<li><strong>工作范围</strong>：Loader专注于文件级别的转换；Plugin可以工作在整个构建流程上，不直接操作文件，二十基于事件机制工作，执行各种任务，包括但不限于优化、定义环境变量、重写输出文件等。</li>
</ul>
<p>理解这些区别有助于更合理和高效地使用Webpack，从而为项目构建提供更强大的支持。</p>
<h1 id="bind-call-apply区别"><a href="#bind-call-apply区别" class="headerlink" title="bind call apply区别"></a>bind call apply区别</h1><p>a. 三者都可以改变函数的this对象指向。</p>
<p>b. 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。</p>
<p>c. 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。</p>
<p>d. bind 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数便于稍后调用； apply, call则是立即调用。</p>
<h1 id="301-和-302-有什么区别"><a href="#301-和-302-有什么区别" class="headerlink" title="301 和 302 有什么区别"></a>301 和 302 有什么区别</h1><p><code>301 Moved Permanently:</code> 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应 当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也 是可缓存的。  </p>
<p><code>302 Found:</code> 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。  </p>
<p>字面上的区别就是 301 是永久重定向，而 302 是临时重定向。  </p>
<p>301 比较常用的场景是使用域名跳转。302 用来做临时跳转, 比如未登陆的用户访问用户中心被重定向到登录页面  </p>
<h1 id="进程线程的区别"><a href="#进程线程的区别" class="headerlink" title="进程线程的区别"></a>进程线程的区别</h1><p>a. <strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p>b. <strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p>c. <strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p>d. <strong>内存分配</strong>：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p>
<p>e. <strong>影响关系</strong>：因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程要比多线程健壮。  </p>
<p>还可看看：<br><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" title="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">阮一峰对进程线程的简单解释</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903908385488903" title="https://juejin.cn/post/6844903908385488903">深入理解Node.js 中的进程与线程</a></p>
<h1 id="JavaScript和Typescript的区别"><a href="#JavaScript和Typescript的区别" class="headerlink" title="JavaScript和Typescript的区别"></a>JavaScript和Typescript的区别</h1><p>a. TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。</p>
<p>b. JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。</p>
<p>c. TypeScript 通过类型注解提供编译时的静态类型检查。</p>
<p>d. TypeScript 中的数据要求带有明确的类型，JavaScript不要求。</p>
<p>e. TypeScript 为函数提供了缺省参数值。</p>
<p>f. TypeScript 引入了 JavaScript 中没有的“类”概念。</p>
<p>h. TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。</p>
<h1 id="localstorage、sessionstorage、cookie的区别"><a href="#localstorage、sessionstorage、cookie的区别" class="headerlink" title="localstorage、sessionstorage、cookie的区别"></a>localstorage、sessionstorage、cookie的区别</h1><h3 id="localstorage是异步还是同步？"><a href="#localstorage是异步还是同步？" class="headerlink" title="localstorage是异步还是同步？"></a>localstorage是异步还是同步？</h3><p><code>localStorage</code> 是一个同步的存储机制，这意味着当你从 JavaScript 代码对其进行读取或写入操作时，这些操作会立即执行，并且在操作完成之前，JavaScript 执行将被阻塞。这里有几个原因解释为什么 <code>localStorage</code> 是同步的：</p>
<h4 id="设计简单性"><a href="#设计简单性" class="headerlink" title="设计简单性"></a>设计简单性</h4><p><code>localStorage</code> 的设计目标是提供一个简单易用的方式来持久化数据在浏览器端。使其操作同步允许开发者直接通过简单的API调用来存取数据，无需处理异步回调或者promise，这样可以简化代码的复杂度。</p>
<h4 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h4><p>由于 <code>localStorage</code> 直接在本地存储数据，不涉及网络请求，其读写操作相对较快。因此，它被设计为同步操作，以便直接返回结果，不需要异步等待。</p>
<h4 id="避免并发问题"><a href="#避免并发问题" class="headerlink" title="避免并发问题"></a>避免并发问题</h4><p>同步操作简化了数据存储的并发处理。如果 <code>localStorage</code> 的操作是异步的，那么在并发访问和修改数据时可能需要额外的机制来处理数据一致性和竞态条件。通过同步操作，可以确保在任一时刻只有一个操作在访问数据，避免了复杂的并发控制问题。</p>
<h4 id="兼容性和历史原因"><a href="#兼容性和历史原因" class="headerlink" title="兼容性和历史原因"></a>兼容性和历史原因</h4><p>当 <code>localStorage</code> 被引入时，JavaScript 的异步编程模式（如 Promises 和 async&#x2F;await）还不是标准的一部分。因此，为了保持API的易用性和兼容性，<code>localStorage</code> 被设计为同步API。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然同步设计简化了使用，但也带来了一些性能问题，尤其是在涉及较大数据或频繁操作时。同步调用可能会阻塞主线程，导致用户界面的响应变慢，影响用户体验。因此，对于需要频繁访问或处理大量数据的应用，推荐使用 <code>IndexedDB</code>，它是一个支持异步操作的更强大的本地存储解决方案。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>localStorage</code> 是同步的，因为这简化了其使用和实现，使其适合快速且少量的数据存取操作。然而，开发者需要注意，过度依赖 <code>localStorage</code> 可能会导致性能瓶颈，尤其是在复杂应用中。对于更高级的存储需求，应考虑使用异步的 <code>IndexedDB</code>。</p>
<h2 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h2><p>a. 相同点是都是保存在浏览器端、且同源的</p>
<p>b. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p>
<p>c. 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p>
<p>d. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p>
<p>e. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p>
<p>f. webStorage(<code>webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage</code>)支持事件通知机制，可以将数据更新的通知发送给监听者</p>
<p>h. webStorage的api接口使用更方便</p>
<h2 id="23-http-1-0-x2F-1-1-x2F-2-0的不同"><a href="#23-http-1-0-x2F-1-1-x2F-2-0的不同" class="headerlink" title="23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同"></a>23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同</h2><p><strong>http 1.0(构建可扩展性)</strong><br>HTTP原有的应用非常局限，浏览器和服务器迅速扩展使其用途更广：</p>
<p>a. 版本信息现在会随着每个请求发送（HTTP1.0 被追加到GET行）</p>
<p>b. 状态代码行也会在响应开始时发送，允许浏览器本身了解请求的成功或失败，并相应地调整其行为（如以特定方式更新或使用本地缓存）</p>
<p>c. 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，并使协议非常灵活和可扩展。</p>
<p>d. Content-Type标头告诉客户端实际返回的内容的内容类型。在Content-Type标头帮助下，增加了传输除纯文本HTML文件外的其他类型文档的能力。</p>
<p><strong>http 1.1(标准化的协议)</strong><br>HTTP&#x2F;1.0的多种不同的实现运用起来有些混乱，HTTP1.1是第一个标准化版本，重点关注的是校正HTTP设计中的结构性缺陷：</p>
<p>a. 连接可以重复使用，节省了多次打开它的时间，以显示嵌入到单个原始文档中的资源。</p>
<p>b. 增加流水线操作，允许在第一个应答被完全发送之前发送第二个请求，以降低通信的延迟。</p>
<p>c. 支持响应分块。</p>
<p>d. 引入额外的缓存控制机制。</p>
<p>e. 引入内容协商，包括语言，编码，或类型，并允许客户端和服务器约定以最适当的内容进行交换。</p>
<p>f. 通过 Host 头，能够使不同的域名配置在同一个IP地址的服务器。</p>
<p>g. 安全性得到了提高</p>
<p><strong>http 2.0(为了更优异的表现)</strong><br>HTTP&#x2F;2在HTTP&#x2F;1.1有几处基本的不同:</p>
<p>HTTP2是二进制协议而不是文本协议。不再可读和无障碍的手动创建，改善的优化技术现在可被实施。</p>
<p>这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP&#x2F;1.x中顺序和阻塞的约束。</p>
<p>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</p>
<p>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</p>
<p><a href="https://link.juejin.cn/?target=https://www.cnblogs.com/zytrue/p/8568181.html" title="https://www.cnblogs.com/zytrue/p/8568181.html">参考自这篇文章</a></p>
<h2 id="24-MongoDB和MySQL的区别"><a href="#24-MongoDB和MySQL的区别" class="headerlink" title="24. MongoDB和MySQL的区别"></a>24. MongoDB和MySQL的区别</h2><p>直接放上对比表格：  </p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>MongoDB</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据库模型</td>
<td>非关系型</td>
<td>关系型</td>
</tr>
<tr>
<td>存储方式</td>
<td>以类JSON的文档的格式存储</td>
<td>不同引擎有不同的存储方式</td>
</tr>
<tr>
<td>查询语句</td>
<td>MongoDB查询方式（类似JavaScript的函数）</td>
<td>SQL语句</td>
</tr>
<tr>
<td>数据处理方式</td>
<td>基于内存，将热数据存放在物理内存中，从而达到高速读写</td>
<td>不同引擎有自己的特点</td>
</tr>
<tr>
<td>成熟度</td>
<td>新兴数据库，成熟度较低</td>
<td>成熟度高</td>
</tr>
<tr>
<td>广泛度</td>
<td>NoSQL数据库中，比较完善且开源，使用人数在不断增长</td>
<td>开源数据库，市场份额不断增长</td>
</tr>
<tr>
<td>事务性</td>
<td>仅支持单文档事务操作，弱一致性</td>
<td>支持事务操作</td>
</tr>
<tr>
<td>占用空间</td>
<td>占用空间大</td>
<td>占用空间小</td>
</tr>
<tr>
<td>join操作</td>
<td>MongoDB没有join</td>
<td>MySQL支持join</td>
</tr>
</tbody></table>
<p>希望各位看官指出其中的错误，我必改正！也请对其中的一些问题提出自己的一些看法。这里只是一些大概的总结，想要有最好的学习效果，还是对其中每有一个点进行系统的学习。</p>
<p>笔者最近也在准备面试和寻找前端实习岗位中！wx：xieHB-frontend-178,加个微信一起学习😜，也希望有大佬介绍个内推和提出学习意见，感谢。哈哈！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Lavender321.github.com">流泪猫猫头</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lavender321.github.com/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/">http://lavender321.github.com/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Lavender321.github.com" target="_blank">Lavender's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/29/%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80CSS%E7%9F%A5%E8%AF%86%E7%82%B9/" title="巩固基础CSS知识点"><img class="cover" src="https://s2.loli.net/2023/02/19/4peNtadoWguhcU5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">巩固基础CSS知识点</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/29/webpack%E6%94%BB%E7%95%A5/" title="webpack攻略"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">webpack攻略</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/" title="CSS面试记录"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-22</div><div class="title">CSS面试记录</div></div></a></div><div><a href="/2024/04/19/Javascript%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/" title="Javascript手写代码"><img class="cover" src="https://s2.loli.net/2022/12/31/HYB9fKZPknOqSLz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-19</div><div class="title">Javascript手写代码</div></div></a></div><div><a href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">React面试题</div></div></a></div><div><a href="/2023/02/13/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98/" title="TypeScript面试题"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-13</div><div class="title">TypeScript面试题</div></div></a></div><div><a href="/2023/01/27/JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="JavaScript数组常用方法总结"><img class="cover" src="https://s2.loli.net/2022/12/31/HYB9fKZPknOqSLz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-27</div><div class="title">JavaScript数组常用方法总结</div></div></a></div><div><a href="/2023/01/19/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Vue面试题总结"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-19</div><div class="title">Vue面试题总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">流泪猫猫头</div><div class="author-info__description">THE TORTURED POETS DEPARTMENT</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lavender321"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lavender321" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:r1727439300@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#var%EF%BC%8Clet%E5%92%8Cconst%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">var，let和const之间的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bigint%E5%92%8CNumber%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">Bigint和Number的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">基本数据类型和引用数据类型的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">基本数据类型：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">引用数据类型：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#defer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">defer和async的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#defer"><span class="toc-number">5.1.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async"><span class="toc-number">5.2.</span> <span class="toc-text">async</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#async-await%E5%AF%B9%E6%AF%94promise%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">async await对比promise的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#async-x2F-await%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">async&#x2F;await优点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-x2F-await%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">6.2.</span> <span class="toc-text">async&#x2F;await缺点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">promise的一些问题：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">get和post的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%8D%E7%94%A8%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Cvue%E5%92%8Creact%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">用框架和不用框架的区别，vue和react的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%8D%E7%94%A8%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A%EF%BC%88%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%A1%86%E6%9E%B6%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">用框架和不用框架的区别：（以使用框架的角度看）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">8.1.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">8.1.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue%E5%92%8CReact%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">说说Vue和React的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%A1%86%E6%9E%B6%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E4%B8%80%E5%AE%9A%E6%AF%94%E7%9C%9F%E5%AE%9EDOM%E8%8A%82%E7%82%B9%E5%A5%BD%E5%90%97"><span class="toc-number">8.3.</span> <span class="toc-text">用框架的虚拟DOM一定比真实DOM节点好吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">8.3.1.</span> <span class="toc-text">虚拟DOM的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">8.3.2.</span> <span class="toc-text">虚拟DOM的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9EDOM%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">8.3.3.</span> <span class="toc-text">真实DOM的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cookies%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">cookies和session的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">宏任务和微任务有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fetch%EF%BC%8CAjax%EF%BC%8Caxios%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">fetch，Ajax，axios区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax"><span class="toc-number">11.1.</span> <span class="toc-text">Ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-number">11.2.</span> <span class="toc-text">axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetch"><span class="toc-number">11.3.</span> <span class="toc-text">fetch</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">TCP和UDP的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">JS中的堆和栈，栈和队列有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WebSocket%E5%92%8CHTTP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">WebSocket和HTTP有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.1.</span> <span class="toc-text">15. http和https的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-px%EF%BC%8Cem%EF%BC%8Crem%EF%BC%8Cvw%EF%BC%8Cvh%E5%8C%BA%E5%88%AB"><span class="toc-number">14.2.</span> <span class="toc-text">16. px，em，rem，vw，vh区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Webpack%E4%B8%ADloader%E5%92%8Cplugin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">Webpack中loader和plugin的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Loader"><span class="toc-number">15.1.</span> <span class="toc-text">Loader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Plugin"><span class="toc-number">15.2.</span> <span class="toc-text">Plugin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">15.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bind-call-apply%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">bind call apply区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#301-%E5%92%8C-302-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">301 和 302 有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">进程线程的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E5%92%8CTypescript%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">JavaScript和Typescript的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#localstorage%E3%80%81sessionstorage%E3%80%81cookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">localstorage、sessionstorage、cookie的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#localstorage%E6%98%AF%E5%BC%82%E6%AD%A5%E8%BF%98%E6%98%AF%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-number">20.0.1.</span> <span class="toc-text">localstorage是异步还是同步？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%AE%80%E5%8D%95%E6%80%A7"><span class="toc-number">20.0.1.1.</span> <span class="toc-text">设计简单性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-number">20.0.1.2.</span> <span class="toc-text">直接访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">20.0.1.3.</span> <span class="toc-text">避免并发问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E5%8E%86%E5%8F%B2%E5%8E%9F%E5%9B%A0"><span class="toc-number">20.0.1.4.</span> <span class="toc-text">兼容性和历史原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">20.0.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">20.0.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">20.1.</span> <span class="toc-text">相同点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-http-1-0-x2F-1-1-x2F-2-0%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">20.2.</span> <span class="toc-text">23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-MongoDB%E5%92%8CMySQL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.3.</span> <span class="toc-text">24. MongoDB和MySQL的区别</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/18/58/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/09/18/58/" title="无题">无题</a><time datetime="2024-09-18T07:21:55.572Z" title="发表于 2024-09-18 15:21:55">2024-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/31/vite%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="vite相关面试题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vite相关面试题"/></a><div class="content"><a class="title" href="/2024/08/31/vite%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="vite相关面试题">vite相关面试题</a><time datetime="2024-08-31T10:37:40.000Z" title="发表于 2024-08-31 18:37:40">2024-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95/" title="小程序面试"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小程序面试"/></a><div class="content"><a class="title" href="/2024/08/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95/" title="小程序面试">小程序面试</a><time datetime="2024-08-31T07:30:26.000Z" title="发表于 2024-08-31 15:30:26">2024-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/06/2025-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="2025-前端面试总结"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-前端面试总结"/></a><div class="content"><a class="title" href="/2024/08/06/2025-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="2025-前端面试总结">2025-前端面试总结</a><time datetime="2024-08-06T03:22:45.000Z" title="发表于 2024-08-06 11:22:45">2024-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/05/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/" title="hexo创建博客"><img src="https://s2.loli.net/2023/01/29/yz4ZcjfxPlEMnUD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo创建博客"/></a><div class="content"><a class="title" href="/2024/08/05/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/" title="hexo创建博客">hexo创建博客</a><time datetime="2024-08-05T14:43:08.713Z" title="发表于 2024-08-05 22:43:08">2024-08-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 流泪猫猫头</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>