<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>浏览器原理 | Lavender's blog</title><meta name="author" content="流泪猫猫头"><meta name="copyright" content="流泪猫猫头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="浏览器进程现代浏览器是一个多进程的应用程序，主要通过将不同的任务分配给不同的进程来提高性能和安全性。以下是浏览器中常见的几个进程及其功能： 浏览器主进程（Browser Process） 管理浏览器的用户界面，包括地址栏、书签栏、前进&#x2F;后退按钮等。 协调与管理子进程（如渲染进程、网络进程等），包括进程的创建和销毁。 处理与文件系统的交互（如下载文件）。 管理浏览器窗口和标签页的生命周期。">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器原理">
<meta property="og:url" content="http://lavender321.github.com/2023/01/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Lavender&#39;s blog">
<meta property="og:description" content="浏览器进程现代浏览器是一个多进程的应用程序，主要通过将不同的任务分配给不同的进程来提高性能和安全性。以下是浏览器中常见的几个进程及其功能： 浏览器主进程（Browser Process） 管理浏览器的用户界面，包括地址栏、书签栏、前进&#x2F;后退按钮等。 协调与管理子进程（如渲染进程、网络进程等），包括进程的创建和销毁。 处理与文件系统的交互（如下载文件）。 管理浏览器窗口和标签页的生命周期。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-01-29T09:18:25.000Z">
<meta property="article:modified_time" content="2024-10-27T06:01:24.885Z">
<meta property="article:author" content="流泪猫猫头">
<meta property="article:tag" content="HTTP">
<meta property="article:tag" content="HTTPS">
<meta property="article:tag" content="浏览器">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta property="article:tag" content="DNS">
<meta property="article:tag" content="三次握手">
<meta property="article:tag" content="四次挥手">
<meta property="article:tag" content="token">
<meta property="article:tag" content="跨域">
<meta property="article:tag" content="进程">
<meta property="article:tag" content="线程">
<meta property="article:tag" content="Cookie">
<meta property="article:tag" content="SEO优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2022/10/08/k5M7H1NdmnZgtlY.png"><link rel="canonical" href="http://lavender321.github.com/2023/01/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 流泪猫猫头","link":"链接: ","source":"来源: Lavender's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '浏览器原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-27 14:01:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Lavender's blog"><span class="site-name">Lavender's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">浏览器原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-29T09:18:25.000Z" title="发表于 2023-01-29 17:18:25">2023-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-27T06:01:24.885Z" title="更新于 2024-10-27 14:01:24">2024-10-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="浏览器原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h1><p>现代浏览器是一个多进程的应用程序，主要通过将不同的任务分配给不同的进程来提高性能和安全性。以下是浏览器中常见的几个进程及其功能：</p>
<h2 id="浏览器主进程（Browser-Process）"><a href="#浏览器主进程（Browser-Process）" class="headerlink" title="浏览器主进程（Browser Process）"></a>浏览器主进程（Browser Process）</h2><ul>
<li>管理浏览器的<strong>用户界面</strong>，包括地址栏、书签栏、前进&#x2F;后退按钮等。</li>
<li><strong>协调与管理子进程</strong>（如渲染进程、网络进程等），包括进程的创建和销毁。</li>
<li>处理与文件系统的交互（如下载文件）。</li>
<li>管理浏览器窗口和标签页的生命周期。</li>
<li>处理<strong>浏览器的安全机制</strong>，比如同源策略、沙盒机制等。</li>
</ul>
<h2 id="渲染进程（Renderer-Process）"><a href="#渲染进程（Renderer-Process）" class="headerlink" title="渲染进程（Renderer Process）"></a>渲染进程（Renderer Process）</h2><ul>
<li>渲染进程负责<strong>页面内容的渲染、布局和绘制</strong>，包括 HTML 解析、CSS 解析、JavaScript 执行、图片绘制等。</li>
<li>由于性能和安全的考虑，渲染进程运行在一个<strong>沙盒环境</strong>中，具有较低的权限，限制其对系统资源的访问，减少潜在的安全风险。</li>
<li>每个<strong>标签页</strong>或<strong>框架</strong>通常会拥有独立的渲染进程，这样可以隔离不同页面的运行，防止一个页面的崩溃影响其他页面。</li>
<li>渲染进程会与<strong>GPU 进程</strong>合作，进行页面的合成和绘制。</li>
</ul>
<p>浏览器的<strong>渲染进程</strong>（Renderer Process）负责将网页的 HTML、CSS、JavaScript 解析成可以在屏幕上显示的内容。了解渲染进程的工作流程有助于编写性能优化的代码，避免不必要的渲染和重绘，提高网页的响应速度和用户体验。</p>
<h3 id="渲染进程的主要过程"><a href="#渲染进程的主要过程" class="headerlink" title="渲染进程的主要过程"></a>渲染进程的主要过程</h3><p>渲染进程的流程可以分为以下几个阶段：</p>
<ol>
<li><strong>构建 DOM 树（DOM Tree Construction）</strong>—DOM tree</li>
<li><strong>样式计算（Style Calculation）</strong>—CSS tree</li>
<li><strong>布局阶段（Layout）</strong></li>
<li><strong>分层（Layering）</strong></li>
<li><strong>绘制阶段（Painting）</strong></li>
<li><strong>合成阶段（Compositing）</strong></li>
</ol>
<p>接下来逐步介绍每个阶段的工作机制及其细节。</p>
<h3 id="1-构建-DOM-树（DOM-Tree-Construction）"><a href="#1-构建-DOM-树（DOM-Tree-Construction）" class="headerlink" title="1. 构建 DOM 树（DOM Tree Construction）"></a>1. <strong>构建 DOM 树（DOM Tree Construction）</strong></h3><h4 id="1-1-HTML-解析"><a href="#1-1-HTML-解析" class="headerlink" title="1.1 HTML 解析"></a>1.1 <strong>HTML 解析</strong></h4><ul>
<li><strong>HTML 文档的解析</strong>：当浏览器接收到 HTML 文件后，渲染进程会开始解析 HTML 内容，并将其转换为一棵 <strong>DOM 树（Document Object Model）</strong>。</li>
<li><strong>DOM 树结构</strong>：DOM 树是一种由节点组成的树状结构，每个 HTML 标签（如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code> 等）对应 DOM 树中的一个节点，根节点是 <code>&lt;html&gt;</code> 标签。</li>
<li><strong>顺序解析</strong>：HTML 是顺序解析的，浏览器会一边下载 HTML，一边解析并构建 DOM 树。</li>
</ul>
<h4 id="1-2-阻塞行为"><a href="#1-2-阻塞行为" class="headerlink" title="1.2 阻塞行为"></a>1.2 <strong>阻塞行为</strong></h4><ul>
<li><strong>外部资源的阻塞</strong>：如果在 HTML 文档中遇到外部资源（如 JavaScript 脚本），DOM 构建可能会暂时暂停，直到外部资源加载和执行完成。<ul>
<li><strong>阻塞的脚本</strong>：在 <code>&lt;head&gt;</code> 中的 JavaScript 脚本会阻塞 DOM 树的构建，除非使用 <code>async</code> 或 <code>defer</code>。</li>
<li><strong>CSS 文件的阻塞</strong>：CSS 文件不会阻塞 DOM 树的构建，但会阻塞页面的渲染，直到 CSS 加载完成。</li>
</ul>
</li>
</ul>
<h3 id="2-样式计算（Style-Calculation）"><a href="#2-样式计算（Style-Calculation）" class="headerlink" title="2. 样式计算（Style Calculation）"></a>2. <strong>样式计算（Style Calculation）</strong></h3><h4 id="2-1-CSS-解析"><a href="#2-1-CSS-解析" class="headerlink" title="2.1 CSS 解析"></a>2.1 <strong>CSS 解析</strong></h4><ul>
<li><strong>构建 CSSOM 树</strong>：与 DOM 树类似，浏览器会解析所有的 CSS 样式（包括外部样式表和嵌入式样式），并将其解析成 <strong>CSSOM 树（CSS Object Model）</strong>。CSSOM 树描述了每个元素的样式信息。</li>
<li><strong>层叠顺序处理</strong>：在 CSSOM 树构建过程中，浏览器会处理<strong>层叠规则</strong>（如 <code>inherit</code>、<code>!important</code>）、<strong>选择器的优先级</strong>等，以确定每个 DOM 元素的最终样式。</li>
</ul>
<h4 id="2-2-合并-CSSOM-和-DOM"><a href="#2-2-合并-CSSOM-和-DOM" class="headerlink" title="2.2 合并 CSSOM 和 DOM"></a>2.2 <strong>合并 CSSOM 和 DOM</strong></h4><ul>
<li><strong>合成 Render Tree</strong>：在这一步，浏览器将 DOM 树与 CSSOM 树结合，生成 <strong>渲染树（Render Tree）</strong>。渲染树中的每个节点都是可见元素，并包含元素的样式信息。不可见的元素（如 <code>display: none</code> 的元素）不会出现在渲染树中。</li>
</ul>
<h3 id="3-布局阶段（Layout）"><a href="#3-布局阶段（Layout）" class="headerlink" title="3. 布局阶段（Layout）"></a>3. <strong>布局阶段（Layout）</strong></h3><h4 id="3-1-布局计算"><a href="#3-1-布局计算" class="headerlink" title="3.1 布局计算"></a>3.1 <strong>布局计算</strong></h4><ul>
<li><strong>确定元素的大小和位置</strong>：布局阶段，也称为 <strong>重排（Reflow）</strong>，浏览器根据渲染树中的信息，计算每个可见元素的几何属性，即它们在屏幕中的确切大小和位置。</li>
<li><strong>依赖样式和关系的计算</strong>：布局计算取决于元素的样式属性（如 <code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code> 等），并考虑了父子元素之间的关系（如流式布局或绝对定位等）。</li>
<li><strong>流式布局模型</strong>：默认情况下，浏览器使用流式布局模型，从上到下、从左到右依次布局。</li>
</ul>
<h4 id="3-2-回流的触发"><a href="#3-2-回流的触发" class="headerlink" title="3.2 回流的触发"></a>3.2 <strong>回流的触发</strong></h4><ul>
<li><strong>布局的重新计算</strong>：当元素的几何属性（如大小、位置）发生变化时，会触发回流（Reflow），这会导致布局的重新计算。常见的导致回流的操作包括：<ul>
<li>改变元素的尺寸（如宽高、边框大小等）。</li>
<li>在 DOM 中添加或删除元素。</li>
<li>读取一些会触发回流的属性，如 <code>offsetWidth</code>、<code>scrollHeight</code> 等。</li>
</ul>
</li>
</ul>
<h3 id="4-分层（Layering）"><a href="#4-分层（Layering）" class="headerlink" title="4. 分层（Layering）"></a>4. <strong>分层（Layering）</strong></h3><h4 id="4-1-图层的生成"><a href="#4-1-图层的生成" class="headerlink" title="4.1 图层的生成"></a>4.1 <strong>图层的生成</strong></h4><ul>
<li><strong>合成层的创建</strong>：在某些情况下，渲染树中的元素会被提升为<strong>合成层（Compositing Layer）</strong>，每个合成层独立渲染。这些图层会交由 GPU 处理，可以优化页面的渲染性能。</li>
<li><strong>触发合成层的条件</strong>：以下操作可能会触发合成层的生成：<ul>
<li>具有 <code>z-index</code> 的元素，尤其是使用 <code>position: absolute/fixed</code>。</li>
<li>使用 <code>transform</code>、<code>opacity</code>、<code>will-change</code> 等属性的元素。</li>
</ul>
</li>
</ul>
<h4 id="4-2-层叠上下文"><a href="#4-2-层叠上下文" class="headerlink" title="4.2 层叠上下文"></a>4.2 <strong>层叠上下文</strong></h4><ul>
<li><strong>层叠上下文的生成</strong>：某些 CSS 属性（如 <code>position</code>、<code>z-index</code>、<code>opacity</code>）会创建一个新的层叠上下文，改变元素的绘制顺序和叠放关系。</li>
</ul>
<h3 id="5-绘制阶段（Painting）"><a href="#5-绘制阶段（Painting）" class="headerlink" title="5. 绘制阶段（Painting）"></a>5. <strong>绘制阶段（Painting）</strong></h3><h4 id="5-1-绘制过程"><a href="#5-1-绘制过程" class="headerlink" title="5.1 绘制过程"></a>5.1 <strong>绘制过程</strong></h4><ul>
<li><strong>绘制渲染树</strong>：浏览器会根据渲染树中的信息，将页面中的每个可见元素绘制到屏幕上。这一阶段也被称为 <strong>重绘（Repaint）</strong>。</li>
<li><strong>绘制的内容</strong>：包括文本、颜色、边框、阴影、背景图片等视觉效果。</li>
<li><strong>重绘的触发</strong>：当元素的外观发生变化（如颜色、字体、背景）但不影响布局时，浏览器会触发重绘。例如，修改元素的 <code>color</code> 或 <code>background-color</code> 会导致重绘。</li>
</ul>
<h4 id="5-2-绘制的优化"><a href="#5-2-绘制的优化" class="headerlink" title="5.2 绘制的优化"></a>5.2 <strong>绘制的优化</strong></h4><ul>
<li><strong>避免频繁重绘</strong>：如果代码频繁改变元素的样式，会导致频繁的重绘操作，影响页面性能。可以通过减少不必要的样式修改来优化重绘性能。</li>
</ul>
<h3 id="6-合成阶段（Compositing）"><a href="#6-合成阶段（Compositing）" class="headerlink" title="6. 合成阶段（Compositing）"></a>6. <strong>合成阶段（Compositing）</strong></h3><h4 id="6-1-层合成"><a href="#6-1-层合成" class="headerlink" title="6.1 层合成"></a>6.1 <strong>层合成</strong></h4><ul>
<li><strong>图层合成</strong>：在页面渲染过程中，浏览器将已经绘制的图层合成为最终的页面。这些图层可以在 GPU 中处理，特别是当涉及到动画和复杂的视觉效果时，合成操作会减少 CPU 的负担，提高渲染性能。</li>
</ul>
<h4 id="6-2-GPU-加速"><a href="#6-2-GPU-加速" class="headerlink" title="6.2 GPU 加速"></a>6.2 <strong>GPU 加速</strong></h4><ul>
<li><strong>硬件加速</strong>：当元素具有 <code>transform</code>、<code>opacity</code> 或者动画效果时，浏览器会将这些元素提升到 GPU 上，利用硬件加速来进行处理。GPU 加速减少了 CPU 的参与，提升了复杂场景下的渲染速度。</li>
</ul>
<h3 id="渲染过程中的优化和注意事项"><a href="#渲染过程中的优化和注意事项" class="headerlink" title="渲染过程中的优化和注意事项"></a>渲染过程中的优化和注意事项</h3><ol>
<li><p><strong>减少回流和重绘</strong>：</p>
<ul>
<li><strong>避免频繁修改 DOM</strong>：一次性修改 DOM 比逐个修改要高效。使用 <code>documentFragment</code>、<code>innerHTML</code> 批量修改元素。</li>
<li><strong>避免强制同步布局</strong>：如 <code>offsetWidth</code>、<code>scrollHeight</code> 等属性的读取会导致浏览器立即执行布局（reflow），应尽量避免在同一轮操作中频繁读取这些属性。</li>
</ul>
</li>
<li><p><strong>使用合成层优化渲染</strong>：</p>
<ul>
<li>**<code>will-change</code>**：告知浏览器某个元素可能会发生动画或其他改变，让浏览器提前为该元素创建合成层以优化性能。</li>
<li>**<code>transform</code> 和 <code>opacity</code>**：使用这些属性进行动画时，可以避免回流和重绘，因为它们不会影响元素的几何属性。</li>
</ul>
</li>
<li><p><strong>延迟加载资源</strong>：</p>
<ul>
<li><strong>Lazy Load</strong>：对于图片、视频等大资源，使用懒加载技术，避免一次性加载所有资源，减少页面初次渲染的负担。</li>
<li><strong>脚本延迟加载</strong>：对于不阻塞渲染的 JavaScript 文件，使用 <code>async</code> 或 <code>defer</code> 来延迟加载，确保页面尽快呈现。</li>
</ul>
</li>
<li><p><strong>减少渲染阻塞</strong>：</p>
<ul>
<li><strong>优化 CSS 和 JavaScript</strong>：将 CSS 放在 <code>&lt;head&gt;</code> 中，JavaScript 放在 <code>&lt;body&gt;</code> 底部，或使用 <code>async</code> 和 <code>defer</code> 来避免阻塞页面渲染。</li>
</ul>
</li>
<li><p><strong>利用浏览器缓存和 Service Worker</strong>：</p>
<ul>
<li><strong>缓存静态资源</strong>：通过 HTTP 头的缓存机制（如 <code>Cache-Control</code>），减少资源重复下载。</li>
<li><strong>Service Worker</strong>：利用 Service Worker 实现离线缓存，加快页面的加载速度，尤其是在 PWA（渐进式 Web 应用）中非常有用。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>浏览器的渲染进程是将 HTML、CSS 和 JavaScript 转换为可视页面的核心流程。其主要步骤包括构建 DOM 树、计算样式、布局、绘制和合成。每个步骤都涉及复杂的计算，优化这些过程能够极大地提升页面的性能和用户体验。通过了解渲染进程的细节，开发者可以针对性地减少回流和重绘、优化合成层，并有效管理资源加载，从而提升前端应用的效率和响应速度。</p>
<h2 id="GPU-进程（GPU-Process）"><a href="#GPU-进程（GPU-Process）" class="headerlink" title="GPU 进程（GPU Process）"></a>GPU 进程（GPU Process）</h2><ul>
<li><strong>处理页面的图形绘制任务</strong>，包括加速渲染 HTML、CSS 和图片，尤其是涉及到复杂的 3D 渲染、图形动画和 WebGL 的操作。</li>
<li>现代浏览器将页面的某些渲染任务交给 GPU，以提高渲染速度，尤其是在高性能动画、视频播放等场景下，GPU 的硬件加速显得尤为重要。</li>
<li>GPU 进程的引入可以降低主线程的工作负担，从而提高页面响应速度和流畅度。</li>
</ul>
<h2 id="网络进程（Network-Process）"><a href="#网络进程（Network-Process）" class="headerlink" title="网络进程（Network Process）"></a>网络进程（Network Process）</h2><ul>
<li>网络进程负责处理<strong>所有与网络相关的操作</strong>，如发送 HTTP 请求、建立 WebSocket 连接、处理下载等。</li>
<li>它负责与服务器通信，获取页面的 HTML、CSS、JavaScript、图片等资源，并将这些资源传递给渲染进程进行处理。</li>
<li>网络进程通过处理浏览器的缓存、Cookie、跨域请求等网络层任务，确保浏览器的请求和响应是安全且高效的。</li>
</ul>
<h2 id="插件进程（Plugin-Process）"><a href="#插件进程（Plugin-Process）" class="headerlink" title="插件进程（Plugin Process）"></a>插件进程（Plugin Process）</h2><ul>
<li>一些页面可能使用外部插件（如 Flash 等）。为了隔离插件的运行，浏览器为插件分配了独立的进程。</li>
<li>插件进程与渲染进程独立分离，保证即使插件崩溃，也不会影响到浏览器的稳定性。</li>
<li>由于插件已经逐渐被 Web 标准（如 HTML5）取代，浏览器中插件进程的使用越来越少。</li>
</ul>
<h2 id="存储进程或数据持久化进程（Storage-Process）"><a href="#存储进程或数据持久化进程（Storage-Process）" class="headerlink" title="存储进程或数据持久化进程（Storage Process）"></a>存储进程或数据持久化进程（Storage Process）</h2><ul>
<li>某些浏览器会单独划分一个进程来处理数据存储和持久化操作。</li>
<li>负责管理 LocalStorage、IndexedDB、SessionStorage、Service Worker 缓存等浏览器端的数据存储，确保数据的持久化和隔离性。</li>
<li>提供数据的安全性和完整性，避免页面之间的数据泄漏。</li>
</ul>
<h2 id="音频进程（Audio-Process）"><a href="#音频进程（Audio-Process）" class="headerlink" title="音频进程（Audio Process）"></a>音频进程（Audio Process）</h2><p>专门处理与音频播放相关的任务。通过独立的进程管理，可以提高音频的稳定性，并减少主线程的工作量，防止在页面卡顿或崩溃时影响音频播放。</p>
<h2 id="沙盒进程（Sandboxed-Process）"><a href="#沙盒进程（Sandboxed-Process）" class="headerlink" title="沙盒进程（Sandboxed Process）"></a>沙盒进程（Sandboxed Process）</h2><ul>
<li>渲染进程、插件进程等都运行在沙盒模式下，沙盒进程限制了进程对操作系统资源（如文件系统、网络等）的直接访问。</li>
<li>这种隔离机制可以防止恶意代码通过网页或插件攻击系统，提升浏览器的整体安全性。</li>
</ul>
<h2 id="扩展进程（Extensions-Process）"><a href="#扩展进程（Extensions-Process）" class="headerlink" title="扩展进程（Extensions Process）"></a>扩展进程（Extensions Process）</h2><ul>
<li>扩展进程用于处理安装在浏览器中的扩展程序（如 Chrome 扩展）。</li>
<li>每个扩展可能会运行在独立的进程中，确保扩展程序的崩溃或错误不会影响浏览器的主进程或其他扩展程序。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>现代浏览器的多进程架构通过将不同的任务分配给不同的进程来提高<strong>性能、稳定性和安全性</strong>。每个进程都有自己的职责，并且相互隔离，防止单个进程的错误影响整个浏览器的运行。这种架构使得浏览器可以在处理复杂任务（如页面渲染、网络请求、扩展管理等）的同时保持高效、稳定的运行。</p>
<h3 id="常见的浏览器进程包括："><a href="#常见的浏览器进程包括：" class="headerlink" title="常见的浏览器进程包括："></a>常见的浏览器进程包括：</h3><ol>
<li><strong>浏览器主进程</strong>：管理 UI、标签页、浏览器窗口。</li>
<li><strong>渲染进程</strong>：解析 HTML、CSS、JavaScript，处理页面渲染。</li>
<li><strong>GPU 进程</strong>：加速页面的图形绘制任务。</li>
<li><strong>网络进程</strong>：处理所有网络请求和响应。</li>
<li><strong>插件进程</strong>：管理页面中使用的外部插件。</li>
<li><strong>存储进程</strong>：负责浏览器数据的持久化和安全存储。</li>
<li><strong>音频进程</strong>：处理音频的播放。</li>
<li><strong>沙盒进程</strong>：隔离渲染和插件进程，提升安全性。</li>
<li><strong>扩展进程</strong>：管理浏览器扩展程序的运行。</li>
</ol>
<p>这套架构确保了浏览器的安全、流畅和高效的操作，尤其是在处理复杂的现代 Web 应用时。</p>
<h1 id="GC垃圾回收机制"><a href="#GC垃圾回收机制" class="headerlink" title="GC垃圾回收机制"></a>GC垃圾回收机制</h1><p><strong>垃圾回收机制（Garbage Collection，GC）</strong> 是编程语言（包括 JavaScript）中的一项自动化内存管理功能，它的主要目的是自动释放那些不再被使用的内存，防止内存泄漏并优化内存的使用效率。在 JavaScript 中，开发者不需要手动管理内存分配和释放，浏览器的 JavaScript 引擎会自动进行内存回收操作。</p>
<h2 id="垃圾回收的基本概念"><a href="#垃圾回收的基本概念" class="headerlink" title="垃圾回收的基本概念"></a>垃圾回收的基本概念</h2><ol>
<li><strong>内存分配</strong>：在 JavaScript 中，当创建变量、对象、数组、函数等时，JavaScript 引擎会为它们分配内存。这种内存分配是在<strong>堆（heap）</strong>内存中进行的。</li>
<li><strong>内存使用</strong>：当执行程序代码时，分配的内存用于存储数据（如对象、数组、函数等），这些数据会被程序访问和操作。</li>
<li><strong>内存释放</strong>：当程序中不再需要某些数据时（如变量超出作用域），这些内存就应该被释放，以便后续的代码可以重复使用这些内存空间。这是垃圾回收的核心任务。</li>
</ol>
<h2 id="可达性（Reachability）概念"><a href="#可达性（Reachability）概念" class="headerlink" title="可达性（Reachability）概念"></a>可达性（Reachability）概念</h2><p>JavaScript 的垃圾回收机制基于<strong>可达性分析</strong>。具体的思想是，如果一个对象可以从<strong>根</strong>（root）出发被访问到，则该对象是可达的，并且不会被回收。相反，如果一个对象不可达，那么它就是“垃圾”，将被回收。</p>
<ul>
<li><strong>根对象</strong>：在 JavaScript 中，根对象通常是全局对象（在浏览器中是 <code>window</code> 对象）以及执行栈中的所有局部变量。</li>
<li><strong>可达对象</strong>：任何从根对象出发、通过引用链能够访问到的对象都是可达的，不会被回收。</li>
<li><strong>不可达对象</strong>：如果一个对象没有被任何引用，或者它不能从根对象访问到，那么该对象就是不可达的，会被标记为垃圾，最终被垃圾回收器回收。</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>JavaScript 引擎（如 V8 引擎）使用了多种垃圾回收算法。以下是两种最常见的垃圾回收算法：</p>
<h3 id="标记清除算法（Mark-and-Sweep）"><a href="#标记清除算法（Mark-and-Sweep）" class="headerlink" title="标记清除算法（Mark and Sweep）"></a>标记清除算法（Mark and Sweep）</h3><p>这是最经典的垃圾回收算法，也是 JavaScript 中最基础的回收机制。它的基本原理是：</p>
<ul>
<li><strong>标记阶段</strong>：从根对象出发，遍历所有可以访问到的对象，并做标记。所有被标记的对象都表示它们是可达的。</li>
<li><strong>清除阶段</strong>：那些没有被标记的对象被认为是不可达的，因此会被垃圾回收器清除，释放它们所占用的内存。</li>
</ul>
<p>标记清除算法的执行流程如下：</p>
<ol>
<li>垃圾回收器会从根对象（例如全局对象、当前执行上下文中的局部变量等）开始，遍历并标记所有能访问到的对象。</li>
<li>之后，垃圾回收器会检查堆中的其他对象，如果某个对象没有被标记，则表示它已经不可达，可以被清除。</li>
<li>垃圾回收器会释放这些不可达对象所占用的内存。</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li>实现简单，能够高效地回收不再使用的对象。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>停止-世界</strong>（Stop-The-World）：在标记清除过程中，JavaScript 的执行会暂停，可能导致应用在某些时候出现短暂的卡顿，特别是在处理大量对象时。</li>
</ul>
<h3 id="标记整理算法（Mark-and-Compact）"><a href="#标记整理算法（Mark-and-Compact）" class="headerlink" title="标记整理算法（Mark and Compact）"></a>标记整理算法（Mark and Compact）</h3><p>标记整理算法是标记清除算法的改进版本，解决了标记清除算法可能导致的内存碎片问题。</p>
<p><strong>执行步骤</strong>：</p>
<ol>
<li><strong>标记</strong>：和标记清除算法一样，从根对象出发，标记所有可达的对象。</li>
<li><strong>整理</strong>：将所有存活的对象向内存的一端移动，保持内存空间的连续性，避免内存碎片。</li>
<li><strong>清除</strong>：清除没有被标记的对象，并释放内存。</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li>解决了标记清除算法中可能产生的内存碎片问题，整理后内存更加紧凑。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>相比标记清除算法，移动对象会带来额外的性能开销。</li>
</ul>
<h3 id="分代回收算法（Generational-Garbage-Collection）"><a href="#分代回收算法（Generational-Garbage-Collection）" class="headerlink" title="分代回收算法（Generational Garbage Collection）"></a>分代回收算法（Generational Garbage Collection）</h3><p>现代 JavaScript 引擎（如 V8）采用了<strong>分代回收算法</strong>，这种算法将内存分为不同的“代”，分别管理生命周期不同的对象。通常分为<strong>新生代</strong>和<strong>老生代</strong>：</p>
<ul>
<li><strong>新生代</strong>：存储生命周期较短的对象（如函数中的局部变量、临时对象等）。这些对象通常很快就会变得不可达，因此垃圾回收器会频繁检查新生代对象。<ul>
<li><strong>From 空间</strong>：一个正在使用的内存区域，存放新分配的对象。</li>
<li><strong>To 空间</strong>：另一个备用的内存区域，用于在垃圾回收时存放存活的对象。</li>
</ul>
</li>
<li><strong>老生代</strong>：老生代用于存储生命周期较长的对象。这些对象通常已经在新生代经过了多次垃圾回收后仍然存活，因此被移动到老生代中。相比新生代，老生代的垃圾回收频率要低得多，但每次回收的成本较高，因为存活的对象较多，回收的时间较长。</li>
</ul>
<p><strong>工作原理</strong>：</p>
<ol>
<li>当一个对象首次分配时，它会被存放在新生代区域。</li>
<li>新生代区域的回收操作非常频繁，使用的是<strong>复制算法</strong>（Scavenge）。即当垃圾回收器运行时，它会将存活的对象复制到一个新的区域，并清除所有未被复制的对象。</li>
<li>如果一个对象在新生代区域存活足够长的时间，它会被移到老生代区域，减少其回收频率。</li>
<li>老生代区域的垃圾回收使用<strong>标记清除</strong>或<strong>标记整理</strong>算法。</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li>对生命周期较短的对象回收效率高，减少整体的垃圾回收开销。</li>
<li>避免了频繁回收老生代对象的高成本操作。</li>
</ul>
<h2 id="常见的内存泄漏场景"><a href="#常见的内存泄漏场景" class="headerlink" title="常见的内存泄漏场景"></a>常见的内存泄漏场景</h2><p>尽管 JavaScript 有自动的垃圾回收机制，但在一些情况下，内存泄漏依然会发生。以下是一些常见的内存泄漏场景：</p>
<h3 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h3><p>如果忘记使用 <code>var</code>、<code>let</code> 或 <code>const</code> 声明变量，JavaScript 会自动将它添加为全局对象的属性。这些全局变量无法被垃圾回收器释放，导致内存泄漏。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">leak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 应该使用 let、var 或 const 声明</span></span><br><span class="line">    globalVar = <span class="string">&quot;This is a global variable&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="闭包导致的内存泄漏"><a href="#闭包导致的内存泄漏" class="headerlink" title="闭包导致的内存泄漏"></a>闭包导致的内存泄漏</h3><p>JavaScript 的闭包会捕获外部函数的变量。如果不当使用闭包，可能导致外部作用域中的变量无法被释放。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> largeArray = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(largeArray);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> innerFunc = <span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure>
<p><code>largeArray</code> 无法被释放，因为它被 <code>inner</code> 函数引用。</p>
<h3 id="DOM-引用未释放"><a href="#DOM-引用未释放" class="headerlink" title="DOM 引用未释放"></a>DOM 引用未释放</h3><p>如果 JavaScript 中的变量仍然引用着已经从 DOM 中移除的元素，这些元素将无法被垃圾回收器回收，导致内存泄漏。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myElement&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(elem);  <span class="comment">// 删除 DOM 元素，但 elem 变量仍引用着它</span></span><br></pre></td></tr></table></figure>

<h3 id="事件监听器未清除"><a href="#事件监听器未清除" class="headerlink" title="事件监听器未清除"></a>事件监听器未清除</h3><p>当给 DOM 元素添加事件监听器时，如果忘记移除它们，哪怕 DOM 元素已经被移除，监听器的引用仍然存在，导致内存泄漏。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Button clicked&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 button 被移除时，监听器还在占用内存</span></span><br></pre></td></tr></table></figure>

<h3 id="被遗忘的定时器或回调"><a href="#被遗忘的定时器或回调" class="headerlink" title="被遗忘的定时器或回调"></a>被遗忘的定时器或回调</h3><p>未清除的定时器或异步回调也会导致内存泄漏。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">leak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Leaking memory&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使 <code>leak()</code> 执行完毕，<code>setInterval</code> 仍然会继续运行，占用内存。</p>
<h2 id="垃圾回收的优化建议"><a href="#垃圾回收的优化建议" class="headerlink" title="垃圾回收的优化建议"></a>垃圾回收的优化建议</h2><ol>
<li><strong>减少不必要的全局变量</strong>：尽量避免使用全局变量，尤其是存放大量数据的变量。</li>
<li><strong>及时清理不再使用的 DOM 引用</strong>：当元素被移除时，确保 JavaScript 中不再保留对这些元素的引用。</li>
<li><strong>正确移除事件监听器</strong>：当 DOM 元素不再需要时</li>
</ol>
<p>，使用 <code>removeEventListener</code> 来清除事件监听器。<br>4. <strong>合理使用闭包</strong>：尽量避免不必要的闭包引用，防止捕获的外部变量无法被回收。<br>5. <strong>清理定时器和回调</strong>：确保 <code>setInterval</code> 和 <code>setTimeout</code> 被及时清理，尤其是页面或组件卸载时。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 的垃圾回收机制大大简化了开发者的内存管理工作，但了解其原理和常见的内存泄漏场景，对于编写高效、内存优化的代码是非常重要的。通过避免内存泄漏、正确处理对象引用，可以帮助应用程序在复杂的前端环境中保持良好的性能。</p>
<h1 id="浏览器安全机制"><a href="#浏览器安全机制" class="headerlink" title="浏览器安全机制"></a>浏览器安全机制</h1><h1 id="跨域及解决方法"><a href="#跨域及解决方法" class="headerlink" title="跨域及解决方法"></a>跨域及解决方法</h1><p>同源策略是浏览器的安全机制，用于防止不同来源的文档或脚本相互访问。根据同源策略，只有当两个资源的协议、端口和域名完全相同时，才能相互访问。</p>
<h2 id="同源策略的组成部分"><a href="#同源策略的组成部分" class="headerlink" title="同源策略的组成部分"></a>同源策略的组成部分</h2><ol>
<li><strong>协议</strong>：指的是用于访问资源的协议，如HTTP或HTTPS。只有当两个资源使用相同的协议时，才会被认为是同源的。</li>
<li><strong>域名</strong>：指的是资源所在的主机名或IP地址。如果两个资源的域名不同，则它们不被视为同源。例如，<code>example.com</code>与<code>sub.example.com</code>是不同的域名。</li>
<li><strong>端口</strong>：指的是用于访问资源的网络端口。默认情况下，HTTP使用80端口，HTTPS使用443端口。如果两个资源使用不同的端口，即使协议和域名相同，它们也不被视为同源。</li>
</ol>
<h2 id="CORS（跨域资源共享）"><a href="#CORS（跨域资源共享）" class="headerlink" title="CORS（跨域资源共享）"></a>CORS（跨域资源共享）</h2><p><strong>CORS</strong> 是一种 W3C 标准，允许服务器声明哪些来源（域、协议、端口）有权限访问它的资源。浏览器会根据服务器返回的响应头决定是否允许客户端跨域请求。服务器通过在响应头中设置 <code>Access-Control-Allow-Origin</code> 来指定允许哪些域访问资源，浏览器根据这个头信息决定是否允许跨域请求。</p>
<ul>
<li>服务器端设置 <code>Access-Control-Allow-Origin</code> 响应头。</li>
<li>服务器可以选择允许特定域，或者通过设置 <code>*</code> 来允许所有域进行跨域请求。</li>
</ul>
<p><strong>使用场景</strong>：现代前后端分离的项目中，常用的跨域方案，适用于不同源之间的数据请求。</p>
<ul>
<li><strong>优点</strong>：支持多种 HTTP 方法（GET、POST、PUT、DELETE 等），灵活配置。</li>
<li><strong>缺点</strong>：需要服务器端支持，配置复杂性可能较高，预检请求会增加请求开销。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Express.js 中设置 CORS</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);  <span class="comment">// 允许所有域名</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;GET,POST,PUT,DELETE&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type&#x27;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="JSONP（JSON-with-Padding）"><a href="#JSONP（JSON-with-Padding）" class="headerlink" title="JSONP（JSON with Padding）"></a>JSONP（JSON with Padding）</h2><p><strong>JSONP</strong> 是一种传统的跨域解决方案，依赖 <code>&lt;script&gt;</code> 标签的特性。<code>&lt;script&gt;</code> 标签可以跨域加载 JavaScript 文件，JSONP 通过服务器返回包含 JavaScript 函数调用的 JSON 数据来实现跨域。</p>
<ul>
<li><p>前端创建一个 <code>&lt;script&gt;</code> 标签，发起请求，并指定回调函数的名称。</p>
</li>
<li><p>服务器返回的数据格式为 <code>callback(data)</code>，其中 <code>callback</code> 是前端定义的回调函数。</p>
</li>
<li><p><strong>优点</strong>：简单易用，兼容性好，支持老式浏览器。</p>
</li>
<li><p><strong>缺点</strong>：只支持 GET 请求，不支持 POST、PUT、DELETE 等其他 HTTP 方法，容易受到 XSS 攻击风险。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received data:&#x27;</span>, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = <span class="string">&#x27;http://example.com/api?callback=handleResponse&#x27;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>服务器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设服务器返回的数据为： handleResponse(&#123;&quot;message&quot;: &quot;Hello, World!&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="服务器代理（Server-Side-Proxy）"><a href="#服务器代理（Server-Side-Proxy）" class="headerlink" title="服务器代理（Server-Side Proxy）"></a>服务器代理（Server-Side Proxy）</h2><p><strong>原理</strong>：通过在<strong>服务器端</strong>设置代理，将跨域请求转发给目标服务器。浏览器对服务器是同源的，而服务器与目标服务器之间没有跨域限制，这样可以实现跨域请求。</p>
<ul>
<li><strong>优点</strong>：支持各种 HTTP 方法，可以实现复杂的跨域请求，并且服务器端可以处理更多的逻辑（如缓存、验证）。</li>
<li><strong>缺点</strong>：需要额外的服务器配置，增加了服务器的工作负担，增加了请求的中间层，可能会增加延迟。</li>
</ul>
<p>前端请求服务器代理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/proxy?url=http://example.com/api&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));</span><br></pre></td></tr></table></figure>

<p>服务器代理实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>); <span class="comment">// 代理请求的库</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/proxy&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.<span class="property">query</span>.<span class="property">url</span>;</span><br><span class="line">  <span class="title function_">request</span>(url).<span class="title function_">pipe</span>(res); <span class="comment">// 将目标URL的数据返回给客户端</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Proxy server listening on port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="PostMessage（窗口消息传递）"><a href="#PostMessage（窗口消息传递）" class="headerlink" title="PostMessage（窗口消息传递）"></a>PostMessage（窗口消息传递）</h2><p><strong>原理</strong>： <code>postMessage</code> 是一种安全的跨源通信方式，适用于在不同窗口（如 iframe 或 pop-up 窗口）之间传递消息。通过它可以在父窗口和嵌套的 iframe 之间实现跨域通信。</p>
<p><strong>使用场景</strong>：  常用于 iframe 内部与父窗口之间的通信，或跨域窗口之间的数据交换。 </p>
<ul>
<li><p>父窗口通过 <code>postMessage</code> 发送消息给 iframe。</p>
</li>
<li><p>iframe 监听 <code>message</code> 事件，并根据消息内容执行操作。</p>
</li>
<li><p><strong>优点</strong>：安全、可靠，适合在嵌套页面、不同窗口之间传递消息。</p>
</li>
<li><p><strong>缺点</strong>：只能用于页面与页面之间的消息传递，不能直接获取跨域资源。</p>
</li>
</ul>
<p>父窗口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>);</span><br><span class="line">iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from parent&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>iframe页面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">origin</span> === <span class="string">&#x27;http://yourdomain.com&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from parent:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>原理</strong>：<strong>WebSocket</strong> 是一种持久化的全双工通信协议，它在创建连接时只需要通过一次握手（<code>HTTP</code>），此后就不再受同源策略的限制，可以跨域进行通信。适用于需要实时通信的应用，如聊天室、游戏等。</p>
<p><strong>使用场景</strong>：适用于需要实时通信的应用，如即时聊天、在线游戏、股票行情推送等。</p>
<ul>
<li><strong>优点</strong>：支持双向通信，适合实时数据传输。</li>
<li><strong>缺点</strong>：协议较复杂，服务器需要支持 WebSocket，可能涉及额外的配置。</li>
</ul>
<p>前端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://example.com/socket&#x27;</span>);</span><br><span class="line"></span><br><span class="line">socket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection opened&#x27;</span>);</span><br><span class="line">  socket.<span class="title function_">send</span>(<span class="string">&#x27;Hello Server&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from server: &#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span> = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">ws</span> =&gt;</span> &#123;</span><br><span class="line">  ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received:&#x27;</span>, message);</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;Hello from server&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="跨域资源嵌入（Cross-Origin-Resource-Embedding）"><a href="#跨域资源嵌入（Cross-Origin-Resource-Embedding）" class="headerlink" title="跨域资源嵌入（Cross-Origin Resource Embedding）"></a>跨域资源嵌入（Cross-Origin Resource Embedding）</h2><p><strong>原理</strong>：某些 HTML 标签如 <code>&lt;img&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code> 和 <code>&lt;iframe&gt;</code> 等不受同源策略限制，可以跨域加载资源。</p>
<p><strong>使用场景</strong>：用来跨域加载图片、JS 文件、CSS 文件、或者嵌入第三方页面。</p>
<ul>
<li><strong>优点</strong>：简单直接，不需要额外配置，可以轻松加载跨域的静态资源。</li>
<li><strong>缺点</strong>：无法获取资源内容（如 <code>&lt;img&gt;</code> 无法获取图片的二进制数据），不能用于复杂的双向通信。</li>
</ul>
<h2 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h2><p>通过 Nginx 的反向代理功能，可以将请求转发到目标服务器，从而解决跨域问题。与服务器端代理类似，但使用 Nginx 可以减少后端服务的开发负担。</p>
<ul>
<li>配置 Nginx，将来自前端的请求代理到目标服务器。</li>
<li>Nginx 作为前端和目标服务器的中间层。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name yourdomain.<span class="property">com</span>;</span><br><span class="line"></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">        proxy_pass <span class="attr">http</span>:<span class="comment">//targetserver.com/api/;</span></span><br><span class="line">        proxy_set_header <span class="title class_">Host</span> $host;</span><br><span class="line">        proxy_set_header X-<span class="title class_">Real</span>-<span class="variable constant_">IP</span> $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置会将 <code>/api/</code> 前缀的请求代理到 <code>http://targetserver.com/api/</code>。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>性能高效，Nginx 处理大量并发请求非常高效。</li>
<li>反向代理和负载均衡可以同时进行。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>需要额外的服务器配置和运维支持。</li>
<li>只适合在有 Nginx 服务器的项目中使用。</li>
</ul>
<h2 id="WebRTC（Web-Real-Time-Communication）"><a href="#WebRTC（Web-Real-Time-Communication）" class="headerlink" title="WebRTC（Web Real-Time Communication）"></a>WebRTC（Web Real-Time Communication）</h2><p><strong>原理</strong>：<br>WebRTC 是一种点对点的实时通信技术，允许浏览器之间或浏览器与服务器之间进行直接的音视频、数据传输，不需要经过中间服务器。</p>
<p><strong>使用场景</strong>：<br>适用于需要高效的点对点通信场景，如音视频通话、文件传输等。</p>
<ul>
<li><strong>优点</strong>：支持高效的点对点通信，适合实时数据传输。</li>
<li><strong>缺点</strong>：实现较为复杂，涉及网络穿透和信令服务器等问题。</li>
</ul>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h2><table>
<thead>
<tr>
<th><strong>跨域方法</strong></th>
<th><strong>原理</strong></th>
<th><strong>使用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>CORS</strong></td>
<td>通过 <code>Access-Control-Allow-Origin</code> 设置跨域访问控制</td>
<td>前后端分离、API 调用</td>
<td>支持多种 HTTP 方法，灵活</td>
<td>需要服务器配置，预检请求有额外开销</td>
</tr>
<tr>
<td><strong>JSONP</strong></td>
<td>利用 <code>&lt;script&gt;</code> 标签跨域加载 JavaScript</td>
<td>早期 GET 请求的跨域场景</td>
<td>简单易用，兼容性好</td>
<td>只支持 GET，易受 XSS 攻击</td>
</tr>
<tr>
<td><strong>服务器代理</strong></td>
<td>本地服务器代理请求转发</td>
<td>跨域访问第三方 API</td>
<td>支持各种 HTTP 方法，安全性高</td>
<td>需要额外服务器配置，增加服务器负担</td>
</tr>
<tr>
<td><strong>PostMessage</strong></td>
<td>使用 <code>window.postMessage</code> 在不同窗口、iframe 之间传递消息</td>
<td>iframe 与父页面通信</td>
<td>安全可靠，适合页面间数据传递</td>
<td>只能用于页面间通信，无法直接获取跨域资源</td>
</tr>
<tr>
<td><strong>WebSocket</strong></td>
<td>全双工通信协议，不受同源策略限制</td>
<td>实时通信，如聊天、游戏</td>
<td>支持双向通信，适合实时数据</td>
<td>实现复杂，需服务器支持</td>
</tr>
<tr>
<td><strong>跨域资源嵌入</strong></td>
<td>通过 <code>&lt;img&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code> 等标签跨域加载静态资源</td>
<td>加载静态资源，如图片、JS 文件</td>
<td>简单直接</td>
<td>无法获取资源内容，不能用于双向通信</td>
</tr>
<tr>
<td><strong>WebRTC</strong></td>
<td>通过点对点连接直接传输音视频和数据</td>
<td>实时音视频、文件传输</td>
<td>高效的点对点通信，适合实时传输</td>
<td>实现复杂，涉及网络穿透、信令等问题</td>
</tr>
</tbody></table>
<h1 id="浏览器相关事件总结"><a href="#浏览器相关事件总结" class="headerlink" title="浏览器相关事件总结"></a>浏览器相关事件总结</h1><p>浏览器事件是 JavaScript 与用户和浏览器交互的重要机制。它们根据不同的功能和触发条件分为多种类型，包括页面加载、用户交互、键盘与鼠标事件、剪贴板事件等。</p>
<p>以下是浏览器常见的事件类型及其用途。</p>
<h2 id="页面生命周期事件"><a href="#页面生命周期事件" class="headerlink" title="页面生命周期事件"></a>页面生命周期事件</h2><h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a><code>DOMContentLoaded</code></h3><ul>
<li><strong>触发对象</strong>：<code>document</code></li>
<li><strong>触发时机</strong>：当 <strong>HTML 被解析完毕</strong>，DOM 树构建完成后触发，但不等待图片、CSS 等资源加载。</li>
<li><strong>用途</strong>：用于确保 DOM 可操作。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM 已加载完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="load"><a href="#load" class="headerlink" title="load"></a><code>load</code></h3><ul>
<li><strong>触发对象</strong>：<code>window</code></li>
<li><strong>触发时机</strong>：当页面<strong>所有资源（HTML、CSS、图片等）加载完成</strong>后触发。</li>
<li><strong>用途</strong>：需要等待所有资源加载完毕再执行的逻辑。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;页面所有资源加载完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="beforeunload"><a href="#beforeunload" class="headerlink" title="beforeunload"></a><code>beforeunload</code></h3><ul>
<li><strong>触发对象</strong>：<code>window</code></li>
<li><strong>触发时机</strong>：当用户即将离开页面时触发。</li>
<li><strong>用途</strong>：提示用户页面未保存的修改，或处理数据。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  event.<span class="property">returnValue</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 现代浏览器必须设置 returnValue 以触发提示</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="unload"><a href="#unload" class="headerlink" title="unload"></a><code>unload</code></h3><ul>
<li><strong>触发对象</strong>：<code>window</code></li>
<li><strong>触发时机</strong>：当页面即将卸载时触发。</li>
<li><strong>用途</strong>：清理资源、记录数据。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unload&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;页面已卸载&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="用户交互事件"><a href="#用户交互事件" class="headerlink" title="用户交互事件"></a>用户交互事件</h2><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul>
<li><code>click</code>：鼠标点击</li>
<li><code>dblclick</code>：双击</li>
<li><code>mousedown</code>：按下鼠标键</li>
<li><code>mouseup</code>：释放鼠标键</li>
<li><code>mousemove</code>：鼠标移动</li>
<li><code>mouseenter</code> &#x2F; <code>mouseleave</code>：鼠标进入&#x2F;离开元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;页面被点击&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul>
<li><code>keydown</code>：按下键盘键</li>
<li><code>keypress</code>：按下字符键（已废弃）</li>
<li><code>keyup</code>：释放键盘键</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`按下了键：<span class="subst">$&#123;event.key&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><ul>
<li><code>focus</code>：元素获得焦点</li>
<li><code>blur</code>：元素失去焦点</li>
<li><code>focusin</code> &#x2F; <code>focusout</code>：与 <code>focus</code> &#x2F; <code>blur</code> 类似，但支持事件冒泡</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;focus&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;输入框获得焦点&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h2><ul>
<li><code>copy</code>：复制</li>
<li><code>cut</code>：剪切</li>
<li><code>paste</code>：粘贴</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;copy&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文本已复制&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h2><ul>
<li><code>submit</code>：表单提交</li>
<li><code>input</code>：输入框内容变化</li>
<li><code>change</code>：表单元素的值改变（如 <code>&lt;select&gt;</code>）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>(); <span class="comment">// 阻止默认提交</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;表单提交&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="网络与连接事件"><a href="#网络与连接事件" class="headerlink" title="网络与连接事件"></a>网络与连接事件</h2><h3 id="online-x2F-offline"><a href="#online-x2F-offline" class="headerlink" title="online &#x2F; offline"></a><code>online</code> &#x2F; <code>offline</code></h3><ul>
<li><strong>触发对象</strong>：<code>window</code></li>
<li><strong>触发时机</strong>：当网络连接状态变化时触发。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;online&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;网络已连接&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;offline&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;网络已断开&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="fetch-事件（Service-Worker）"><a href="#fetch-事件（Service-Worker）" class="headerlink" title="fetch 事件（Service Worker）"></a><code>fetch</code> 事件（Service Worker）</h3><ul>
<li><strong>触发对象</strong>：Service Worker</li>
<li><strong>触发时机</strong>：捕获网络请求时触发。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到网络请求&#x27;</span>, event.<span class="property">request</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="滚动与窗口事件"><a href="#滚动与窗口事件" class="headerlink" title="滚动与窗口事件"></a>滚动与窗口事件</h2><h3 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a><code>scroll</code></h3><ul>
<li><strong>触发对象</strong>：<code>window</code> 或滚动的元素</li>
<li><strong>触发时机</strong>：当页面或元素滚动时触发。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;页面滚动&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a><code>resize</code></h3><ul>
<li><strong>触发对象</strong>：<code>window</code></li>
<li><strong>触发时机</strong>：当窗口大小变化时触发。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;窗口大小改变&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a><code>IntersectionObserver</code></h3><p><code>IntersectionObserver</code> 是一种 <strong>异步 API</strong>，用于检测一个元素是否进入视口（Viewport）或与另一个元素相交。它常用于<strong>懒加载图片</strong>、<strong>无限滚动列表</strong>、<strong>统计曝光率</strong>等场景。</p>
<p><code>IntersectionObserver</code> 是一种高效、非阻塞的 API，可以让我们轻松检测元素是否进入视口，非常适合懒加载、滚动监听、曝光统计等场景。相比传统的事件监听（如 <code>scroll</code> 事件），它具有<strong>性能更高</strong>、<strong>代码更简洁</strong>等优点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;entry.target.textContent&#125;</span> 进入视口`</span>);</span><br><span class="line">      observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>); <span class="comment">// 停止观察（可选）</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">box</span> =&gt;</span> observer.<span class="title function_">observe</span>(box));</span><br></pre></td></tr></table></figure>



<h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a><code>MutationObserver</code></h3><p><strong><code>MutationObserver</code></strong> 是一个 <strong>浏览器 API</strong>，用于<strong>监听 DOM 树的变化</strong>。当页面的 DOM 元素<strong>发生增删、修改</strong>或<strong>属性变化</strong>时，<code>MutationObserver</code> 可以捕获这些变化并执行自定义的回调逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">mutationsList</span>) =&gt;</span> &#123;</span><br><span class="line">  mutationsList.<span class="title function_">forEach</span>(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutation.<span class="property">type</span> === <span class="string">&#x27;childList&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子元素发生了变化&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutation.<span class="property">type</span> === <span class="string">&#x27;attributes&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`属性 <span class="subst">$&#123;mutation.attributeName&#125;</span> 被修改`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target&#x27;</span>); <span class="comment">// 要监控的节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;; <span class="comment">// 配置选项</span></span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(targetNode, config); <span class="comment">// 开始观察</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> observer.<span class="title function_">disconnect</span>(), <span class="number">5000</span>); <span class="comment">// 5秒后停止观察（可选）</span></span><br></pre></td></tr></table></figure>

<h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><ul>
<li><code>progress</code>：下载或上传的进度更新</li>
<li><code>loadstart</code>：请求开始</li>
<li><code>loadend</code>：请求结束</li>
<li><code>error</code>：请求错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>);</span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`已加载 <span class="subst">$&#123;event.loaded&#125;</span> 字节`</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<h2 id="任务调度事件"><a href="#任务调度事件" class="headerlink" title="任务调度事件"></a>任务调度事件</h2><ul>
<li>requestIdleCallback：在浏览器空闲时执行回调，用于非关键任务。  </li>
<li>cancelIdleCallback：取消先前通过 requestIdleCallback 请求的任务。  </li>
<li>setTimeout、setInterval：延迟执行代码或按指定间隔重复执行代码。</li>
</ul>
<h2 id="动画与过渡事件"><a href="#动画与过渡事件" class="headerlink" title="动画与过渡事件"></a>动画与过渡事件</h2><ul>
<li><code>transitionend</code>：CSS 过渡结束</li>
<li><code>animationstart</code> &#x2F; <code>animationend</code> &#x2F; <code>animationiteration</code>：动画的不同阶段触发</li>
<li><code>requestAnimationFrame</code>：在浏览器重绘前执行回调函数，用于高效动画绘制。  </li>
<li><code>cancelAnimationFrame</code>：取消先前通过 requestAnimationFrame 请求的动画帧。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;transitionend&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;过渡结束&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>开发者可以<strong>自定义事件</strong>并在代码中手动触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> customEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;myCustomEvent&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;myCustomEvent&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;自定义事件触发&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(customEvent);</span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>浏览器提供了多种事件，帮助开发者处理页面加载、用户交互、网络请求等场景。</p>
<ol>
<li><strong>页面生命周期事件</strong>：<code>DOMContentLoaded</code>、<code>load</code>、<code>beforeunload</code></li>
<li><strong>用户交互事件</strong>：<code>click</code>、<code>keydown</code>、<code>focus</code></li>
<li><strong>表单与剪贴板事件</strong>：<code>submit</code>、<code>input</code>、<code>copy</code></li>
<li><strong>网络事件</strong>：<code>online</code>、<code>offline</code>、<code>fetch</code></li>
<li><strong>滚动与窗口事件</strong>：<code>scroll</code>、<code>resize</code></li>
<li><strong>动画与进度事件</strong>：<code>transitionend</code>、<code>progress</code></li>
<li><strong>自定义事件</strong>：<code>new Event()</code></li>
</ol>
<h1 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h1><p><strong>事件委托</strong>（Event Delegation）和 <strong>事件代理</strong>（Event Delegation）实际上是同一个概念，指的是<strong>通过父元素来统一处理子元素上的事件</strong>。这利用了浏览器的事件冒泡机制，将事件绑定在父元素上，而不是在每个子元素上都单独绑定事件处理器。</p>
<ul>
<li><strong>事件委托的原理</strong>：当子元素触发事件时，事件会冒泡到父元素，父元素通过事件处理器捕获事件，并通过事件对象的 <code>target</code> 属性判断是哪一个子元素触发了事件，从而执行相应的逻辑。</li>
<li><strong>优点</strong>：<ul>
<li>减少内存占用：不需要为每个子元素单独绑定事件，事件处理器只绑定在父元素上。</li>
<li>动态元素处理：即使子元素是动态添加的，父元素的事件处理器依然能够响应，不需要重新绑定事件。</li>
</ul>
</li>
</ul>
<h2 id="如何实现事件委托"><a href="#如何实现事件委托" class="headerlink" title="如何实现事件委托"></a>如何实现事件委托</h2><h4 id="示例：使用事件委托处理多个子元素的点击事件"><a href="#示例：使用事件委托处理多个子元素的点击事件" class="headerlink" title="示例：使用事件委托处理多个子元素的点击事件"></a>示例：使用事件委托处理多个子元素的点击事件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot; @click=&quot;handleClick&quot;&gt;</span><br><span class="line">    &lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot; :data-id=&quot;item.id&quot; class=&quot;child&quot;&gt;</span><br><span class="line">      &#123;&#123; item.name &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      items: [</span><br><span class="line">        &#123; id: 1, name: &#x27;Item 1&#x27; &#125;,</span><br><span class="line">        &#123; id: 2, name: &#x27;Item 2&#x27; &#125;,</span><br><span class="line">        &#123; id: 3, name: &#x27;Item 3&#x27; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick(event) &#123;</span><br><span class="line">      const target = event.target;</span><br><span class="line">      if (target.classList.contains(&#x27;child&#x27;)) &#123;</span><br><span class="line">        const itemId = target.getAttribute(&#x27;data-id&#x27;);</span><br><span class="line">        console.log(`Clicked on item with ID: $&#123;itemId&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.child &#123;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">  margin-bottom: 5px;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>事件委托实现</strong>：我们在父元素 <code>.parent</code> 上绑定了 <code>@click=&quot;handleClick&quot;</code>，而不是在每个 <code>.child</code> 子元素上绑定 <code>click</code> 事件。通过事件冒泡，父元素的 <code>handleClick</code> 方法可以捕获来自子元素的事件。</li>
<li><strong>识别子元素</strong>：在 <code>handleClick</code> 中，使用 <code>event.target</code> 来确定事件的目标元素，通过 <code>target.classList.contains(&#39;child&#39;)</code> 来判断事件是否由子元素触发。</li>
</ul>
<h2 id="只处理捕获阶段或冒泡阶段的事件"><a href="#只处理捕获阶段或冒泡阶段的事件" class="headerlink" title="只处理捕获阶段或冒泡阶段的事件"></a>只处理捕获阶段或冒泡阶段的事件</h2><p>在事件委托中，你可以选择只在<strong>捕获阶段</strong>或<strong>冒泡阶段</strong>处理事件。Vue 提供了 <strong><code>.capture</code></strong> 和 <strong>默认冒泡行为</strong>，我们可以根据需要来控制事件的传播。</p>
<h3 id="只处理捕获阶段的事件"><a href="#只处理捕获阶段的事件" class="headerlink" title="只处理捕获阶段的事件"></a>只处理捕获阶段的事件</h3><p>在 Vue 中，如果你只想在捕获阶段处理事件，可以使用 <code>.capture</code> 修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot; @click.capture=&quot;handleCaptureClick&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;Click Me&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleCaptureClick(event) &#123;</span><br><span class="line">      console.log(&#x27;Event captured at parent level&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>.capture</code> 修饰符</strong>：当你在 <code>@click</code> 事件后加上 <code>.capture</code>，事件会在捕获阶段触发，而不是在冒泡阶段。这样，在点击子元素时，父元素会在捕获阶段处理事件。</li>
</ul>
<h3 id="只处理冒泡阶段的事件（默认行为）"><a href="#只处理冒泡阶段的事件（默认行为）" class="headerlink" title="只处理冒泡阶段的事件（默认行为）"></a>只处理冒泡阶段的事件（默认行为）</h3><p>Vue 默认的事件绑定是<strong>冒泡阶段</strong>触发的。如果你不添加 <code>.capture</code>，事件处理器就会在冒泡阶段执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot; @click=&quot;handleBubbleClick&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;Click Me&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleBubbleClick(event) &#123;</span><br><span class="line">      console.log(&#x27;Event bubbled to parent&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>默认行为</strong>：在这个例子中，<code>@click</code> 会在冒泡阶段触发，因此点击子元素后，事件会冒泡到父元素并在父元素处理器中捕获。</li>
</ul>
<h2 id="阻止事件传播：阻止冒泡和阻止捕获"><a href="#阻止事件传播：阻止冒泡和阻止捕获" class="headerlink" title="阻止事件传播：阻止冒泡和阻止捕获"></a>阻止事件传播：阻止冒泡和阻止捕获</h2><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>如果你想让事件只在子元素中处理，而不冒泡到父元素，可以使用 <code>event.stopPropagation()</code>，或 Vue 的 <code>.stop</code> 修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot; @click=&quot;handleParentClick&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot; @click.stop=&quot;handleChildClick&quot;&gt;Click Me&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleParentClick() &#123;</span><br><span class="line">      console.log(&#x27;Parent clicked&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChildClick() &#123;</span><br><span class="line">      console.log(&#x27;Child clicked&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>.stop</code> 修饰符</strong>：Vue 提供了 <code>.stop</code> 修饰符，它相当于在事件处理器中调用 <code>event.stopPropagation()</code>。在这个例子中，点击子元素时只会触发 <code>handleChildClick</code>，不会冒泡到父元素。</li>
</ul>
<h4 id="4-2-阻止事件捕获"><a href="#4-2-阻止事件捕获" class="headerlink" title="4.2 阻止事件捕获"></a>4.2 <strong>阻止事件捕获</strong></h4><p>阻止事件捕获相对较少用，但你可以在捕获阶段的事件处理器中调用 <code>event.stopPropagation()</code> 来阻止事件在捕获阶段继续传播。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot; @click.capture=&quot;handleCaptureClick&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot; @click=&quot;handleChildClick&quot;&gt;Click Me&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleCaptureClick(event) &#123;</span><br><span class="line">      event.stopPropagation(); // 阻止事件捕获传播</span><br><span class="line">      console.log(&#x27;Event stopped during capture phase&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChildClick() &#123;</span><br><span class="line">      console.log(&#x27;Child clicked&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个例子中，点击子元素时，<code>handleCaptureClick</code> 会在捕获阶段阻止事件的进一步传播，因此冒泡阶段的事件（<code>handleChildClick</code>）不会被触发。</li>
</ul>
<h3 id="5-结合事件委托、捕获和冒泡的使用场景"><a href="#5-结合事件委托、捕获和冒泡的使用场景" class="headerlink" title="5. 结合事件委托、捕获和冒泡的使用场景"></a>5. <strong>结合事件委托、捕获和冒泡的使用场景</strong></h3><ul>
<li><strong>事件委托</strong>：当你有多个子元素需要处理同一类型事件时，使用事件委托可以减少内存开销和代码冗余，将事件处理器统一绑定到父元素上。</li>
<li><strong>捕获阶段处理</strong>：在某些复杂的场景下，你可能需要在事件传播到子元素之前进行处理。此时，可以使用捕获阶段的事件处理器来提前响应事件。</li>
<li><strong>冒泡阶段处理（默认）</strong>：这是大多数情况下的默认选择，适合一般的事件处理场景。</li>
<li><strong>阻止事件传播</strong>：通过阻止事件冒泡或捕获，可以精细控制事件传播链，避免不必要的事件触发。</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>事件委托（代理）</strong> 是一种优化手段，利用事件冒泡机制将子元素的事件处理统一放在父元素上处理。通过事件委托，可以减少为每个子元素绑定事件处理器的需求，提高性能。</li>
<li><strong>捕获阶段处理</strong>：使用 <code>.capture</code> 修饰符可以让事件处理器在捕获阶段执行。</li>
<li><strong>冒泡阶段处理</strong>：Vue 默认在冒泡阶段处理事件，直接使用 <code>@事件名</code> 即可。</li>
<li><strong>阻止事件传播</strong>：可以通过 <code>.stop</code> 或 <code>event.stopPropagation()</code> 来阻止事件冒泡；同样，也可以在捕获阶段调用 <code>stopPropagation()</code> 来阻止事件传播。</li>
</ol>
<p>通过这些机制，你可以灵活地控制事件的传播方式和行为，从而实现更高效、更精细的事件处理。</p>
<h2 id="1-DOMContentLoaded-事件"><a href="#1-DOMContentLoaded-事件" class="headerlink" title="1. DOMContentLoaded 事件"></a>1. <code>DOMContentLoaded</code> 事件</h2><ul>
<li><strong>类型</strong>：浏览器事件</li>
<li><strong>触发对象</strong>：<code>document</code></li>
<li><strong>触发时机</strong>：当<strong>HTML 文档被完全解析</strong>，并且<strong>DOM 树</strong>构建完成时触发。</li>
<li><strong>特点</strong>：不需要等待外部资源（如图片、CSS 文件）加载完成。</li>
</ul>
<h4 id="代码示例：监听-DOMContentLoaded-事件"><a href="#代码示例：监听-DOMContentLoaded-事件" class="headerlink" title="代码示例：监听 DOMContentLoaded 事件"></a><strong>代码示例：监听 <code>DOMContentLoaded</code> 事件</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM 已完全加载&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>用途</strong>：确保页面的<strong>DOM 结构</strong>已经加载完毕，可以安全地操作 DOM 元素，例如给按钮绑定事件监听器。</li>
</ul>
<h2 id="2-load-事件"><a href="#2-load-事件" class="headerlink" title="2. load 事件"></a><strong>2. <code>load</code> 事件</strong></h2><ul>
<li><strong>类型</strong>：浏览器事件</li>
<li><strong>触发对象</strong>：<code>window</code></li>
<li><strong>触发时机</strong>：当页面的<strong>所有资源</strong>（HTML、CSS、图片、脚本等）<strong>加载完成</strong>后触发。</li>
<li><strong>特点</strong>：会在所有资源加载完成后才触发，因此比 <code>DOMContentLoaded</code> 更晚。</li>
</ul>
<h4 id="代码示例：监听-load-事件"><a href="#代码示例：监听-load-事件" class="headerlink" title="代码示例：监听 load 事件"></a><strong>代码示例：监听 <code>load</code> 事件</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有资源加载完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>用途</strong>：适用于<strong>依赖外部资源</strong>的操作，如计算图片尺寸或执行需要所有资源加载完的逻辑。</li>
</ul>
<h2 id="3-两者的事件类型和注册方式"><a href="#3-两者的事件类型和注册方式" class="headerlink" title="3. 两者的事件类型和注册方式"></a><strong>3. 两者的事件类型和注册方式</strong></h2><table>
<thead>
<tr>
<th><strong>事件</strong></th>
<th><strong>触发对象</strong></th>
<th><strong>触发时机</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>DOMContentLoaded</code></td>
<td><code>document</code></td>
<td>HTML 完全解析，DOM 树构建完成</td>
<td>操作 DOM 元素，无需等待资源加载</td>
</tr>
<tr>
<td><code>load</code></td>
<td><code>window</code></td>
<td>所有资源（HTML、CSS、图片等）加载完成</td>
<td>需要等待页面所有资源的加载，比如图片尺寸</td>
</tr>
</tbody></table>
<h2 id="4-是什么类型的事件？"><a href="#4-是什么类型的事件？" class="headerlink" title="4. 是什么类型的事件？"></a><strong>4. 是什么类型的事件？</strong></h2><p><code>DOMContentLoaded</code> 和 <code>load</code> 都是 <strong>浏览器提供的内置事件</strong>，属于 <strong>页面生命周期事件</strong>。它们与浏览器的 <strong>事件模型（Event Model）</strong> 和 <strong>事件循环（Event Loop）</strong> 机制密切相关。</p>
<h3 id="事件流中的位置"><a href="#事件流中的位置" class="headerlink" title="事件流中的位置"></a><strong>事件流中的位置</strong></h3><ul>
<li><strong><code>DOMContentLoaded</code></strong> 和 <strong><code>load</code></strong> 是属于<strong>冒泡阶段的事件</strong>，即它们会从触发对象往上传播。</li>
<li><strong>捕获和冒泡</strong>：你可以在<strong>捕获阶段</strong>或<strong>冒泡阶段</strong>监听这些事件。</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h2><ul>
<li><strong>是浏览器的事件</strong>：<code>DOMContentLoaded</code> 和 <code>load</code> 都是浏览器提供的事件，用于帮助开发者监听<strong>页面加载的不同阶段</strong>。</li>
<li><strong>两者的区别</strong>在于它们的触发时机：<ul>
<li>**<code>DOMContentLoaded</code>**：HTML 解析完毕后触发，无需等待资源加载。</li>
<li>**<code>load</code>**：所有资源（包括图片、CSS、脚本）加载完毕后触发。</li>
</ul>
</li>
</ul>
<p>这些事件是开发者在处理页面加载和初始化逻辑时的重要工具。</p>
<h1 id="GET和POST的请求的区别"><a href="#GET和POST的请求的区别" class="headerlink" title="GET和POST的请求的区别"></a>GET和POST的请求的区别</h1><p><code>GET</code> 和 <code>POST</code> 是 HTTP 协议中两种常见的请求方法，主要用于客户端与服务器之间的数据交换。它们的区别如下：</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li><strong>GET</strong>：用于从服务器获取数据。GET 请求通常用于请求资源或信息，例如获取网页、图像、数据等。</li>
<li><strong>POST</strong>：用于向服务器提交数据。POST 请求通常用于上传数据，提交表单，或者进行需要修改服务器状态的操作。</li>
</ul>
<h3 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h3><ul>
<li><strong>GET</strong>：参数通过 <strong>URL</strong> 传递，附加在请求的 URL 末尾，格式为 <code>?key1=value1&amp;key2=value2</code>。URL 中的参数可见，长度有限，依赖于浏览器和服务器的限制（一般在 2048 字符以内）。</li>
<li><strong>POST</strong>：参数在 <strong>请求体</strong> 中传递，不会显示在 URL 中，因此更适合传递较大的数据量或敏感信息（如密码）。POST 请求没有长度限制。</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul>
<li><strong>GET</strong>：不适合传输敏感数据（如密码、信用卡信息），因为参数包含在 URL 中，容易被记录到浏览器历史、日志文件等地方。GET 请求只能使用 HTTPS 来加密数据传输。</li>
<li><strong>POST</strong>：相对更安全一些，因为数据是在请求体中传递，并且不会出现在 URL 中。虽然传输数据本身不加密，但配合 HTTPS 可以提高数据的安全性。</li>
</ul>
<h3 id="4-幂等性"><a href="#4-幂等性" class="headerlink" title="4. 幂等性"></a>4. <strong>幂等性</strong></h3><ul>
<li><strong>GET</strong>：是 <strong>幂等</strong> 的，也就是说多次执行相同的 GET 请求应该返回相同的结果，不会对服务器上的资源进行修改。因此，GET 通常用于读取数据，而不用于执行对服务器状态有影响的操作。</li>
<li><strong>POST</strong>：不是 <strong>幂等</strong> 的，每次执行相同的 POST 请求都可能导致服务器的状态发生变化。例如，重复提交表单可能会导致创建多条记录。</li>
</ul>
<h3 id="5-浏览器行为"><a href="#5-浏览器行为" class="headerlink" title="5. 浏览器行为"></a>5. <strong>浏览器行为</strong></h3><ul>
<li><strong>GET</strong>：<ul>
<li>可以被 <strong>缓存</strong>（例如网页、图片等可以被浏览器缓存）。</li>
<li>可以被 <strong>书签</strong> 保存，URL 中包含所有必要的信息。</li>
<li>浏览器的 <strong>回退</strong> 操作是安全的，不会引发重复操作。</li>
</ul>
</li>
<li><strong>POST</strong>：<ul>
<li>不会被浏览器缓存。</li>
<li>无法通过 <strong>书签</strong> 保存，因为数据在请求体中。</li>
<li>浏览器的 <strong>回退</strong> 操作可能会提示重复提交表单。</li>
</ul>
</li>
</ul>
<h3 id="6-数据传输大小限制"><a href="#6-数据传输大小限制" class="headerlink" title="6. 数据传输大小限制"></a>6. <strong>数据传输大小限制</strong></h3><ul>
<li><strong>GET</strong>：数据量较小，因为数据通过 URL 传递，受限于 URL 的长度限制（一般在 2048 字符以内）。</li>
<li><strong>POST</strong>：数据量较大，理论上没有大小限制，实际限制取决于服务器配置。POST 更适合上传文件、大量表单数据等场景。</li>
</ul>
<h3 id="7-请求的可见性"><a href="#7-请求的可见性" class="headerlink" title="7. 请求的可见性"></a>7. <strong>请求的可见性</strong></h3><ul>
<li><strong>GET</strong>：参数附加在 URL 中，因此请求的可见性强，任何人都能看到 URL 中传递的参数。</li>
<li><strong>POST</strong>：参数在请求体中传递，因此相对不可见，且不会显示在地址栏中。</li>
</ul>
<h3 id="8-浏览器预取-x2F-预请求"><a href="#8-浏览器预取-x2F-预请求" class="headerlink" title="8. 浏览器预取&#x2F;预请求"></a>8. <strong>浏览器预取&#x2F;预请求</strong></h3><ul>
<li><strong>GET</strong>：浏览器可以预取 GET 请求（提前请求资源以加快加载速度），但通常不会预取 POST 请求。</li>
</ul>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">GET</th>
<th align="center">POST</th>
</tr>
</thead>
<tbody><tr>
<td align="center">用途</td>
<td align="center">获取数据</td>
<td align="center">提交数据</td>
</tr>
<tr>
<td align="center">参数传递</td>
<td align="center">URL（请求头）</td>
<td align="center">请求体</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">不安全，数据暴露在 URL</td>
<td align="center">相对安全，数据在请求体中</td>
</tr>
<tr>
<td align="center">数据大小限制</td>
<td align="center">有限制（通常2048字符）</td>
<td align="center">理论上无限制（受服务器配置限制）</td>
</tr>
<tr>
<td align="center">缓存</td>
<td align="center">可以被缓存</td>
<td align="center">不会缓存</td>
</tr>
<tr>
<td align="center">幂等性</td>
<td align="center">是幂等的</td>
<td align="center">不是幂等的</td>
</tr>
<tr>
<td align="center">URL 长度</td>
<td align="center">有限制</td>
<td align="center">无限制</td>
</tr>
<tr>
<td align="center">适用场景</td>
<td align="center">请求资源、查询数据</td>
<td align="center">提交表单、上传数据</td>
</tr>
</tbody></table>
<p>简单来说，<code>GET</code> 主要用于获取资源，数据通过 URL 传递；<code>POST</code> 主要用于提交数据，数据通过请求体传递，并且相对更安全，适合传输较大的数据或敏感信息。</p>
<p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p>
<ul>
<li><strong>应用场景：</strong> (GET 请求是一个<strong>幂等</strong>的请求)一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。(而 Post 不是一个<strong>幂等</strong>的请求)一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。（<strong>幂等是指一个请求方法执行多次和仅执行一次的效果完全相同</strong>）</li>
<li><strong>是否缓存：</strong> 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li>
<li><strong>传参方式不同：</strong> Get 通过查询字符串传参，Post 通过请求体传参。</li>
<li><strong>安全性：</strong> Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li>
<li><strong>请求长度：</strong> 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li>
<li><strong>参数类型：</strong> get参数只允许ASCII字符，post 的参数传递支持更多的数据类型(如文件、图片)。</li>
</ul>
<h1 id="POST和PUT请求的区别"><a href="#POST和PUT请求的区别" class="headerlink" title="POST和PUT请求的区别"></a>POST和PUT请求的区别</h1><p>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</p>
<p>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</p>
<h1 id="为什么post请求会发送两次请求"><a href="#为什么post请求会发送两次请求" class="headerlink" title="为什么post请求会发送两次请求?"></a>为什么post请求会发送两次请求?</h1><ul>
<li>1.第一次请求为<code>options</code>预检请求，状态码为:204<ul>
<li>作用：<ul>
<li>作用1: 询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求</li>
<li>作用2: 检测服务器是否为同源请求,是否支持跨域</li>
</ul>
</li>
</ul>
</li>
<li>2.第二次为真正的<code>post</code>请求</li>
</ul>
<h2 id="常见的HTTP请求头和响应头"><a href="#常见的HTTP请求头和响应头" class="headerlink" title="常见的HTTP请求头和响应头"></a>常见的HTTP请求头和响应头</h2><h2 id="HTTP-Request-Header"><a href="#HTTP-Request-Header" class="headerlink" title="HTTP Request Header"></a>HTTP Request Header</h2><ul>
<li>Accept:浏览器能够处理的内容类型</li>
<li>Accept-Charset:浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<h2 id="HTTP-Responses-Header"><a href="#HTTP-Responses-Header" class="headerlink" title="HTTP Responses Header"></a>HTTP Responses Header</h2><ul>
<li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li>
<li>server:服务器名称</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cache-Control：控制HTTP缓存</li>
<li>content-type:表示后面的文档属于什么MIME类型</li>
<li>access-control-allow-origin：域名</li>
</ul>
<h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><p><strong>常见的 Content-Type 属性值有以下四种：</strong></p>
<p>（1）<code>application/x-www-form-urlencoded</code>：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL转码。</p>
<p>（2）<code>multipart/form-data</code>：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p>
<p>（3）<code>application/json</code>：服务器消息主体是序列化后的 JSON 字符串。</p>
<p>（4）<code>text/xml</code>：该种方式主要用来提交 XML 格式的数据。</p>
<h2 id="HTTP状态码304是多好还是少好"><a href="#HTTP状态码304是多好还是少好" class="headerlink" title="HTTP状态码304是多好还是少好"></a>HTTP状态码304是多好还是少好</h2><p><strong>为什么会有304</strong></p>
<p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。</p>
<p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应。</p>
<p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p>
<p><strong>产生较多304状态码的原因：</strong></p>
<ul>
<li>页面更新周期长或不更新</li>
<li>纯静态页面或强制生成静态html</li>
</ul>
<p><strong>304状态码出现过多会造成以下问题：</strong></p>
<ul>
<li>网站快照停止；</li>
<li>收录减少；</li>
<li>权重下降。</li>
</ul>
<h2 id="说说Ajax组成部分"><a href="#说说Ajax组成部分" class="headerlink" title="说说Ajax组成部分"></a>说说Ajax组成部分</h2><p>Ajax：全称 <code>Asynchronous Javascript And XML(异步的js与xml)</code></p>
<ul>
<li>说人话： <strong>用js发送异步的网络请求</strong></li>
<li>A : Asynchronous 异步</li>
<li>J：Javascript</li>
<li>A ：And</li>
<li>X : XML 与 XMLHttpRequest<ul>
<li>XML ： 解决跨平台数据传输。<ul>
<li>在JSON没有出来以前, 网络传输主要以XML格式数据为主。 后来JSON问世，逐渐取代XML。 但是由于ajax技术出来的比json早，因此xml这个称呼一直保留至今</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="请介绍一下XMLHTTPRequest对象"><a href="#请介绍一下XMLHTTPRequest对象" class="headerlink" title="请介绍一下XMLHTTPRequest对象"></a>请介绍一下XMLHTTPRequest对象</h2><p><strong>Ajax的核心是XMLHTTPRequest</strong>。它是一种支持异步请求的技术。 XMLHTTPRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。可以在页面加载以后进行页面的局部更新</p>
<p><strong>使用方法</strong></p>
<p><strong>1.实例化ajax对象</strong></p>
<p><strong>2. open()</strong> ：创建HTTP请求 第一个参数是指定提交方式(post、get) 第二个参数是指定要提交的地址是哪 第三个参数是指定是异步还是同步(true表示异步，false表示同步) 第四和第五参数在HTTP认证的时候会用到。是可选的</p>
<p><strong>3.设置请求头</strong></p>
<p><strong>setRequestHeader</strong>(Stringheader,Stringvalue) <strong>（使用post方式才会使用到，get方法并不需要调用该方法）</strong></p>
<p><strong>4.发送请求</strong></p>
<p><strong>send(content)</strong> ：发送请求给服务器 如果是get方式，并不需要填写参数，或填写null 如果是post方式，把要提交的参数写上去</p>
<p><strong>5. 注册回调函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 1.ajax： 在页面不刷新的情况下向服务器请求数据</span></span><br><span class="line"><span class="comment">           2.XMLHttpRequest ： http请求对象，负责实现ajax技术（小黄人）</span></span><br><span class="line"><span class="comment">                （1）创建XMLHttpRequest对象</span></span><br><span class="line"><span class="comment">                        * 小黄人，相当于黄袍加身的跑腿外卖小哥哥</span></span><br><span class="line"><span class="comment">                （2）设置请求</span></span><br><span class="line"><span class="comment">                        * 告诉小黄人服务器地址</span></span><br><span class="line"><span class="comment">                （3）发送请求</span></span><br><span class="line"><span class="comment">                        * 小黄人出发去指定地址取外卖（数据）</span></span><br><span class="line"><span class="comment">                            * 2G网速：走路去的</span></span><br><span class="line"><span class="comment">                            * 3G网速：骑膜拜去的</span></span><br><span class="line"><span class="comment">                            * WIFI : 骑电动车去的</span></span><br><span class="line"><span class="comment">                            * 4G   ： 骑小牛牌电动车去的</span></span><br><span class="line"><span class="comment">                （4）注册回调函数</span></span><br><span class="line"><span class="comment">                        * 小黄人把取回的外卖送到你家门口</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//(1).实例化ajax对象</span></span><br><span class="line">      <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">      <span class="comment">//(2).设置请求方法和地址</span></span><br><span class="line">      xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;http://www.liulongbin.top:3009/api/login&quot;</span>)</span><br><span class="line">      <span class="comment">//(3).设置请求头（post请求才需要设置）</span></span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">      <span class="comment">//(4).发送请求 ： 参数格式  &#x27;key=value&#x27;</span></span><br><span class="line">      xhr.<span class="title function_">send</span>(<span class="string">&quot;username=admin&amp;password=123456&quot;</span>)</span><br><span class="line">      <span class="comment">//(5).注册回调函数</span></span><br><span class="line">      <span class="comment">// xhr.onload = function() &#123;&#125;;</span></span><br><span class="line">      xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//onreadystatechange会触发多次，一般需要判断xhr.readState == 4 才获取响应数据</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="onreadstatechange事件"><a href="#onreadstatechange事件" class="headerlink" title="onreadstatechange事件"></a>onreadstatechange事件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">*/ <span class="number">1.</span> onload事件 ：  接收服务器响应的数（一次请求，只会执行一次）</span><br><span class="line">  */      <span class="number">2.</span> onreadystatechang事件 : 作用与onload事件一致（一次请求，会执行多次）</span><br><span class="line">  */          面试点： <span class="title class_">XMLHttpRequest</span>对象的状态码 （xhr.<span class="property">readyState</span>）</span><br><span class="line">   */             <span class="number">0</span>: 请求未建立  (创建了xhr对象，但是还没调用open)</span><br><span class="line">   */             <span class="number">1</span>: 服务器连接已建立 </span><br><span class="line">   */             <span class="number">2.</span> 请求已接收  (send之后,服务器已经接收了请求)</span><br><span class="line">   */             <span class="number">3.</span> 请求处理中 </span><br><span class="line">   */             <span class="number">4.</span> 请求已完成，且响应已就绪 （ <span class="number">4</span>状态码等同于onload事件 ）</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">      <span class="comment">//(1).实例化ajax对象</span></span><br><span class="line">      <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">readyState</span>) <span class="comment">//0</span></span><br><span class="line">      <span class="comment">//(2).设置请求方法和地址</span></span><br><span class="line">      xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;http://www.liulongbin.top:3009/api/login&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">readyState</span>) <span class="comment">//1</span></span><br><span class="line">      <span class="comment">//(3).设置请求头（post请求才需要设置）</span></span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">readyState</span>) <span class="comment">//1</span></span><br><span class="line">      <span class="comment">//(4).发送请求 ： 参数格式  &#x27;key=value&#x27;</span></span><br><span class="line">      xhr.<span class="title function_">send</span>(<span class="string">&quot;username=admin&amp;password=123456&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">readyState</span>) <span class="comment">//1</span></span><br><span class="line">      <span class="comment">//(5).注册回调函数</span></span><br><span class="line">      <span class="comment">//a. onload 是新式浏览器才支持的</span></span><br><span class="line">      <span class="comment">//b. 如果要兼容更早的浏览器，可以使用 onreadystatechange</span></span><br><span class="line">      <span class="comment">//c. onreadystatechange触发时机 ： xhr.readState状态变化</span></span><br><span class="line">      <span class="comment">// xhr.onload = function() &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line">      xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">readyState</span>) <span class="comment">//2,3,4</span></span><br><span class="line">        <span class="comment">//onreadystatechange会触发多次，一般需要判断xhr.readState == 4 才获取响应数据</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何上传文件（上传图片）"><a href="#如何上传文件（上传图片）" class="headerlink" title="如何上传文件（上传图片）"></a>如何上传文件（上传图片）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*文件上传思路总结 </span></span><br><span class="line"><span class="comment">   1. 给file表单注册onchange事件 </span></span><br><span class="line"><span class="comment">     * 当用户选择图片之后执行</span></span><br><span class="line"><span class="comment">   2. 获取用户选择的图片 </span></span><br><span class="line"><span class="comment">     * this.files[0]</span></span><br><span class="line"><span class="comment">   3. 创建FormData对象 </span></span><br><span class="line"><span class="comment">     * 只有FormData才可以上传文件</span></span><br><span class="line"><span class="comment">   4. 将图片添加到FormData对象中 </span></span><br><span class="line"><span class="comment">     * fd.append(&#x27;参数名&#x27;, this.files[0])</span></span><br><span class="line"><span class="comment">   5. 发送ajax请求</span></span><br><span class="line"><span class="comment">     * 文件上传请求方法一定是post, 且请求参数为 FormData对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">//1. file类型表单自带一个选择文件点击按钮，当用户选择文件之后就会触发onchange事件</span></span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#iptFile&quot;</span>).<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">//this : file表单</span></span><br><span class="line">     <span class="comment">//(1)获取用户选择的文件</span></span><br><span class="line">     <span class="keyword">let</span> file = <span class="variable language_">this</span>.<span class="property">files</span>[<span class="number">0</span>]</span><br><span class="line">     <span class="comment">// 非空判断，如果内容为undefined，给出提示</span></span><br><span class="line">     <span class="keyword">if</span> (file == <span class="literal">undefined</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="title function_">alert</span>(<span class="string">&quot;请选择上传文件！&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//(2)创建FormData对象， 只有FormData对象才可以上传文件</span></span><br><span class="line">     <span class="keyword">let</span> fd = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">     <span class="comment">//(3)添加文件</span></span><br><span class="line">     fd.<span class="title function_">append</span>(<span class="string">&quot;avatar&quot;</span>, file)</span><br><span class="line">     <span class="comment">//(4)发送ajax请求, 参数为 FormData对象</span></span><br><span class="line">     <span class="title function_">axios</span>(&#123;</span><br><span class="line">       <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">       <span class="attr">url</span>: <span class="string">&quot;http://www.liulongbin.top:3009/api/upload/avatar&quot;</span>,</span><br><span class="line">       <span class="attr">data</span>: fd</span><br><span class="line">     &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; data: res &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">       <span class="keyword">if</span> (res.<span class="property">code</span> != <span class="number">200</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="title function_">alert</span>(res.<span class="property">message</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 成功后提示，修改图片路径</span></span><br><span class="line">       <span class="title function_">alert</span>(<span class="string">&quot;恭喜您，上传头像成功！&quot;</span>)</span><br><span class="line">       <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;img&quot;</span>).<span class="property">src</span> = <span class="string">`http://www.liulongbin.top:3009<span class="subst">$&#123;res.url&#125;</span>`</span></span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何自定义上传文件按钮"><a href="#如何自定义上传文件按钮" class="headerlink" title="如何自定义上传文件按钮"></a>如何自定义上传文件按钮</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*自定义文件上传按钮思路</span></span><br><span class="line"><span class="comment">  (1)隐藏file表单</span></span><br><span class="line"><span class="comment">  (2)给自定义按钮添加一个点击事件</span></span><br><span class="line"><span class="comment">  (3)点击按钮的时候，触发 file表单的点击 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btnChoose&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    dom对象.onclick()  :  只能触发你自己注册的onclick事件，没注册触发不了</span></span><br><span class="line"><span class="comment">    dom对象.click() : 模拟鼠标点击。 触发注册的onclick事件 + 默认点击事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#iptFile&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ajax请求如何取消"><a href="#ajax请求如何取消" class="headerlink" title="ajax请求如何取消"></a>ajax请求如何取消</h2><p><strong>1. 原生xhr取消请求</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">xhr</span> = new XMLHttpRequest()<span class="comment">;</span></span><br><span class="line">xhr.abort()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.axios取消请求</strong></p>
<p><strong>1.使用 CancelToken.source 工厂方法创建 cancel token</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">CancelToken</span> = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">source</span> = CancelToken.<span class="title function_ invoke__">source</span>();</span><br><span class="line">axios.<span class="title function_ invoke__">get</span>(<span class="string">&#x27;/user/123&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">cancelToken</span>: source.token</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (axios.<span class="title function_ invoke__">isCancel</span>(thrown)) &#123;</span><br><span class="line">        console.<span class="title function_ invoke__">log</span>(<span class="string">&#x27;Request canceled&#x27;</span>, thrown.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_ invoke__">post</span>(<span class="string">&#x27;/user/123&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">cancelToken</span>: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求（message 参数是可选的）</span></span><br><span class="line">source.<span class="title function_ invoke__">cancel</span>(<span class="string">&#x27;canceled by the user.&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2.传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const <span class="attr">CancelToken</span> = axios.CancelToken<span class="comment">;</span></span><br><span class="line">let cancel<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">axios.get(&#x27;/user/12345&#x27;, &#123;</span><br><span class="line">  cancelToken: new CancelToken(function executor(c) &#123;</span><br><span class="line">    // executor 函数接收一个 cancel 函数作为参数</span><br><span class="line">    <span class="attr">cancel</span> = c<span class="comment">;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// cancel the request</span><br><span class="line">cancel()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="取消ajax请求有什么意义"><a href="#取消ajax请求有什么意义" class="headerlink" title="取消ajax请求有什么意义"></a>取消ajax请求有什么意义</h2><p><strong>取消ajax请求的意义</strong></p>
<ol>
<li>已发出的请求可能仍然会到达后端</li>
<li>取消后续的回调处理，避免多余的回调处理，以及特殊情况，先发出的后返回，导致回调中的数据错误覆盖</li>
<li>取消loading效果，以及该请求的其他交互效果，特别是在单页应用中，A页面跳转到B页面之后，A页面的请求应该取消，否则回调中的一些处理可能影响B页面</li>
<li>超时处理，错误处理等都省去了，节约资源</li>
</ol>
<h2 id="OPTIONS请求方法及使用场景"><a href="#OPTIONS请求方法及使用场景" class="headerlink" title="OPTIONS请求方法及使用场景"></a>OPTIONS请求方法及使用场景</h2><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。(浏览器自动执行)</p>
<p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求&#x2F;响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p>
<p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p>
<ul>
<li>获取服务器支持的所有HTTP请求方法；</li>
<li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送<strong>嗅探</strong>请求，以判断是否有对指定资源的访问权限。</li>
</ul>
<h2 id="HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h2><ul>
<li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li>
<li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>http1.1</strong> 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li>
<li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li>
</ul>
<h2 id="HTTP-1-1-和-HTTP-2-0-的区别"><a href="#HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="HTTP 1.1 和 HTTP 2.0 的区别"></a>HTTP 1.1 和 HTTP 2.0 的区别</h2><ul>
<li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议。在 HTTP&#x2F;1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li>
<li><strong>多路复用：</strong> HTTP&#x2F;2 实现了多路复用，HTTP&#x2F;2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li>
<li><strong>数据流：</strong> HTTP&#x2F;2 使用了数据流的概念，因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li>
<li><strong>头信息压缩：</strong> HTTP&#x2F;2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li>
<li><strong>服务器推送：</strong> HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li>
</ul>
<h2 id="什么是队头堵塞"><a href="#什么是队头堵塞" class="headerlink" title="什么是队头堵塞"></a>什么是队头堵塞</h2><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p>
<h3 id="队头阻塞的解决方案"><a href="#队头阻塞的解决方案" class="headerlink" title="队头阻塞的解决方案"></a>队头阻塞的解决方案</h3><p>（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p>
<h2 id="HTTP和HTTPS协议的区别"><a href="#HTTP和HTTPS协议的区别" class="headerlink" title="HTTP和HTTPS协议的区别"></a>HTTP和HTTPS协议的区别</h2><p>HTTP和HTTPS协议的主要区别如下：</p>
<ul>
<li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li>
<li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<h2 id="GET方法URL长度限制的原因"><a href="#GET方法URL长度限制的原因" class="headerlink" title="GET方法URL长度限制的原因"></a>GET方法URL长度限制的原因</h2><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的<strong>浏览器</strong>及<strong>服务器</strong>对它的限制。 IE对URL长度的限制是<strong>2083</strong>字节(2K+35)。由于IE浏览器对URL长度的允许值是<strong>最小的</strong>，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span>的长度值 <span class="operator">=</span> URL（<span class="number">2083</span>）<span class="operator">-</span> （你的Domain<span class="operator">+</span>Path）<span class="number">-2</span>（<span class="number">2</span>是<span class="keyword">get</span>请求中?<span class="operator">=</span>两个字符的长度）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面看一下主流浏览器对get方法中url的长度限制范围：</p>
<ul>
<li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为<strong>2083</strong>个字符，如果超过这个数字，提交按钮没有任何反应。</li>
<li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 <strong>65,536</strong> 个字符。</li>
<li>Safari (Browser)：URL最大长度限制为 <strong>80,000</strong> 个字符。</li>
<li>Opera (Browser)：URL最大长度限制为 <strong>190,000</strong> 个字符。</li>
<li>Google (chrome)：URL最大长度限制为 <strong>8182</strong> 个字符。</li>
</ul>
<p>主流的服务器对get方法中url的长度限制范围：</p>
<ul>
<li>Apache (Server)：能接受最大url长度为<strong>8192</strong>个字符。</li>
<li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为<strong>16384</strong>个字符。</li>
</ul>
<p>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</p>
<h1 id="从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h1><p>（1）<strong>解析URL：</strong> <strong>首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径</strong>。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p>
<p>（2）<strong>缓存判断：</strong> <strong>浏览器会判断所请求的资源是否在缓存里</strong>，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p>
<p>（3）<strong>DNS解析：</strong> 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会<strong>判断本地是否有该域名的 IP 地址的缓存</strong>，如果有则使用，<strong>如果没有则向本地 DNS 服务器发起请求</strong>。<strong>本地 DNS 服务器也会先检查是否存在缓存</strong>，如果<strong>没有就会先向根域名服务器发起请求</strong>，获得负责的顶级域名服务器的地址后，<strong>再向顶级域名服务器请求</strong>，然后获得负责的权威域名服务器的地址后，<strong>再向权威域名服务器发起请求</strong>，<strong>最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户</strong>。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p>
<p>（4）<strong>获取MAC地址（选说）</strong> 当浏览器得到 IP 地址后，<strong>数据传输还需要知道目的主机 MAC 地址</strong>，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p>
<p>（5）<strong>TCP三次握手：</strong> ，<strong>确认客户端与服务器的接收与发送能力</strong>，下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p>
<p>（6）<strong>HTTPS握手（选说）：</strong> <strong>如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程</strong>。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p>
<p>（7）<strong>发送HTTP请求</strong></p>
<p><strong>服务器处理请求,返回HTTP报文</strong>(响应)(文件)</p>
<p>（8）<strong>页面渲染：</strong> 浏览器首先会根据 html 文件(响应) <strong>建 DOM 树</strong>，根据解析到的 css 文件构<strong>建 CSSOM 树</strong>，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。<strong>当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树</strong>。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p>
<p>（9）<strong>TCP四次挥手：</strong> <strong>最后一步是 TCP 断开连接的四次挥手过程</strong>。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p>
<h2 id="15-页面有多张图片，HTTP是怎样的加载表现？"><a href="#15-页面有多张图片，HTTP是怎样的加载表现？" class="headerlink" title="15.页面有多张图片，HTTP是怎样的加载表现？"></a>15.页面有多张图片，HTTP是怎样的加载表现？</h2><p>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</p>
<p>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。</p>
<h2 id="16-HTTP2的头部压缩算法是怎样的？"><a href="#16-HTTP2的头部压缩算法是怎样的？" class="headerlink" title="16. HTTP2的头部压缩算法是怎样的？"></a>16. HTTP2的头部压缩算法是怎样的？</h2><p>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>
<p>具体来说:</p>
<ul>
<li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</li>
<li>首部表在HTTP&#x2F;2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li>
<li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li>
</ul>
<h2 id="17-HTTP请求报文的是什么样的？"><a href="#17-HTTP请求报文的是什么样的？" class="headerlink" title="17. HTTP请求报文的是什么样的？"></a>17. HTTP请求报文的是什么样的？</h2><p>请求报⽂有4部分组成:</p>
<ul>
<li>请求⾏</li>
<li>请求头部</li>
<li>空⾏</li>
<li>请求体</li>
</ul>
<p><strong>其中：</strong></p>
<p>（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET &#x2F;index.html HTTP&#x2F;1.1。</p>
<p>（2）请求头部:请求头部由关键字&#x2F;值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔</p>
<ul>
<li>User-Agent：产⽣请求的浏览器类型。</li>
<li>Accept：客户端可识别的内容类型列表。</li>
<li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</li>
</ul>
<p>（3）请求体: post put等请求携带的数据</p>
<h2 id="18-HTTP响应报文的是什么样的？"><a href="#18-HTTP响应报文的是什么样的？" class="headerlink" title="18. HTTP响应报文的是什么样的？"></a>18. HTTP响应报文的是什么样的？</h2><p>请求报⽂有4部分组成:</p>
<ul>
<li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP&#x2F;1.1 200 OK</li>
<li>响应头：响应部⾸组成</li>
<li>空⾏</li>
<li>响应体：服务器响应的数据</li>
</ul>
<h2 id="19-HTTP协议的优点和缺点"><a href="#19-HTTP协议的优点和缺点" class="headerlink" title="19. HTTP协议的优点和缺点"></a>19. HTTP协议的优点和缺点</h2><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p>
<p>HTTP协议具有以下<strong>优点</strong>：</p>
<ul>
<li>支持客户端&#x2F;服务器模式</li>
<li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li>
<li><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li>
<li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li>
<li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li>
</ul>
<p>HTTP协议具有以下<strong>缺点</strong>：</p>
<ul>
<li><strong>无状态：</strong> HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li>
<li><strong>明文传输：</strong> 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li>
<li><strong>不安全</strong></li>
</ul>
<p>（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改；</p>
<h2 id="20-说一下HTTP-3-0"><a href="#20-说一下HTTP-3-0" class="headerlink" title="20. 说一下HTTP 3.0"></a>20. 说一下HTTP 3.0</h2><p>HTTP3.0，也称作HTTP over QUIC。HTTP3.0的核心是QUIC(读音quick)协议，由Google在 2015年提出的SPDY v3演化而来的新协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层UDP上的协议，可以定义成:HTTP3.0基于UDP的安全可靠的HTTP2.0协议。</p>
<h2 id="21-HTTP的两种连接模式"><a href="#21-HTTP的两种连接模式" class="headerlink" title="21. HTTP的两种连接模式"></a>21. HTTP的两种连接模式</h2><p>HTTP 协议是基于 TCP&#x2F;IP，并且使用了<strong>请求-应答</strong>的通信模式。</p>
<p><strong>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接</strong>。 （1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。 （2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p>
<h2 id="22-URL有哪些组成部分"><a href="#22-URL有哪些组成部分" class="headerlink" title="22. URL有哪些组成部分"></a>22. URL有哪些组成部分</h2><p>以下面的URL为例<a target="_blank" rel="noopener" href="http://www.aspxfans.com:8080/news/index?ID=246188#name">www.aspxfans.com:8080/news/index?ID=246188#name</a></p>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<ul>
<li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符；</li>
<li><strong>域名部分</strong>：该URL的域名部分为<a target="_blank" rel="noopener" href="http://www.aspxfans.com.一个url中,也可以使用ip地址作为域名使用/">www.aspxfans.com。一个URL中，也可以使用IP地址作为域名使用</a></li>
<li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li>
<li><strong>虚拟目录部分</strong>：从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”；</li>
<li><strong>文件名部分</strong>：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li>
<li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li>
<li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ul>
<h2 id="23-与缓存相关的HTTP请求头有哪些"><a href="#23-与缓存相关的HTTP请求头有哪些" class="headerlink" title="23.与缓存相关的HTTP请求头有哪些"></a>23.与缓存相关的HTTP请求头有哪些</h2><p>强缓存：</p>
<ul>
<li>Expires</li>
<li>Cache-Control</li>
</ul>
<p>协商缓存：</p>
<ul>
<li>Etag、If-None-Match</li>
<li>Last-Modified、If-Modified-Since</li>
</ul>
<h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><p><strong>1.强缓存：</strong> 不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache两种（灰色表示缓存）。</p>
<p><strong>2.协商缓存：</strong> 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</p>
<blockquote>
<p>共同点：都是从客户端缓存中读取资源； 区别是强缓存不会发请求，协商缓存会发请求。</p>
</blockquote>
<h1 id="HTTP的keep-alive有什么作用？"><a href="#HTTP的keep-alive有什么作用？" class="headerlink" title="HTTP的keep-alive有什么作用？"></a>HTTP的keep-alive有什么作用？</h1><p><strong>http1.0默认关闭，需要手动开启。http1.1后默认开启</strong></p>
<p><strong>作用：</strong> 使客户端到服务器端的链接持续有效(<strong>长连接</strong>)，当出现对服务器的后续请求时，keep-Alive功能避免了建立或者重新建立链接。</p>
<p><strong>使用方法：</strong> 在请求头中加上Connection：keep-alive。</p>
<p><strong>优点：</strong></p>
<ul>
<li>较少的CPU和内存的占用(因为要打开的连接数变少了，复用了连接)</li>
<li>减少了后续请求的延迟(无需再进行握手)</li>
</ul>
<p><strong>缺点：</strong> 本来可以释放的资源仍旧被占用。有的请求已经结束了，但是还一直连接着。</p>
<p><strong>解决方法：</strong> 服务器设置过期时间和请求次数，超过这个时间或者次数就断掉连接。</p>
<h1 id="OSI的七层模型是什么？"><a href="#OSI的七层模型是什么？" class="headerlink" title="OSI的七层模型是什么？"></a>OSI的七层模型是什么？</h1><p>ISO于1978年开发的一套标准架构ISO模型，被引用来说明数据通信协议的结构和功能。</p>
<p>OSI在功能上可以划分为两组：</p>
<p>网络群组：物理层、数据链路层、网络层</p>
<p>使用者群组：传输层、会话层、表示层、应用层</p>
<table>
<thead>
<tr>
<th><code>OSI</code>七层网络模型</th>
<th><code>TCP/IP</code>四层概念模型</th>
<th>对应网络协议</th>
</tr>
</thead>
<tbody><tr>
<td>7：应用层</td>
<td>应用层</td>
<td><code>HTTP</code>、<code>RTSP</code> <code>TFTP（简单文本传输协议）、</code>FTP<code>、</code> NFS<code>（数域筛法，数据加密）、</code>WAIS&#96;（广域信息查询系统）</td>
</tr>
<tr>
<td>6：表示层</td>
<td>应用层</td>
<td><code>Telnet</code>（internet远程登陆服务的标准协议）、<code>Rlogin</code>、<code>SNMP</code>（网络管理协议）、Gopher</td>
</tr>
<tr>
<td>5：会话层</td>
<td>应用层</td>
<td><code>SMTP</code>（简单邮件传输协议）、<code>DNS</code>（域名系统）</td>
</tr>
<tr>
<td>4：传输层</td>
<td>传输层</td>
<td><code>TCP</code>（传输控制协议）、<code>UDP</code>（用户数据报协议））</td>
</tr>
<tr>
<td>3：网络层</td>
<td>网际层</td>
<td><code>ARP</code>（地域解析协议）、<code>RARP</code>、<code>AKP</code>、<code>UUCP</code>（Unix to Unix copy）</td>
</tr>
<tr>
<td>2：数据链路层</td>
<td>数据链路层</td>
<td><code>FDDI</code>（光纤分布式数据接口）、<code>Ethernet、Arpanet、PDN</code>（公用数据网）、<code>SLIP</code>（串行线路网际协议）<code>PPP</code>（点对点协议，通过拨号或专线方建立点对点连接发送数据）</td>
</tr>
<tr>
<td>1：物理层</td>
<td>物理层</td>
<td><code>SMTP</code>（简单邮件传输协议）、<code>DNS</code>（域名系统）</td>
</tr>
</tbody></table>
<p>其中高层（7、6、5、4层）定义了应用程序的功能，下面三层（3、2、1层）主要面向通过网络的端到端的数据流</p>
<h1 id="什么是HTTPS协议？"><a href="#什么是HTTPS协议？" class="headerlink" title="什么是HTTPS协议？"></a>什么是HTTPS协议？</h1><p><code>超文本传输安全协议</code>（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。<strong>HTTPS经由HTTP进行通信，利用SSL&#x2F;TLS来加密数据包。</strong> HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 <img src="/../imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/7fc896a61f7d4810811b2d47b2170e02tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="img"> HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS&#x2F;SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p>
<p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p>
<h2 id="TLS-x2F-SSL的工作原理"><a href="#TLS-x2F-SSL的工作原理" class="headerlink" title="TLS&#x2F;SSL的工作原理"></a>TLS&#x2F;SSL的工作原理</h2><p><strong>TLS</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）及其前身<strong>安全套接层</strong>（Secure Sockets Layer，缩写作<strong>SSL</strong>） 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p>
<ul>
<li>散列算法用来验证信息的完整性</li>
<li>对称加密算法采用协商的秘钥对数据加密</li>
<li>非对称加密实现身份认证和秘钥协商</li>
</ul>
<h2 id="对称加密、非对称加密是什么，有什么区别？"><a href="#对称加密、非对称加密是什么，有什么区别？" class="headerlink" title="对称加密、非对称加密是什么，有什么区别？"></a>对称加密、非对称加密是什么，有什么区别？</h2><p><strong>对称加密和非对称加密是安全传输层里的加密算法</strong></p>
<p><strong>对称加密</strong></p>
<ul>
<li><p>对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，</p>
<p>这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难</p>
<p><strong>通信的双⽅都使⽤同⼀个秘钥进⾏加密, 解密。</strong> ⽐如，两个人事先约定的暗号，就属于对称加密。</p>
</li>
</ul>
<p>**优点:**计算量小、加密速度快、加密效率高。</p>
<p>**缺点:**在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。如果一方的秘钥被泄露，那么加密信息也就不安全了。</p>
<p>最不安全的地方, 就在于第一开始, 互相约定密钥的时候!!! 传递密钥!</p>
<p>使用场景：本地数据加密、https 通信、网络传输等</p>
<p><strong>非对称加密</strong></p>
<p>通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。</p>
<p>特征: 私钥可以解密公钥加密的内容, 公钥可以解密私钥加密的内容</p>
<p>非对称加密的特点是：</p>
<ul>
<li>优点：非对称加密与对称加密相比其安全性更好</li>
<li><strong>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</strong></li>
</ul>
<p>使用场景：https 会话前期、CA 数字证书、信息加密、登录认证等</p>
<h2 id="数字证书是什么？"><a href="#数字证书是什么？" class="headerlink" title="数字证书是什么？"></a>数字证书是什么？</h2><p>使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为<strong>数字证书</strong>。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<h3 id="数字证书的作用"><a href="#数字证书的作用" class="headerlink" title="数字证书的作用"></a>数字证书的作用</h3><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用<strong>数字证书</strong>。</p>
<h3 id="数字签名是什么？"><a href="#数字签名是什么？" class="headerlink" title="数字签名是什么？"></a>数字签名是什么？</h3><p>数字签名就是先用CA自带的Hash算法来计算出证书内容的一个摘要，然后使用CA私钥进行加密，组成数字签名。</p>
<p>当别人把他的数字证书发过来时，接收方用同样的算法再次生成摘要，用CA公钥解密后得到CA生成的摘要，两者进行对比后，就能确定中间是否被人篡改。这样就能最大程度的保证通信的安全了。</p>
<h1 id="HTTPS通信（握手）过程–三次握手"><a href="#HTTPS通信（握手）过程–三次握手" class="headerlink" title="HTTPS通信（握手）过程–三次握手"></a>HTTPS通信（握手）过程–三次握手</h1><p>HTTPS的通信过程如下：</p>
<ol>
<li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li>
<li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li>
<li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li>
<li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li>
<li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li>
</ol>
<h2 id="HTTPS的优缺点"><a href="#HTTPS的优缺点" class="headerlink" title="HTTPS的优缺点"></a>HTTPS的优缺点</h2><p>HTTPS的<strong>优点</strong>如下：</p>
<ul>
<li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li>
<li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；</li>
</ul>
<p>HTTPS的<strong>缺点</strong>如下：</p>
<ul>
<li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li>
<li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li>
<li>SSL证书是收费的，功能越强大的证书费用越高；</li>
<li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li>
<li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。</li>
</ul>
<h2 id="HTTPS是如何保证安全的？"><a href="#HTTPS是如何保证安全的？" class="headerlink" title="HTTPS是如何保证安全的？"></a><strong>HTTPS</strong>是如何保证安全的？</h2><p>结合<strong>对称加密</strong>和<strong>非对称加密</strong>两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。</p>
<p>这个时候还需要⼀个安全的<strong>第三⽅颁发证书</strong>（CA），证明身份的身份，防⽌被中间⼈攻击。</p>
<p>为了防止中间人篡改证书，需要用到<strong>数字签名</strong>这个技术</p>
<p><em>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。</em></p>
<h2 id="HTTP状态码分别代表什么意思？"><a href="#HTTP状态码分别代表什么意思？" class="headerlink" title="HTTP状态码分别代表什么意思？"></a>HTTP状态码分别代表什么意思？</h2><table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>原因</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>Informational(信息性状态码)</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作一完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error (客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a><strong>2XX 成功</strong></h3><ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。通常是在POST请求，或者是某些PUT请求之后创建了内容，进行的返回的响应。</li>
<li>202 Accepted 请求服务器已接受，但是尚未处理，不保证完成请求。适合异步任务或者说需要处理时间比较长的请求，避免HTTP链接一直占用。</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li>
<li>206 Partial Content，进行的是范围请求，表示服务器已经成功处理了部分GET请求，响应头中会包含获取的内容范围(常用于分段下载)</li>
</ul>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a><strong>3XX 重定向</strong></h3><ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL，支持搜索引擎优化</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li>
<li>304 not modified，自从上次请求后，请求的网页内容未修改过。服务器返回此响应时，不会返回网页内容。(<strong>协商缓存</strong>)</li>
<li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li>
</ul>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a><strong>4XX 客户端错误</strong></h3><ul>
<li>400 bad request，请求报文存在语法错误(传参格式不正确)</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息(没有权限)</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
<li>408 Request Timeout 客户端请求超时</li>
<li>409 Confict 请求的资源可能引起冲突</li>
</ul>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a><strong>5XX 服务器错误</strong></h3><ul>
<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>
<li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
</ul>
<h2 id="同样是重定向，307，303，302的区别？"><a href="#同样是重定向，307，303，302的区别？" class="headerlink" title="同样是重定向，307，303，302的区别？"></a>同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h2><p><strong>302</strong>是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。</p>
<p><strong>303</strong>明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。</p>
<p><strong>307</strong>会遵照浏览器标准，不会从post变为get。</p>
<h2 id="DNS-协议是什么"><a href="#DNS-协议是什么" class="headerlink" title="DNS 协议是什么"></a>DNS 协议是什么</h2><p><strong>概念</strong>： DNS 是<strong>域名系统</strong> (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p>
<h2 id="11-DNS完整的查询过程"><a href="#11-DNS完整的查询过程" class="headerlink" title="11. DNS完整的查询过程"></a>11. DNS完整的查询过程</h2><p>DNS服务器解析域名的过程：</p>
<ul>
<li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li>
<li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li>
<li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li>
<li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li>
<li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li>
<li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li>
<li>本地DNS服务器将返回结果返回给浏览器</li>
</ul>
<h2 id="简述一下TCP的三次握手"><a href="#简述一下TCP的三次握手" class="headerlink" title="简述一下TCP的三次握手"></a>简述一下TCP的三次握手</h2><p><strong>第一次握手：</strong> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p>
<p><strong>第二次握手：</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p>
<p><strong>第三次握手：</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>
<h2 id="TCP什么要三次握手呢？两次不行吗？"><a href="#TCP什么要三次握手呢？两次不行吗？" class="headerlink" title="TCP什么要三次握手呢？两次不行吗？"></a><strong>TCP什么要三次握手呢？两次不行吗？</strong></h2><ul>
<li>为了确认双方的接收能力和发送能力都正常</li>
<li>如果是用两次握手，则会出现下面这种情况：</li>
</ul>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
<h2 id="简述一下TCP的四次挥手"><a href="#简述一下TCP的四次挥手" class="headerlink" title="简述一下TCP的四次挥手"></a>简述一下TCP的四次挥手</h2><p><strong>第一次挥手：</strong> 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</p>
<p><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</p>
<p><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</p>
<p><strong>第四次挥手：</strong> 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p>
<h2 id="TCP为什么需要四次挥手呢？"><a href="#TCP为什么需要四次挥手呢？" class="headerlink" title="TCP为什么需要四次挥手呢？"></a>TCP<strong>为什么需要四次挥手呢？</strong></h2><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p>
<h2 id="TCP粘包是怎么回事，如何处理"><a href="#TCP粘包是怎么回事，如何处理" class="headerlink" title="TCP粘包是怎么回事，如何处理?"></a>TCP粘包是怎么回事，如何处理?</h2><p>默认情况下, TCP 连接会启⽤<strong>延迟传送算法</strong> (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.</p>
<p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</p>
<p>⽽对于处理粘包的问题, 常⻅的解决⽅案有:</p>
<p><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</p>
<p><strong>关闭 Nagle 算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)</p>
<p><strong>进⾏封包&#x2F;拆包：</strong> 封包&#x2F;拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前&#x2F;后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。</p>
<h2 id="token是什么？"><a href="#token是什么？" class="headerlink" title="token是什么？"></a>token是什么？</h2><ol>
<li><p>token也可以称做<strong>令牌</strong>，一般由 <code>uid+time+sign(签名)+[固定参数]</code> 组成</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uid<span class="punctuation">:</span> 用户唯一身份标识</span><br><span class="line">time<span class="punctuation">:</span> 当前时间的时间戳</span><br><span class="line">sign<span class="punctuation">:</span> 签名<span class="punctuation">,</span> 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</span><br><span class="line">固定参数(可选)<span class="punctuation">:</span> 将一些常用的固定参数加入到 token 中是为了避免重复查库</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p>
</li>
<li><p>token 的认证流程</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户登录，成功后服务器返回Token给客户端。</span><br><span class="line">客户端收到数据后保存在客户端</span><br><span class="line">客户端再次访问服务器，将token放入headers中 或者每次的请求 参数中</span><br><span class="line">服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>token可以抵抗csrf，cookie+session不行</p>
</li>
<li><p>session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session</p>
</li>
<li><p>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)</p>
</li>
</ol>
<h2 id="token是怎么加密的"><a href="#token是怎么加密的" class="headerlink" title="token是怎么加密的"></a>token是怎么加密的</h2><ol>
<li>需要一个secret（随机数）</li>
<li>后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端</li>
<li>前端每次request在header中带上token</li>
<li>后端用同样的算法解密</li>
</ol>
<h2 id="cookie和token都放在header中，为什么会劫持cookie，不会劫持token"><a href="#cookie和token都放在header中，为什么会劫持cookie，不会劫持token" class="headerlink" title="cookie和token都放在header中，为什么会劫持cookie，不会劫持token"></a>cookie和token都放在header中，为什么会劫持cookie，不会劫持token</h2><ul>
<li><strong>cookie</strong>: 登陆后后端生成一个sessionid放在cookie中返回给客户端, 并且服务端一直记录着这个 sessionid, 客户端以后每次请求都会带上这个sessionid, 服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie就相当于拿到了sessionid ,就可以完全替代你。同时浏览器会自动携带cookie</li>
<li>token: 同样是登录后服务端返回一个token，客户端保存起来，在以后http请求里手动的加入到请求头里，服务端根据token 进行身份的校验。浏览器不会自动携带token，所以不会劫持 token。</li>
</ul>
<h2 id="token过期后，页面如何实现无感刷新"><a href="#token过期后，页面如何实现无感刷新" class="headerlink" title="token过期后，页面如何实现无感刷新?"></a>token过期后，页面如何实现无感刷新?</h2><h3 id="什么是无感刷新"><a href="#什么是无感刷新" class="headerlink" title="什么是无感刷新"></a><strong>什么是无感刷新</strong></h3><p>后台返回的token是有时效性的，时间到了，你在交互后台的时候，后台会判断你的token是否过期（安全需要），如果过期了就会逼迫你重新登陆！</p>
<p><strong>token无感刷新其本质是为了优化用户体验,当token过期时不需要用户跳回登录页重新登录,而是当token失效时,进行拦截,发送刷新token的ajax,获取最新的token进行覆盖,让用户感受不到token已经过期</strong></p>
<h3 id="实现无感刷新"><a href="#实现无感刷新" class="headerlink" title="实现无感刷新"></a><strong>实现无感刷新</strong></h3><p>1、后端返回过期时间，前端判断token过期时间,去调用刷新token接口。</p>
<p>缺点：需要后端额外提供一个Token过期时间的字段；使用了本地时间判断，若本地时间篡改，特别是本地时间比服务器时间慢时，拦截会失败。</p>
<p>2、写个定时器，定时刷新Token接口。缺点：浪费资源,消耗性能,不建议采用。</p>
<p>3、在响应拦截器中拦截，判断Token 返回过期后，调用刷新token接口。</p>
<h2 id="介绍下304过程"><a href="#介绍下304过程" class="headerlink" title="介绍下304过程"></a>介绍下304过程</h2><ul>
<li>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。</li>
<li>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。</li>
<li>c. 协商缓存Last-Modify&#x2F;If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存</li>
</ul>
<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><h2 id="有哪些可能引起前端安全的问题"><a href="#有哪些可能引起前端安全的问题" class="headerlink" title="有哪些可能引起前端安全的问题?"></a>有哪些可能引起前端安全的问题?</h2><ul>
<li><strong>跨站脚本</strong> (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript &#x2F; CSS &#x2F; Flash 等；</li>
<li><strong>iframe的滥⽤</strong>: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li>
<li><strong>跨站点请求伪造</strong>（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击</li>
<li><strong>恶意第三⽅库</strong>: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li>
</ul>
<h2 id="网络劫持有哪几种，如何防范？"><a href="#网络劫持有哪几种，如何防范？" class="headerlink" title="网络劫持有哪几种，如何防范？"></a>网络劫持有哪几种，如何防范？</h2><p>⽹络劫持分为两种:</p>
<p>（1）<strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持)</p>
<ul>
<li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li>
<li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li>
</ul>
<p>（2）<strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p>
<p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>
<h2 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h2><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p>
<ul>
<li>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li>
<li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li>
</ul>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li>进程可以看做独立应用，线程不能</li>
<li><strong>资源</strong>：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li>
<li><strong>通信方面</strong>：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li>
<li><strong>调度</strong>：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li><strong>系统开销</strong>：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I&#x2F;O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li>
</ul>
<h2 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h2><blockquote>
<p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>
</blockquote>
<ul>
<li><strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li>
<li><strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li>
<li><strong>使用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li>
<li><strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li>
</ul>
<h2 id="6-为什么需要浏览器缓存？"><a href="#6-为什么需要浏览器缓存？" class="headerlink" title="6. 为什么需要浏览器缓存？"></a>6. 为什么需要浏览器缓存？</h2><p>对于浏览器的缓存，主要针对的是前端的静态资源，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p>
<p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p>
<h3 id="浏览器缓存的优点"><a href="#浏览器缓存的优点" class="headerlink" title="浏览器缓存的优点"></a>浏览器缓存的优点</h3><p>使用浏览器缓存，有以下优点：</p>
<ul>
<li>减少了服务器的负担，提高了网站的性能</li>
<li>加快了客户端网页的加载速度</li>
<li>减少了多余网络数据传输</li>
</ul>
<h2 id="点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h2><ul>
<li><strong>点击刷新按钮或者按 F5：</strong> 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li>
<li><strong>用户按 Ctrl+F5（强制刷新）：</strong> 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li>
<li><strong>地址栏回车</strong>： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li>
</ul>
<h2 id="浏览器渲染过程中遇到-JS-文件如何处理？"><a href="#浏览器渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="浏览器渲染过程中遇到 JS 文件如何处理？"></a>浏览器渲染过程中遇到 JS 文件如何处理？</h2><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p>
<p>也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</p>
<h1 id="什么是文档的预解析？"><a href="#什么是文档的预解析？" class="headerlink" title="什么是文档的预解析？"></a>什么是文档的预解析？</h1><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h1 id="CSS-如何阻塞文档解析？"><a href="#CSS-如何阻塞文档解析？" class="headerlink" title="CSS 如何阻塞文档解析？"></a>CSS 如何阻塞文档解析？</h1><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</p>
<p>所以<strong>如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。</strong> 也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p>
<h1 id="前端存储"><a href="#前端存储" class="headerlink" title="前端存储"></a>前端存储</h1><h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><ol>
<li><strong>IndexedDB</strong>：适合存储大量数据，特别是复杂、结构化的数据。容量较大且持久性强。</li>
<li><strong>LocalStorage</strong>：用于持久化存储简单数据。容量适中，存储的数据长期有效，除非手动删除。</li>
<li><strong>SessionStorage</strong>：适用于会话级别的临时数据，生命周期短，当标签页或浏览器窗口关闭时数据清除。</li>
<li><strong>Cookie</strong>：适用于存储少量数据，通常用于会话管理和小型数据存储，虽然持久性可以根据设置进行控制，但每次请求时会附带发送给服务器，影响性能。</li>
</ol>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。<strong>Cookie的大小只有4kb</strong>，它是一种纯文本文件，<strong>每次发起HTTP请求都会携带Cookie。</strong></p>
<h3 id="Cookie的特性："><a href="#Cookie的特性：" class="headerlink" title="Cookie的特性："></a><strong>Cookie的特性：</strong></h3><ul>
<li>Cookie一旦创建成功，名称就无法修改</li>
<li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li>
<li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb；</li>
<li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li>
<li>Cookie在请求一个新的页面的时候都会被发送过去</li>
</ul>
<p><strong>如果需要域名之间跨域共享Cookie，有两种方法：</strong></p>
<ol>
<li>使用Nginx反向代理</li>
<li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li>
</ol>
<p><strong>常见可选字段</strong>：</p>
<ul>
<li><code>Expires</code>：设置 Cookie 的到期时间。</li>
<li><code>Max-Age</code>：以秒为单位设置 Cookie 的存活时间。</li>
<li><code>Domain</code>：指定 Cookie 适用的域。</li>
<li><code>Path</code>：指定 Cookie 适用的路径。</li>
<li><code>Secure</code>：仅在 HTTPS 协议下发送 Cookie。</li>
<li><code>HttpOnly</code>：防止 JavaScript 访问 Cookie。—可能会导致XSS攻击（跨站脚本攻击）</li>
<li><code>SameSite</code>：控制 Cookie 的跨站发送策略，防止跨站请求伪造（CSRF）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止js访问cookie</span></span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: sessionID=abc123; <span class="title class_">HttpOnly</span></span><br></pre></td></tr></table></figure>

<h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p><code>LocalStorage</code> 是一种持久化的浏览器存储机制，用于保存较大且长期有效的键值对数据。数据存储在本地，除非手动删除，否则不会随浏览器关闭或刷新而丢失。<strong>LocalStorage的优点：</strong></p>
<ul>
<li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li>
<li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li>
<li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li>
</ul>
<h4 id="LocalStorage的缺点"><a href="#LocalStorage的缺点" class="headerlink" title="LocalStorage的缺点"></a>LocalStorage的缺点</h4><ul>
<li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li>
<li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li>
<li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li>
</ul>
<h3 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h3><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p>
<h3 id="SessionStorage与LocalStorage对比"><a href="#SessionStorage与LocalStorage对比" class="headerlink" title="SessionStorage与LocalStorage对比"></a>SessionStorage与LocalStorage对比</h3><ul>
<li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>，<code>localstorage</code>存在本地硬盘，关机再打开依然存在，<code>sessionstorage</code>存在内存；</li>
<li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li>
<li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li>
</ul>
<h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p><code>IndexedDB</code> 是浏览器内的 NoSQL 数据库，允许存储大量结构化数据（例如对象），并支持事务和复杂查询操作。它适合处理大数据量，并且数据可以永久存储，直到手动清除。</p>
<ul>
<li><strong>容量</strong>：较大（通常可以达到 50MB 或更多，依赖于浏览器）。</li>
<li><strong>持久性</strong>：数据持久存储，除非手动删除或用户清除浏览器缓存。</li>
<li><strong>访问方式</strong>：通过 JavaScript API 进行操作，支持异步操作。</li>
<li><strong>适用场景</strong>：适合存储复杂的结构化数据、离线数据或需要高效读取和写入的场景。</li>
</ul>
<h3 id="Cookie、LocalStorage、SessionStorage区别"><a href="#Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="Cookie、LocalStorage、SessionStorage区别"></a>Cookie、LocalStorage、SessionStorage区别</h3><p><strong>cookie：</strong> 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</p>
<p><strong>sessionStorage：</strong> HTML5提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</p>
<blockquote>
<p><code>sessionStorage </code>不能在多个窗口或标签页之间共享数据，但是当通过&#96;&#96; window.open <code>或链接打开新页面时(不能是新窗口)，新页面会复制前一页的 </code>sessionStorage<code>。**这种复制行为**意味着原页面和新页面各自都有独立的 **</code>sessionStorage<code>**，但它们不会同步。如果一个页面修改了 **</code>sessionStorage<code>**，另一个页面不会感知到这些变化，因为每个页面都有自己的一份独立的 **</code>sessionStorage&#96;** 数据。</p>
</blockquote>
<h2 id="HTTP存储"><a href="#HTTP存储" class="headerlink" title="HTTP存储"></a>HTTP存储</h2><p><strong>HTTP存储</strong>是指与客户端和服务器之间的交互相关的存储机制，主要通过 HTTP 协议来管理数据的缓存、状态信息存储和传递。它主要通过 HTTP 头（如 <code>Cookie</code>、<code>Cache-Control</code>、<code>Expires</code>、<code>ETag</code>、<code>Last-Modified</code> 等）来控制缓存的存储方式、有效时间、是否需要重新验证等。</p>
<p>主要的 HTTP 存储机制包括：</p>
<ol>
<li><strong>Cookie</strong>：用于存储少量客户端数据，常用于会话状态保持、用户认证等。</li>
<li><strong>HTTP 缓存</strong>：通过响应头中的 <code>Cache-Control</code>、<code>Expires</code>、<code>ETag</code>、<code>Last-Modified</code> 等字段控制资源缓存和有效期。</li>
<li><strong>协商缓存</strong>：通过 <code>ETag</code> 和 <code>Last-Modified</code> 等头来验证缓存资源是否需要更新。</li>
</ol>
<h3 id="HTTP存储的优先级"><a href="#HTTP存储的优先级" class="headerlink" title="HTTP存储的优先级"></a>HTTP存储的优先级</h3><p>不同的 HTTP 存储机制在浏览器中的处理优先级是不同的，主要取决于其功能和覆盖范围。一般来说：</p>
<ol>
<li><strong>Cache-Control</strong>：最优先的字段，用于明确指定缓存的行为。</li>
<li><strong>ETag</strong> 和 <strong>Last-Modified</strong>：用于协商缓存，依赖于浏览器与服务器的协商结果来决定缓存的有效性。</li>
<li><strong>Expires</strong>：早期的缓存机制，若同时存在 <code>Cache-Control</code>，则优先遵循 <code>Cache-Control</code>。</li>
<li><strong>Cookie</strong>：每次 HTTP 请求都会附带发送给服务器，用于保持会话状态或传递小数据。</li>
</ol>
<h3 id="不同-HTTP-存储机制可以设置的字段"><a href="#不同-HTTP-存储机制可以设置的字段" class="headerlink" title="不同 HTTP 存储机制可以设置的字段"></a>不同 HTTP 存储机制可以设置的字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p><code>Cache-Control</code> 是 HTTP&#x2F;1.1 中用来控制缓存行为的响应头或请求头字段。它提供了非常灵活的缓存控制机制，常见的字段有：</p>
<ul>
<li><p>**<code>max-age=&lt;seconds&gt;</code>**：指定缓存的最大有效时间（以秒为单位）。在这段时间内，资源可以直接从缓存中读取，而不需要重新向服务器请求。</p>
<ul>
<li>示例：<code>Cache-Control: max-age=3600</code>（缓存 1 小时）</li>
</ul>
</li>
<li><p>**<code>no-cache</code>**：不直接使用缓存，需要在每次请求时向服务器验证资源的有效性（通常通过 ETag 或 Last-Modified 验证）。</p>
</li>
<li><p>**<code>no-store</code>**：完全禁止缓存，既不缓存请求的响应，也不缓存请求本身。适合敏感数据，如用户登录信息等。</p>
</li>
<li><p>**<code>public</code>**：允许该资源被浏览器和任何中间代理服务器缓存。适用于公共资源。</p>
</li>
<li><p>**<code>private</code>**：只允许该资源被浏览器缓存，禁止中间代理服务器缓存。</p>
</li>
<li><p>**<code>must-revalidate</code>**：当缓存过期时，必须重新验证资源的有效性，而不能使用过期缓存。</p>
</li>
<li><p>**<code>s-maxage=&lt;seconds&gt;</code>**：与 <code>max-age</code> 类似，但只适用于共享缓存（如代理服务器或 CDN 缓存）。</p>
</li>
<li><p>**<code>immutable</code>**：表示资源是不可变的，缓存可以永久存储，适合静态资源，如版本化的 CSS 和 JS 文件。</p>
</li>
<li><p>**<code>no-transform</code>**：禁止代理服务器对资源进行任何转换（如图片压缩、格式转换等）。</p>
</li>
</ul>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p><code>Expires</code> 是 HTTP&#x2F;1.0 中的缓存控制字段，用于设置资源的过期时间点（一个绝对的日期和时间），表示在该时间点之前，缓存是有效的。</p>
<ul>
<li><p>示例：<code>Expires: Wed, 27 Oct 2024 07:00:00 GMT</code></p>
</li>
<li><p><strong>优先级</strong>：如果响应头中同时存在 <code>Cache-Control</code> 和 <code>Expires</code>，<code>Cache-Control</code> 的优先级更高，<code>Expires</code> 会被忽略。</p>
</li>
</ul>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p><code>ETag</code> 是 HTTP 协议中用于协商缓存的字段，表示资源的唯一标识符（通常是资源内容的哈希值）。当浏览器再次请求该资源时，会发送 <code>If-None-Match</code> 字段，并携带当前缓存的 <code>ETag</code>，服务器根据这个值判断资源是否改变。</p>
<ul>
<li><p>示例：<code>ETag: &quot;5d8c72a3ed7ed&quot;</code> （服务器返回的 ETag）</p>
</li>
<li><p>如果资源没有改变，服务器返回 <code>304 Not Modified</code>，浏览器使用缓存资源；如果资源发生变化，服务器返回 <code>200 OK</code> 和新的资源内容。</p>
</li>
</ul>
<h4 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h4><ul>
<li><p>**<code>Last-Modified</code>**：服务器在响应中返回资源的最后修改时间。浏览器之后在请求该资源时，会通过 <code>If-Modified-Since</code> 字段发送最后一次缓存的 <code>Last-Modified</code> 值。服务器根据该值判断资源是否发生改变。</p>
<ul>
<li>示例：<ul>
<li>响应头：<code>Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT</code></li>
<li>请求头：<code>If-Modified-Since: Wed, 21 Oct 2024 07:28:00 GMT</code></li>
</ul>
</li>
</ul>
</li>
<li><p>如果资源未修改，服务器返回 <code>304 Not Modified</code>，浏览器使用缓存；如果资源已修改，服务器返回 <code>200 OK</code> 和新的资源内容。</p>
</li>
</ul>
<h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><p><code>Cookie</code> 是用于在客户端和服务器之间交换数据的存储机制。通常用于会话管理、用户偏好设置等。每次请求时，浏览器会自动将 Cookie 附加到请求头中。</p>
<ul>
<li>**<code>Set-Cookie</code>**：服务器用来设置 Cookie 的响应头字段。<ul>
<li><p>常见的可选字段：</p>
<ul>
<li><code>Expires</code>：设置 Cookie 的过期时间。过期时间之后，浏览器会自动删除 Cookie。</li>
<li><code>Max-Age</code>：指定 Cookie 的有效期（以秒为单位）。与 <code>Expires</code> 类似，但使用相对时间。</li>
<li><code>Domain</code>：指定 Cookie 可以访问的域。</li>
<li><code>Path</code>：指定 Cookie 的有效路径，只有在该路径下，Cookie 才会被发送。</li>
<li><code>Secure</code>：指定 Cookie 只能通过 HTTPS 发送，确保安全。</li>
<li><code>HttpOnly</code>：指定 Cookie 只能在 HTTP 请求中使用，JavaScript 无法访问此 Cookie。</li>
<li><code>SameSite</code>：防止跨站请求伪造攻击，限制第三方站点的 Cookie 传递行为。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>sessionId=abc123; Expires=Wed, 09 Jun 2024 10:18:14 GMT; Path=/; Secure; HttpOnly; SameSite=Lax</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="HTTP存储优先级总结"><a href="#HTTP存储优先级总结" class="headerlink" title="HTTP存储优先级总结"></a>HTTP存储优先级总结</h3><ol>
<li>**<code>Cache-Control</code>**：优先级最高，现代浏览器首选此字段控制缓存策略，能覆盖较多的缓存控制需求。</li>
<li>**<code>ETag</code> 和 <code>Last-Modified</code>**：用于协商缓存，依赖服务器的响应来决定是否重新获取资源。</li>
<li>**<code>Expires</code>**：作为早期缓存机制，仅在 <code>Cache-Control</code> 不存在的情况下使用。</li>
<li>**<code>Cookie</code>**：每次请求都会携带到服务器，用于维持会话状态和小量数据的存储，但不会用于资源缓存管理。</li>
</ol>
<p>通过合理使用这些 HTTP 存储机制，可以显著提升网页的性能，减少服务器负载，同时确保客户端的数据一致性和安全性。</p>
<h2 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h2><ul>
<li><p><strong>正向代理：</strong>正向代理是一个位于客户端和目标服务器之间的代理服务器。它帮助客户端（通常是浏览器或其他请求发起方）访问目标服务器，客户端通过正向代理服务器发起请求，再由代理服务器转发给目标服务器，然后将响应返回给客户端。</p>
</li>
<li><p><strong>反向代理：</strong>反向代理是代理服务器的一种，它位于服务器端，帮助服务器接收和处理来自客户端的请求。客户端并不知道目标服务器的实际地址，所有的请求都被反向代理服务器接收，并由反向代理服务器将请求转发给目标服务器，再将结果返回给客户端。</p>
</li>
</ul>
<h2 id="前端安全了解吗，说一下-XSS-和-CSRF，以及怎么规避"><a href="#前端安全了解吗，说一下-XSS-和-CSRF，以及怎么规避" class="headerlink" title="前端安全了解吗，说一下 XSS 和 CSRF，以及怎么规避"></a>前端安全了解吗，说一下 XSS 和 CSRF，以及怎么规避</h2><p><strong>XSS</strong>：<code>跨域脚本攻击</code></p>
<p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>
<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>
<ul>
<li>获取页面的数据，如DOM、cookie、localStorage；</li>
<li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>
<li>破坏页面结构；</li>
<li>流量劫持（将链接指向某网站）；</li>
</ul>
<p><strong>防御方法</strong></p>
<p>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p>
<p><strong>CSRF</strong>：<code>跨站请求伪造</code></p>
<p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>
<p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p>
<p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p>
<ul>
<li><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。</li>
<li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。</li>
<li><strong>对 Cookie 进行双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。</li>
<li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li>
</ul>
<h3 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p>
<p>攻击过程如下:</p>
<ul>
<li>客户端发送请求到服务端，请求被中间⼈截获</li>
<li>服务器向客户端发送公钥</li>
<li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li>
<li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li>
<li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</li>
<li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li>
</ul>
<h2 id="17-浏览器是如何进行界面渲染的？"><a href="#17-浏览器是如何进行界面渲染的？" class="headerlink" title="17. 浏览器是如何进行界面渲染的？"></a>17. 浏览器是如何进行界面渲染的？</h2><p>不同的渲染引擎的具体做法稍有差异，但是大体流程都是差不多的，下面以 chrome渲染引擎 的 渲染流程来说明：</p>
<ol>
<li>获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）</li>
<li>解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）</li>
<li>根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）</li>
<li>进行布局（Layout）(重排)，即为每个节点分配⼀个在屏幕上应显示的确切坐标位置</li>
<li>进⾏绘制（Paint）(重绘)，遍历渲染树节点，调⽤ GPU(图形处理器) 将元素呈现出来</li>
</ol>
<h2 id="18-前端如何实现即时通讯？websocket"><a href="#18-前端如何实现即时通讯？websocket" class="headerlink" title="18. 前端如何实现即时通讯？websocket"></a>18. 前端如何实现即时通讯？websocket</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">严格意义上: HTTP协议只能做到客户端请求服务器, 服务器做出响应, 做不到让服务器主动给客户端推送消息!</span><br></pre></td></tr></table></figure>

<p><strong>那么如果服务器数据更新了, 想要即时通知到客户端怎么办呢 ? (即时通信需求)</strong></p>
<p>即时通信需求: 服务器数据一有更新, 希望推送给到浏览器</p>
<p>提问的回答重心:</p>
<ol>
<li>即时通信有哪些方案?</li>
<li>为什么使用了其中某一个方案! websocket</li>
</ol>
<p>基于Web的前端，存在以下几种可实现即时通讯的方式：</p>
<ul>
<li><p>短轮询 (历史方案)</p>
<p>开个定时器, 每隔一段时间发请求 (实时性不强，影响性能)</p>
</li>
<li><p>Comet - ajax长轮询(历史方案)</p>
<p>发送一个请求, 服务器只要数据不更新, 就一直阻塞 (服务器压力过大)</p>
</li>
<li><p>SSE</p>
<p>(利用了http协议, 流数据的传输, 并不是严格意义的双向通信, 无法复用连接)</p>
</li>
<li><p>WebSocket (主流)</p>
<p>性能和效率都高!</p>
</li>
</ul>
<h2 id="19-说一下websocket"><a href="#19-说一下websocket" class="headerlink" title="19. 说一下websocket"></a>19. 说一下websocket</h2><p><strong>websocket是一种网络通信协议</strong>，是HTML5开始提供的一种在单个TCP连接上进行全双工通信的协议，这个对比着HTTP协议来说，HTTP协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。</p>
<p><strong>HTTP协议无法实现服务器主动向客户端发起消息</strong>，websocket连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。websocket只需要建立一次连接，就可以一直保持连接状态</p>
<h2 id="19-2-什么是轮询"><a href="#19-2-什么是轮询" class="headerlink" title="19.2 什么是轮询"></a>19.2 什么是轮询</h2><p><strong>轮询：隔一段时间进行一次查询或者询问</strong></p>
<p>轮询分为长轮询和短轮询，长轮询是基于短轮询的一个优化结果。</p>
<p><strong>短轮询：</strong></p>
<p>通过客户端定期轮询来询问服务端是否有新的信息产生，如果有则返回，没有就不响应， 缺点：也是显而易见，轮询间隔大了则信息不够实时，轮询间隔过小又会消耗过多的流量，增加服务器的负担。</p>
<p><strong>长轮询：</strong></p>
<p>是需要服务端进行更改来进行支持，客户端向服务端发送请求时，如果此时服务端没有新的信息产生，并不立刻返回，而是<code>Hold</code>住一段时间等有新的信息或者超时再返回，客户端收到服务器的应答后继续轮询。可以看到长轮询比短轮询可以减少大量无用的请求，并且客户端接收取新消息也会实时不少。减少<code>http</code>请求对性能的优化是很有利的，所以他是短轮询上的一个优化 缺点：终归来讲还是一个<code>http</code>请求，只是进行了变化而已，而且如果客户端不请求，服务端有数据的话，也会一直累积在那，不能实现实时的双向通信</p>
<p>此时的<code>webSocket</code>也就<strong>应需而生</strong>了</p>
<h2 id="20-前端怎么做SEO优化"><a href="#20-前端怎么做SEO优化" class="headerlink" title="20. 前端怎么做SEO优化"></a>20. 前端怎么做SEO优化</h2><p><strong>什么是SEO</strong></p>
<p>SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。</p>
<p><strong>为什么要做SEO</strong></p>
<p>提高网站的权重，增强搜索引擎友好度，以达到提高排名，增加流量，改善（潜在）用户体验，促进销售的作用。</p>
<p><strong>前端怎么做SEO优化</strong></p>
<ol>
<li>网站结构布局优化: 尽量简单<ul>
<li>控制首页链接数量</li>
<li>网页层级不要太深</li>
<li>控制页面大小, 减少HTTP请求, 提高网站的加载速度</li>
<li>尽量使用语义化标签</li>
<li>利用浏览器缓存</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Lavender321.github.com">流泪猫猫头</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lavender321.github.com/2023/01/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/">http://lavender321.github.com/2023/01/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Lavender321.github.com" target="_blank">Lavender's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/HTTP/">HTTP</a><a class="post-meta__tags" href="/tags/HTTPS/">HTTPS</a><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><a class="post-meta__tags" href="/tags/TCP-IP/">TCP/IP</a><a class="post-meta__tags" href="/tags/DNS/">DNS</a><a class="post-meta__tags" href="/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">三次握手</a><a class="post-meta__tags" href="/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">四次挥手</a><a class="post-meta__tags" href="/tags/token/">token</a><a class="post-meta__tags" href="/tags/%E8%B7%A8%E5%9F%9F/">跨域</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a><a class="post-meta__tags" href="/tags/Cookie/">Cookie</a><a class="post-meta__tags" href="/tags/SEO%E4%BC%98%E5%8C%96/">SEO优化</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/29/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" title="事件循环机制"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">事件循环机制</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/29/%E5%AF%B9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3/" title="对微服务的理解"><img class="cover" src="https://s2.loli.net/2023/02/19/KqwjLA8CPWlihdO.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">对微服务的理解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/21/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" title="HTTP相关知识点"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-21</div><div class="title">HTTP相关知识点</div></div></a></div><div><a href="/2023/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="https://s2.loli.net/2023/02/19/u9CT6IyGmXJnqBh.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">计算机网络</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">流泪猫猫头</div><div class="author-info__description">THE TORTURED POETS DEPARTMENT</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lavender321"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lavender321" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:r1727439300@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">浏览器进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%BB%E8%BF%9B%E7%A8%8B%EF%BC%88Browser-Process%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">浏览器主进程（Browser Process）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%88Renderer-Process%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">渲染进程（Renderer Process）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">渲染进程的主要过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E5%BB%BA-DOM-%E6%A0%91%EF%BC%88DOM-Tree-Construction%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">1. 构建 DOM 树（DOM Tree Construction）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-HTML-%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1.1 HTML 解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%98%BB%E5%A1%9E%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">1.2 阻塞行为</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97%EF%BC%88Style-Calculation%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">2. 样式计算（Style Calculation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-CSS-%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.1 CSS 解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%90%88%E5%B9%B6-CSSOM-%E5%92%8C-DOM"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.2 合并 CSSOM 和 DOM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%83%E5%B1%80%E9%98%B6%E6%AE%B5%EF%BC%88Layout%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">3. 布局阶段（Layout）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%B8%83%E5%B1%80%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">3.1 布局计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%9B%9E%E6%B5%81%E7%9A%84%E8%A7%A6%E5%8F%91"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">3.2 回流的触发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E5%B1%82%EF%BC%88Layering%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">4. 分层（Layering）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%9B%BE%E5%B1%82%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">4.1 图层的生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">4.2 层叠上下文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%98%E5%88%B6%E9%98%B6%E6%AE%B5%EF%BC%88Painting%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">5. 绘制阶段（Painting）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">5.1 绘制过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E7%BB%98%E5%88%B6%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">5.2 绘制的优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%90%88%E6%88%90%E9%98%B6%E6%AE%B5%EF%BC%88Compositing%EF%BC%89"><span class="toc-number">1.2.7.</span> <span class="toc-text">6. 合成阶段（Compositing）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%B1%82%E5%90%88%E6%88%90"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">6.1 层合成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-GPU-%E5%8A%A0%E9%80%9F"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">6.2 GPU 加速</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.8.</span> <span class="toc-text">渲染过程中的优化和注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPU-%E8%BF%9B%E7%A8%8B%EF%BC%88GPU-Process%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">GPU 进程（GPU Process）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9B%E7%A8%8B%EF%BC%88Network-Process%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">网络进程（Network Process）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E8%BF%9B%E7%A8%8B%EF%BC%88Plugin-Process%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">插件进程（Plugin Process）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%9B%E7%A8%8B%E6%88%96%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%9B%E7%A8%8B%EF%BC%88Storage-Process%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">存储进程或数据持久化进程（Storage Process）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E8%BF%9B%E7%A8%8B%EF%BC%88Audio-Process%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">音频进程（Audio Process）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%9B%92%E8%BF%9B%E7%A8%8B%EF%BC%88Sandboxed-Process%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">沙盒进程（Sandboxed Process）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%9B%E7%A8%8B%EF%BC%88Extensions-Process%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">扩展进程（Extensions Process）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.10.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-number">1.10.1.</span> <span class="toc-text">常见的浏览器进程包括：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">GC垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">垃圾回收的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%EF%BC%88Reachability%EF%BC%89%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text">可达性（Reachability）概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%88Mark-and-Sweep%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">标记清除算法（Mark and Sweep）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%88Mark-and-Compact%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">标记整理算法（Mark and Compact）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88Generational-Garbage-Collection%EF%BC%89"><span class="toc-number">2.3.3.</span> <span class="toc-text">分代回收算法（Generational Garbage Collection）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.</span> <span class="toc-text">常见的内存泄漏场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%A4%96%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">意外的全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">闭包导致的内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E5%BC%95%E7%94%A8%E6%9C%AA%E9%87%8A%E6%94%BE"><span class="toc-number">2.4.3.</span> <span class="toc-text">DOM 引用未释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E6%9C%AA%E6%B8%85%E9%99%A4"><span class="toc-number">2.4.4.</span> <span class="toc-text">事件监听器未清除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E6%88%96%E5%9B%9E%E8%B0%83"><span class="toc-number">2.4.5.</span> <span class="toc-text">被遗忘的定时器或回调</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.5.</span> <span class="toc-text">垃圾回收的优化建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">浏览器安全机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">跨域及解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">4.1.</span> <span class="toc-text">同源策略的组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">CORS（跨域资源共享）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSONP%EF%BC%88JSON-with-Padding%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">JSONP（JSON with Padding）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%EF%BC%88Server-Side-Proxy%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">服务器代理（Server-Side Proxy）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PostMessage%EF%BC%88%E7%AA%97%E5%8F%A3%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">PostMessage（窗口消息传递）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket"><span class="toc-number">4.6.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%B5%8C%E5%85%A5%EF%BC%88Cross-Origin-Resource-Embedding%EF%BC%89"><span class="toc-number">4.7.</span> <span class="toc-text">跨域资源嵌入（Cross-Origin Resource Embedding）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">4.8.</span> <span class="toc-text">nginx 反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">4.8.0.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">4.8.0.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebRTC%EF%BC%88Web-Real-Time-Communication%EF%BC%89"><span class="toc-number">4.9.</span> <span class="toc-text">WebRTC（Web Real-Time Communication）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">4.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">浏览器相关事件总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">页面生命周期事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOMContentLoaded"><span class="toc-number">5.1.1.</span> <span class="toc-text">DOMContentLoaded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load"><span class="toc-number">5.1.2.</span> <span class="toc-text">load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeunload"><span class="toc-number">5.1.3.</span> <span class="toc-text">beforeunload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unload"><span class="toc-number">5.1.4.</span> <span class="toc-text">unload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">用户交互事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.2.1.</span> <span class="toc-text">鼠标事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.2.2.</span> <span class="toc-text">键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.2.3.</span> <span class="toc-text">焦点事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.3.</span> <span class="toc-text">剪贴板事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.4.</span> <span class="toc-text">表单事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.5.</span> <span class="toc-text">网络与连接事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#online-x2F-offline"><span class="toc-number">5.5.1.</span> <span class="toc-text">online &#x2F; offline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fetch-%E4%BA%8B%E4%BB%B6%EF%BC%88Service-Worker%EF%BC%89"><span class="toc-number">5.5.2.</span> <span class="toc-text">fetch 事件（Service Worker）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E4%B8%8E%E7%AA%97%E5%8F%A3%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.6.</span> <span class="toc-text">滚动与窗口事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scroll"><span class="toc-number">5.6.1.</span> <span class="toc-text">scroll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize"><span class="toc-number">5.6.2.</span> <span class="toc-text">resize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntersectionObserver"><span class="toc-number">5.6.3.</span> <span class="toc-text">IntersectionObserver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutationObserver"><span class="toc-number">5.6.4.</span> <span class="toc-text">MutationObserver</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.7.</span> <span class="toc-text">进度事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.8.</span> <span class="toc-text">任务调度事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BF%87%E6%B8%A1%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.9.</span> <span class="toc-text">动画与过渡事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.10.</span> <span class="toc-text">自定义事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">5.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">事件代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">6.1.</span> <span class="toc-text">如何实现事件委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%AD%90%E5%85%83%E7%B4%A0%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.1.0.1.</span> <span class="toc-text">示例：使用事件委托处理多个子元素的点击事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E5%A4%84%E7%90%86%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5%E6%88%96%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text">只处理捕获阶段或冒泡阶段的事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E5%A4%84%E7%90%86%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">只处理捕获阶段的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E5%A4%84%E7%90%86%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%88%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%EF%BC%89"><span class="toc-number">6.2.2.</span> <span class="toc-text">只处理冒泡阶段的事件（默认行为）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%EF%BC%9A%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E5%92%8C%E9%98%BB%E6%AD%A2%E6%8D%95%E8%8E%B7"><span class="toc-number">6.3.</span> <span class="toc-text">阻止事件传播：阻止冒泡和阻止捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">6.3.1.</span> <span class="toc-text">阻止事件冒泡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">4.2 阻止事件捕获</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%93%E5%90%88%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E3%80%81%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.2.</span> <span class="toc-text">5. 结合事件委托、捕获和冒泡的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">6.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DOMContentLoaded-%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text">1. DOMContentLoaded 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%9B%91%E5%90%AC-DOMContentLoaded-%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.4.0.1.</span> <span class="toc-text">代码示例：监听 DOMContentLoaded 事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-load-%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.5.</span> <span class="toc-text">2. load 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%9B%91%E5%90%AC-load-%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.5.0.1.</span> <span class="toc-text">代码示例：监听 load 事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%A4%E8%80%85%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">6.6.</span> <span class="toc-text">3. 两者的事件类型和注册方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">4. 是什么类型的事件？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">6.7.1.</span> <span class="toc-text">事件流中的位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-number">6.8.</span> <span class="toc-text">5. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GET%E5%92%8CPOST%E7%9A%84%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">GET和POST的请求的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">7.1.</span> <span class="toc-text">用途</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">参数传递方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">7.1.2.</span> <span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">7.1.3.</span> <span class="toc-text">4. 幂等性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA"><span class="toc-number">7.1.4.</span> <span class="toc-text">5. 浏览器行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6"><span class="toc-number">7.1.5.</span> <span class="toc-text">6. 数据传输大小限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">7.1.6.</span> <span class="toc-text">7. 请求的可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A2%84%E5%8F%96-x2F-%E9%A2%84%E8%AF%B7%E6%B1%82"><span class="toc-number">7.1.7.</span> <span class="toc-text">8. 浏览器预取&#x2F;预请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">7.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#POST%E5%92%8CPUT%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">POST和PUT请求的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88post%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82"><span class="toc-number">9.</span> <span class="toc-text">为什么post请求会发送两次请求?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">9.1.</span> <span class="toc-text">常见的HTTP请求头和响应头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-Request-Header"><span class="toc-number">9.2.</span> <span class="toc-text">HTTP Request Header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-Responses-Header"><span class="toc-number">9.3.</span> <span class="toc-text">HTTP Responses Header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Content-Type"><span class="toc-number">9.4.</span> <span class="toc-text">Content-Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81304%E6%98%AF%E5%A4%9A%E5%A5%BD%E8%BF%98%E6%98%AF%E5%B0%91%E5%A5%BD"><span class="toc-number">9.5.</span> <span class="toc-text">HTTP状态码304是多好还是少好</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Ajax%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">9.6.</span> <span class="toc-text">说说Ajax组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BXMLHTTPRequest%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.7.</span> <span class="toc-text">请介绍一下XMLHTTPRequest对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#onreadstatechange%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.8.</span> <span class="toc-text">onreadstatechange事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%EF%BC%89"><span class="toc-number">9.9.</span> <span class="toc-text">如何上传文件（上传图片）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8C%89%E9%92%AE"><span class="toc-number">9.10.</span> <span class="toc-text">如何自定义上传文件按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax%E8%AF%B7%E6%B1%82%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88"><span class="toc-number">9.11.</span> <span class="toc-text">ajax请求如何取消</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E6%B6%88ajax%E8%AF%B7%E6%B1%82%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89"><span class="toc-number">9.12.</span> <span class="toc-text">取消ajax请求有什么意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OPTIONS%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.13.</span> <span class="toc-text">OPTIONS请求方法及使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-0-%E5%92%8C-HTTP-1-1-%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.14.</span> <span class="toc-text">HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-1-%E5%92%8C-HTTP-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.15.</span> <span class="toc-text">HTTP 1.1 和 HTTP 2.0 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%A4%B4%E5%A0%B5%E5%A1%9E"><span class="toc-number">9.16.</span> <span class="toc-text">什么是队头堵塞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">9.16.1.</span> <span class="toc-text">队头阻塞的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.17.</span> <span class="toc-text">HTTP和HTTPS协议的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E6%96%B9%E6%B3%95URL%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">9.18.</span> <span class="toc-text">GET方法URL长度限制的原因</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%88%90%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8CHTTP%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%A1%A8%E7%8E%B0%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">15.页面有多张图片，HTTP是怎样的加载表现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-HTTP2%E7%9A%84%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">16. HTTP2的头部压缩算法是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">17. HTTP请求报文的是什么样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">18. HTTP响应报文的是什么样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">10.5.</span> <span class="toc-text">19. HTTP协议的优点和缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E8%AF%B4%E4%B8%80%E4%B8%8BHTTP-3-0"><span class="toc-number">10.6.</span> <span class="toc-text">20. 说一下HTTP 3.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-HTTP%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.7.</span> <span class="toc-text">21. HTTP的两种连接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-URL%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">10.8.</span> <span class="toc-text">22. URL有哪些组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E4%B8%8E%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.9.</span> <span class="toc-text">23.与缓存相关的HTTP请求头有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">10.10.</span> <span class="toc-text">强缓存和协商缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E7%9A%84keep-alive%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">HTTP的keep-alive有什么作用？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OSI%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">OSI的七层模型是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">什么是HTTPS协议？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TLS-x2F-SSL%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">13.1.</span> <span class="toc-text">TLS&#x2F;SSL的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.2.</span> <span class="toc-text">对称加密、非对称加密是什么，有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.3.</span> <span class="toc-text">数字证书是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">13.3.1.</span> <span class="toc-text">数字证书的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.3.2.</span> <span class="toc-text">数字签名是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTPS%E9%80%9A%E4%BF%A1%EF%BC%88%E6%8F%A1%E6%89%8B%EF%BC%89%E8%BF%87%E7%A8%8B%E2%80%93%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">14.</span> <span class="toc-text">HTTPS通信（握手）过程–三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">14.1.</span> <span class="toc-text">HTTPS的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">14.2.</span> <span class="toc-text">HTTPS是如何保证安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">14.3.</span> <span class="toc-text">HTTP状态码分别代表什么意思？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2XX-%E6%88%90%E5%8A%9F"><span class="toc-number">14.3.1.</span> <span class="toc-text">2XX 成功</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3XX-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">14.3.2.</span> <span class="toc-text">3XX 重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4XX-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF"><span class="toc-number">14.3.3.</span> <span class="toc-text">4XX 客户端错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5XX-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="toc-number">14.3.4.</span> <span class="toc-text">5XX 服务器错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%A0%B7%E6%98%AF%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%8C307%EF%BC%8C303%EF%BC%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">14.4.</span> <span class="toc-text">同样是重定向，307，303，302的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS-%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">14.5.</span> <span class="toc-text">DNS 协议是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-DNS%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">14.6.</span> <span class="toc-text">11. DNS完整的查询过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">14.7.</span> <span class="toc-text">简述一下TCP的三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">14.8.</span> <span class="toc-text">TCP什么要三次握手呢？两次不行吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">14.9.</span> <span class="toc-text">简述一下TCP的四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">14.10.</span> <span class="toc-text">TCP为什么需要四次挥手呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">14.11.</span> <span class="toc-text">TCP粘包是怎么回事，如何处理?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#token%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">14.12.</span> <span class="toc-text">token是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#token%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E5%AF%86%E7%9A%84"><span class="toc-number">14.13.</span> <span class="toc-text">token是怎么加密的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E5%92%8Ctoken%E9%83%BD%E6%94%BE%E5%9C%A8header%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8A%AB%E6%8C%81cookie%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%8A%AB%E6%8C%81token"><span class="toc-number">14.14.</span> <span class="toc-text">cookie和token都放在header中，为什么会劫持cookie，不会劫持token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#token%E8%BF%87%E6%9C%9F%E5%90%8E%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0"><span class="toc-number">14.15.</span> <span class="toc-text">token过期后，页面如何实现无感刷新?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0"><span class="toc-number">14.15.1.</span> <span class="toc-text">什么是无感刷新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0"><span class="toc-number">14.15.2.</span> <span class="toc-text">实现无感刷新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B304%E8%BF%87%E7%A8%8B"><span class="toc-number">14.16.</span> <span class="toc-text">介绍下304过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8"><span class="toc-number">15.</span> <span class="toc-text">浏览器安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">15.1.</span> <span class="toc-text">有哪些可能引起前端安全的问题?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8A%AB%E6%8C%81%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F"><span class="toc-number">15.2.</span> <span class="toc-text">网络劫持有哪几种，如何防范？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">15.3.</span> <span class="toc-text">进程与线程的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.4.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">15.5.</span> <span class="toc-text">如何实现浏览器内多个标签页之间的通信?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">15.6.</span> <span class="toc-text">6. 为什么需要浏览器缓存？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">15.6.1.</span> <span class="toc-text">浏览器缓存的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%88%B7%E6%96%B0%E6%8C%89%E9%92%AE%E6%88%96%E8%80%85%E6%8C%89-F5%E3%80%81%E6%8C%89-Ctrl-F5-%EF%BC%88%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0%EF%BC%89%E3%80%81%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%9B%9E%E8%BD%A6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.7.</span> <span class="toc-text">点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0-JS-%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">15.8.</span> <span class="toc-text">浏览器渲染过程中遇到 JS 文件如何处理？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3%E7%9A%84%E9%A2%84%E8%A7%A3%E6%9E%90%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">什么是文档的预解析？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS-%E5%A6%82%E4%BD%95%E9%98%BB%E5%A1%9E%E6%96%87%E6%A1%A3%E8%A7%A3%E6%9E%90%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">CSS 如何阻塞文档解析？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-number">18.</span> <span class="toc-text">前端存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8"><span class="toc-number">18.1.</span> <span class="toc-text">浏览器存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-number">18.1.1.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">18.1.2.</span> <span class="toc-text">Cookie的特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalStorage"><span class="toc-number">18.1.3.</span> <span class="toc-text">LocalStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalStorage%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">18.1.3.1.</span> <span class="toc-text">LocalStorage的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SessionStorage"><span class="toc-number">18.1.4.</span> <span class="toc-text">SessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SessionStorage%E4%B8%8ELocalStorage%E5%AF%B9%E6%AF%94"><span class="toc-number">18.1.5.</span> <span class="toc-text">SessionStorage与LocalStorage对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexedDB"><span class="toc-number">18.1.6.</span> <span class="toc-text">IndexedDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E3%80%81LocalStorage%E3%80%81SessionStorage%E5%8C%BA%E5%88%AB"><span class="toc-number">18.1.7.</span> <span class="toc-text">Cookie、LocalStorage、SessionStorage区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%AD%98%E5%82%A8"><span class="toc-number">18.2.</span> <span class="toc-text">HTTP存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">18.2.1.</span> <span class="toc-text">HTTP存储的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C-HTTP-%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">18.2.2.</span> <span class="toc-text">不同 HTTP 存储机制可以设置的字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-Control"><span class="toc-number">18.2.2.1.</span> <span class="toc-text">Cache-Control</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Expires"><span class="toc-number">18.2.2.2.</span> <span class="toc-text">Expires</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ETag"><span class="toc-number">18.2.2.3.</span> <span class="toc-text">ETag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Last-Modified-%E5%92%8C-If-Modified-Since"><span class="toc-number">18.2.2.4.</span> <span class="toc-text">Last-Modified 和 If-Modified-Since</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-1"><span class="toc-number">18.2.2.5.</span> <span class="toc-text">Cookie</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%AD%98%E5%82%A8%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%BB%E7%BB%93"><span class="toc-number">18.2.3.</span> <span class="toc-text">HTTP存储优先级总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.3.</span> <span class="toc-text">正向代理和反向代理的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B-XSS-%E5%92%8C-CSRF%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%80%8E%E4%B9%88%E8%A7%84%E9%81%BF"><span class="toc-number">18.4.</span> <span class="toc-text">前端安全了解吗，说一下 XSS 和 CSRF，以及怎么规避</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">18.4.1.</span> <span class="toc-text">什么是中间人攻击？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%95%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%EF%BC%9F"><span class="toc-number">18.5.</span> <span class="toc-text">17. 浏览器是如何进行界面渲染的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%9Fwebsocket"><span class="toc-number">18.6.</span> <span class="toc-text">18. 前端如何实现即时通讯？websocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E8%AF%B4%E4%B8%80%E4%B8%8Bwebsocket"><span class="toc-number">18.7.</span> <span class="toc-text">19. 说一下websocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E8%AF%A2"><span class="toc-number">18.8.</span> <span class="toc-text">19.2 什么是轮询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%89%8D%E7%AB%AF%E6%80%8E%E4%B9%88%E5%81%9ASEO%E4%BC%98%E5%8C%96"><span class="toc-number">18.9.</span> <span class="toc-text">20. 前端怎么做SEO优化</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/%E9%93%B6%E8%A1%8C/" title="银行"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="银行"/></a><div class="content"><a class="title" href="/2024/10/22/%E9%93%B6%E8%A1%8C/" title="银行">银行</a><time datetime="2024-10-22T02:15:44.000Z" title="发表于 2024-10-22 10:15:44">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/16/nodejs%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="nodejs面试笔记"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nodejs面试笔记"/></a><div class="content"><a class="title" href="/2024/10/16/nodejs%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="nodejs面试笔记">nodejs面试笔记</a><time datetime="2024-10-16T02:23:20.000Z" title="发表于 2024-10-16 10:23:20">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/16/%E5%B0%8F%E7%B1%B3/" title="小米"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小米"/></a><div class="content"><a class="title" href="/2024/10/16/%E5%B0%8F%E7%B1%B3/" title="小米">小米</a><time datetime="2024-10-16T02:12:12.000Z" title="发表于 2024-10-16 10:12:12">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/" title="华为前端面试合集"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="华为前端面试合集"/></a><div class="content"><a class="title" href="/2024/10/15/%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/" title="华为前端面试合集">华为前端面试合集</a><time datetime="2024-10-15T08:35:34.000Z" title="发表于 2024-10-15 16:35:34">2024-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/14/%E6%95%B0%E5%AD%97/" title="数字"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数字"/></a><div class="content"><a class="title" href="/2024/10/14/%E6%95%B0%E5%AD%97/" title="数字">数字</a><time datetime="2024-10-14T08:44:56.000Z" title="发表于 2024-10-14 16:44:56">2024-10-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 流泪猫猫头</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>