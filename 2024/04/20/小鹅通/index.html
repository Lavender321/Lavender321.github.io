<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>小鹅通 | Lavender's blog</title><meta name="author" content="流泪猫猫头"><meta name="copyright" content="流泪猫猫头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="项目页面有做SEO优化吗搜索引擎优化（SEO）是提高网站在搜索引擎中的可见性的一种策略，目的是吸引更多的自然（非付费）流量到网站。优化你的网站以适应搜索引擎的标准，可以显著提高其在搜索结果中的排名。以下是一些常见的SEO优化策略及其执行方法： 1. 关键词优化 研究关键词：使用工具如Google关键词规划师、Ahrefs、SEMrush等来找到与你的业务、产品或服务相关的关键词。 关键词部署：在网">
<meta property="og:type" content="article">
<meta property="og:title" content="小鹅通">
<meta property="og:url" content="http://lavender321.github.com/2024/04/20/%E5%B0%8F%E9%B9%85%E9%80%9A/index.html">
<meta property="og:site_name" content="Lavender&#39;s blog">
<meta property="og:description" content="项目页面有做SEO优化吗搜索引擎优化（SEO）是提高网站在搜索引擎中的可见性的一种策略，目的是吸引更多的自然（非付费）流量到网站。优化你的网站以适应搜索引擎的标准，可以显著提高其在搜索结果中的排名。以下是一些常见的SEO优化策略及其执行方法： 1. 关键词优化 研究关键词：使用工具如Google关键词规划师、Ahrefs、SEMrush等来找到与你的业务、产品或服务相关的关键词。 关键词部署：在网">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png">
<meta property="article:published_time" content="2024-04-20T14:49:30.000Z">
<meta property="article:modified_time" content="2024-08-05T14:43:08.722Z">
<meta property="article:author" content="流泪猫猫头">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png"><link rel="shortcut icon" href="https://s2.loli.net/2022/10/08/k5M7H1NdmnZgtlY.png"><link rel="canonical" href="http://lavender321.github.com/2024/04/20/%E5%B0%8F%E9%B9%85%E9%80%9A/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 流泪猫猫头","link":"链接: ","source":"来源: Lavender's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '小鹅通',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-05 22:43:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Lavender's blog"><span class="site-name">Lavender's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">小鹅通</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-20T14:49:30.000Z" title="发表于 2024-04-20 22:49:30">2024-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-05T14:43:08.722Z" title="更新于 2024-08-05 22:43:08">2024-08-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="小鹅通"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="项目页面有做SEO优化吗"><a href="#项目页面有做SEO优化吗" class="headerlink" title="项目页面有做SEO优化吗"></a>项目页面有做SEO优化吗</h1><p>搜索引擎优化（SEO）是提高网站在搜索引擎中的可见性的一种策略，目的是吸引更多的自然（非付费）流量到网站。优化你的网站以适应搜索引擎的标准，可以显著提高其在搜索结果中的排名。以下是一些常见的SEO优化策略及其执行方法：</p>
<h3 id="1-关键词优化"><a href="#1-关键词优化" class="headerlink" title="1. 关键词优化"></a>1. 关键词优化</h3><ul>
<li><strong>研究关键词</strong>：使用工具如Google关键词规划师、Ahrefs、SEMrush等来找到与你的业务、产品或服务相关的关键词。</li>
<li><strong>关键词部署</strong>：在网站的内容中自然地使用这些关键词，特别是在标题、描述、主体文本、URLs和图片的alt属性中。</li>
</ul>
<h3 id="2-高质量内容"><a href="#2-高质量内容" class="headerlink" title="2. 高质量内容"></a>2. 高质量内容</h3><ul>
<li><strong>创建有价值的内容</strong>：确保你的内容对目标受众有用，能解决他们的问题或提供所需信息。</li>
<li><strong>定期更新内容</strong>：定期更新你的网站内容，保持其相关性和新鲜感，这是提高网站权威性和吸引重复访问者的重要方式。</li>
</ul>
<h3 id="3-技术SEO"><a href="#3-技术SEO" class="headerlink" title="3. 技术SEO"></a>3. 技术SEO</h3><ul>
<li><strong>提升网站速度</strong>：使用工具如Google PageSpeed Insights来分析和改进网页加载速度。</li>
<li><strong>移动友好</strong>：确保你的网站对移动设备友好，使用响应式设计使网站在所有设备上都能良好显示。</li>
<li><strong>使用HTTPS</strong>：确保你的网站安全，使用HTTPS加密网站，这是搜索引擎的一个正面评价因素。</li>
<li><strong>优化URL结构</strong>：使用易于理解的URL结构，确保URL包含关键词，并尽量简短。</li>
</ul>
<h3 id="4-用户体验（UX）"><a href="#4-用户体验（UX）" class="headerlink" title="4. 用户体验（UX）"></a>4. 用户体验（UX）</h3><ul>
<li><strong>导航简便</strong>：确保网站结构清晰，用户能够轻松找到他们需要的信息。</li>
<li><strong>界面友好</strong>：设计一个吸引人且易于使用的界面。</li>
</ul>
<h3 id="5-内链和外链"><a href="#5-内链和外链" class="headerlink" title="5. 内链和外链"></a>5. 内链和外链</h3><ul>
<li><strong>内部链接</strong>：在你的网站内容之间使用合理的内部链接，以帮助搜索引擎更好地理解网站结构，同时提高页面的权威性和排名。</li>
<li><strong>获取外部链接</strong>：从其他权威网站获取高质量的回链，这是提高你网站权威性的重要途径。</li>
</ul>
<h3 id="6-元标签和标题优化"><a href="#6-元标签和标题优化" class="headerlink" title="6. 元标签和标题优化"></a>6. 元标签和标题优化</h3><ul>
<li><strong>元描述标签</strong>：每个页面都应有一个独特的元描述标签，它应包含关键词，同时吸引用户点击。</li>
<li><strong>标题标签</strong>：确保使用适当的标题标签（H1, H2, H3等）来组织内容，并在H1标签中包含主关键词。</li>
</ul>
<h3 id="7-图像优化"><a href="#7-图像优化" class="headerlink" title="7. 图像优化"></a>7. 图像优化</h3><ul>
<li><strong>优化图像大小</strong>：减小图像文件的大小，以加快页面加载速度。</li>
<li><strong>Alt标签</strong>：为所有图像使用描述性的alt标签，包含关键词，有助于图像搜索排名。</li>
</ul>
<h3 id="8-社交媒体整合"><a href="#8-社交媒体整合" class="headerlink" title="8. 社交媒体整合"></a>8. 社交媒体整合</h3><ul>
<li><strong>社交信号</strong>：虽然社交媒体信号直接影响SEO排名的程度仍有争议，但在社交媒体上活跃无疑可以提高品牌曝光率，间接吸引更多的网站访问量。</li>
</ul>
<p>这些SEO策略需要持续的努力和时间来实现效果。SEO不是一次性的任务，而是一个持续的过程，需要根据搜索引擎算法的更新和网站性能的监控不断调整策略。</p>
<h1 id="怎么实现响应式布局？"><a href="#怎么实现响应式布局？" class="headerlink" title="怎么实现响应式布局？"></a>怎么实现响应式布局？</h1><p>flex布局和Grid布局</p>
<h1 id="position-有什么属性"><a href="#position-有什么属性" class="headerlink" title="position 有什么属性"></a>position 有什么属性</h1><h1 id="ES6的Promise解决什么问题？Promise原理？"><a href="#ES6的Promise解决什么问题？Promise原理？" class="headerlink" title="ES6的Promise解决什么问题？Promise原理？"></a>ES6的Promise解决什么问题？Promise原理？</h1><h2 id="ES6中的Promise解决的问题–回调函数"><a href="#ES6中的Promise解决的问题–回调函数" class="headerlink" title="ES6中的Promise解决的问题–回调函数"></a>ES6中的Promise解决的问题–回调函数</h2><p>ES6引入的<code>Promise</code>是一个用于异步编程的重要特性。在<code>Promise</code>之前，JavaScript中的异步编程主要依赖于回调函数（callback）。使用回调函数处理复杂的异步流程经常会导致以下几个问题：</p>
<ol>
<li><p><strong>回调地狱（Callback Hell）</strong>：</p>
<ul>
<li>当多个异步操作需要顺序执行时，每个异步操作的回调函数内部需要启动下一个异步操作，这会导致代码向右不断延伸（形成所谓的”回调金字塔”），使代码难以阅读和维护。</li>
</ul>
</li>
<li><p><strong>错误处理困难</strong>：</p>
<ul>
<li>在多层嵌套的回调中，错误处理变得复杂。每一层的回调通常需要自己处理错误，或者将错误传递给外层，缺乏统一的错误处理机制。</li>
</ul>
</li>
<li><p><strong>控制流程不清晰</strong>：</p>
<ul>
<li>回调模式使得跟踪程序的执行流程变得困难，尤其是在有多个异步操作交织时。</li>
</ul>
</li>
</ol>
<p><code>Promise</code>为以上问题提供了解决方案，它允许你以更连贯和可预测的方式处理异步操作。</p>
<h2 id="Promise的原理"><a href="#Promise的原理" class="headerlink" title="Promise的原理"></a>Promise的原理</h2><p><code>Promise</code>是一个代表了异步操作最终完成或失败的对象。它有以下几个核心概念：</p>
<h3 id="状态："><a href="#状态：" class="headerlink" title="状态："></a><strong>状态</strong>：</h3><ul>
<li><code>pending</code>：初始状态，既不是成功，也不是失败状态。</li>
<li><code>fulfilled</code>（或 <code>resolved</code>）：意味着操作成功完成。</li>
<li><code>rejected</code>：意味着操作失败。</li>
</ul>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a><strong>结果</strong>：</h3><ul>
<li>一旦<code>Promise</code>被解决（fulfilled）或被拒绝（rejected），它就会有一个与之相关的值或拒绝的原因。这个值或原因在Promise状态改变后不会再变。</li>
</ul>
<h3 id="链式调用："><a href="#链式调用：" class="headerlink" title="链式调用："></a><strong>链式调用</strong>：</h3><ul>
<li><code>Promise</code>支持链式调用，即<code>then()</code>方法调用另一个<code>then()</code>方法，这使得异步操作和其后续操作（如进一步处理数据、链式处理错误）的管理变得简洁。</li>
</ul>
<h2 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h2><h3 id="创建Promise："><a href="#创建Promise：" class="headerlink" title="创建Promise："></a><strong>创建Promise</strong>：</h3><ul>
<li>一个<code>Promise</code>对象在创建时需要传递一个执行器函数（executor function），这个函数会立即执行，并接受两个参数：<code>resolve</code>和<code>reject</code>。这两个参数也是函数，用于改变<code>Promise</code>的状态。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="处理结果："><a href="#处理结果：" class="headerlink" title="处理结果："></a><strong>处理结果</strong>：</h3><ul>
<li>使用<code>then()</code>方法来设定<code>fulfilled</code>状态和<code>rejected</code>状态的回调函数。</li>
<li><code>then()</code>方法返回一个新的<code>Promise</code>，使得链式调用成为可能。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">/* 成功时的处理 */</span> &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="comment">/* 失败时的处理 */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="错误捕获："><a href="#错误捕获：" class="headerlink" title="错误捕获："></a><strong>错误捕获</strong>：</h3><ul>
<li><code>catch()</code>方法是<code>then(null, rejection)</code>的语法糖，专门用来捕获前面<code>Promise</code>链中的错误。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="comment">/* 错误处理 */</span> &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="链式处理："><a href="#链式处理：" class="headerlink" title="链式处理："></a><strong>链式处理</strong>：</h3><ul>
<li>由于每个<code>then()</code>方法都返回一个新的<code>Promise</code>，可以通过链式调用来顺序执行多个异步操作，每一个操作的输出可以作为下一个操作的输入。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="title function_">doSomethingElse</span>(result))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">newResult</span> =&gt;</span> <span class="title function_">doThirdThing</span>(newResult))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Promise</code>提供了一种强大且灵活的方式来处理JavaScript中的异步操作，避免回调函数。</p>
<h1 id="Promise-all-处理并发？"><a href="#Promise-all-处理并发？" class="headerlink" title="Promise.all()处理并发？"></a>Promise.all()处理并发？</h1><p><code>Promise.all()</code> 允许开发者处理多个并发异步操作，此方法主要用于当你有多个异步任务同时进行，且你需要等待所有的异步操作完成时，它可以帮助你简洁地管理这些操作。</p>
<h2 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h2><p><code>Promise.all()</code> 接收一个 Promise 对象的数组作为参数，返回一个新的 Promise 对象。这个新的 Promise 会在所有传入的 Promise 对象都成功完成时被解决，或者在其中任何一个 Promise 失败时被拒绝。</p>
<h2 id="处理并发步骤"><a href="#处理并发步骤" class="headerlink" title="处理并发步骤"></a>处理并发步骤</h2><h3 id="并行执行："><a href="#并行执行：" class="headerlink" title="并行执行："></a><strong>并行执行</strong>：</h3><ul>
<li>传递给 <code>Promise.all()</code> 的每个 Promise 是并行执行的。这意味着它们各自独立进行，不会等待其他 Promise 完成才开始。例如，如果你传递了三个异步网络请求的 Promise，它们将同时发送。</li>
</ul>
<h3 id="结果聚合："><a href="#结果聚合：" class="headerlink" title="结果聚合："></a><strong>结果聚合</strong>：</h3><ul>
<li><code>Promise.all()</code> 会收集所有 Promise 的结果并将它们聚合为一个数组。这个数组中的元素顺序与传入 Promise 数组的顺序相同，对应每个 Promise 的解决值。</li>
</ul>
<h3 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a><strong>错误处理</strong>：</h3><ul>
<li>如果任何一个传入的 Promise 被拒绝，<code>Promise.all()</code> 返回的 Promise 将立即拒绝，并且拒绝的原因将是第一个拒绝的 Promise 的原因。</li>
<li>这意味着如果一个 Promise 失败了，即使其他 Promise 可能还在执行，<code>Promise.all()</code> 也会结束。</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个使用 <code>Promise.all()</code> 的示例，展示了如何同时进行多个异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">responses</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(responses.<span class="title function_">map</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results);  <span class="comment">// 一个包含所有响应数据的数组</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;One of the promises failed:&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，三个网络请求并行发送。如果所有请求成功，结果数组中将包含每个请求的数据。如果任何请求失败，错误处理函数将被调用。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><code>Promise.all()</code> 非常适用于以下场景：</p>
<ul>
<li>你需要同时执行多个异步任务，如同时从多个数据源获取数据。</li>
<li>你需要等待所有任务都完成才能继续执行代码，如初始化需要多个配置数据的应用。</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>由于 <code>Promise.all()</code> 对错误是”全有或全无”的处理方式，如果你希望即使某些请求失败也能处理其他成功的请求，你可能需要为每个单独的 Promise 添加错误处理逻辑，使它们不会真正地拒绝，而是解决一个错误值或状态。</li>
</ul>
<p>总之，<code>Promise.all()</code> 是一个处理多个并发异步操作的强大工具，可以简化代码并减少错误处理的复杂性，只要你合理地处理其中可能的错误。</p>
<h1 id="有100个请求，每个Promise-all只能处理10个请求，要怎么实现？"><a href="#有100个请求，每个Promise-all只能处理10个请求，要怎么实现？" class="headerlink" title="有100个请求，每个Promise.all只能处理10个请求，要怎么实现？"></a>有100个请求，每个Promise.all只能处理10个请求，要怎么实现？</h1><p>如果你需要处理100个异步请求，但每次只能通过<code>Promise.all()</code>同时处理10个，你可以采用分批处理的方法来实现。这种方法涉及将请求分组，每组包含10个请求，然后顺序或并行地处理每一组请求。这里有两种基本的实现方式：一种是顺序处理每一批请求，另一种是尽可能快地开始每一批请求，但仍然每批处理10个。下面详细说明这两种方法的实现：</p>
<h2 id="顺序执行每批请求"><a href="#顺序执行每批请求" class="headerlink" title="顺序执行每批请求"></a>顺序执行每批请求</h2><p>这种方法中，你将等待当前批次的所有请求完成后，再处理下一批次。这种方式的好处是流量控制和错误处理更加容易，缺点是总体处理时间可能较长。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processRequestsSequentially</span>(<span class="params">allRequests, batchSize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">processBatch</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 取出一批处理</span></span><br><span class="line">        <span class="keyword">const</span> batch = allRequests.<span class="title function_">slice</span>(index, index + batchSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(batch)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Batch results&#x27;</span>, results);</span><br><span class="line">                index += batchSize;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; allRequests.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">processBatch</span>(); <span class="comment">// 递归处理下一批</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> results;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">processBatch</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 createRequest 是创建请求的函数</span></span><br><span class="line"><span class="keyword">const</span> allRequests = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">100</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="title function_">fetch</span>(<span class="string">`https://api.example.com/data?id=<span class="subst">$&#123;i&#125;</span>`</span>));</span><br><span class="line"><span class="title function_">processRequestsSequentially</span>(allRequests, <span class="number">10</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;All batches completed&#x27;</span>))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error processing batches&#x27;</span>, error));</span><br></pre></td></tr></table></figure>

<h2 id="并行执行每批请求"><a href="#并行执行每批请求" class="headerlink" title="并行执行每批请求"></a>并行执行每批请求</h2><p>在这种方法中，你会尽快地开始每批请求的处理，但每一批中仍然只有10个请求同时处理。这种方法可以更快地完成所有请求，但对服务器的压力更大，且并行处理错误可能更复杂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processRequestsInParallel</span>(<span class="params">allRequests, batchSize</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> batches = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allRequests.<span class="property">length</span>; i += batchSize) &#123;</span><br><span class="line">        <span class="keyword">const</span> batch = allRequests.<span class="title function_">slice</span>(i, i + batchSize);</span><br><span class="line">        batches.<span class="title function_">push</span>(<span class="title class_">Promise</span>.<span class="title function_">all</span>(batch));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(batches)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;All batches completed&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> results.<span class="title function_">flat</span>(); <span class="comment">// 将所有批次结果平铺成一个数组</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allRequests = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">100</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="title function_">fetch</span>(<span class="string">`https://api.example.com/data?id=<span class="subst">$&#123;i&#125;</span>`</span>));</span><br><span class="line"><span class="title function_">processRequestsInParallel</span>(allRequests, <span class="number">10</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Results of all requests:&#x27;</span>, results))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error processing batches&#x27;</span>, error));</span><br></pre></td></tr></table></figure>

<h2 id="选择实现方式"><a href="#选择实现方式" class="headerlink" title="选择实现方式"></a>选择实现方式</h2><p>选择哪种方式取决于你的具体需求：</p>
<ul>
<li>如果希望尽量减少对服务器的压力，或者需要按顺序处理请求结果（例如，后一批次依赖前一批次的结果），则应选择顺序执行。</li>
<li>如果希望尽可能快地完成所有请求，可以选择并行执行，但需要确保服务器能够处理较高的并发请求，并且应当准备好处理复杂的错误情况。</li>
</ul>
<p>在实际应用中，这两种方法都是处理大量并发请求的有效策略，可以根据实际情况进行选择和调整。</p>
<h1 id="Vue的双向绑定如何实现？"><a href="#Vue的双向绑定如何实现？" class="headerlink" title="Vue的双向绑定如何实现？"></a>Vue的双向绑定如何实现？</h1><p>Vue.js 的双向数据绑定是其核心特性之一，它极大简化了界面和状态之间的同步过程。Vue 实现双向绑定主要依靠两大机制：响应式系统和指令系统。在 Vue 2.x 和 Vue 3.x 中，这两者的实现细节有所不同，这里将分别讲解。</p>
<h3 id="Vue-2-x-的双向绑定"><a href="#Vue-2-x-的双向绑定" class="headerlink" title="Vue 2.x 的双向绑定"></a>Vue 2.x 的双向绑定</h3><p>在 Vue 2.x 中，双向数据绑定是通过响应式系统和 <code>v-model</code> 指令实现的。</p>
<ol>
<li><p><strong>响应式系统</strong>：</p>
<ul>
<li>**基于 <code>Object.defineProperty()</code>**：Vue 2 使用这个方法将数据对象的每个属性转换成 getter&#x2F;setter。Vue 在内部跟踪依赖（即哪些组件依赖于这些属性），并在属性值改变时通知它们。</li>
<li>当组件渲染时，Vue 会记录所有被访问的属性作为依赖。当这些属性的setter被调用时（即属性值改变时），相关的组件会重新渲染。</li>
</ul>
</li>
<li><p><strong><code>v-model</code> 指令</strong>：</p>
<ul>
<li>在表单元素上使用 <code>v-model</code> 指令可以创建数据和视图之间的双向绑定。</li>
<li>对于不同的表单输入元素（如 <code>input</code>, <code>select</code>, <code>textarea</code>），Vue 会处理用户的输入事件以更新数据模型，并响应数据模型的变化来更新界面。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这行代码实质上是以下代码的语法糖：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">&quot;message = $event.target.value&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>当用户在输入框中输入时，<code>input</code> 事件被触发，并更新 <code>message</code> 数据属性；当 <code>message</code> 属性变化时，输入框中的值也会更新。</p>
</li>
</ol>
<h3 id="Vue-3-x-的双向绑定"><a href="#Vue-3-x-的双向绑定" class="headerlink" title="Vue 3.x 的双向绑定"></a>Vue 3.x 的双向绑定</h3><p>Vue 3 重写了响应式系统，引入了基于 ES6 的 <code>Proxy</code> 来替代 <code>Object.defineProperty()</code>。</p>
<ol>
<li><p><strong>响应式系统</strong>：</p>
<ul>
<li>**基于 <code>Proxy</code>**：<code>Proxy</code> 可以拦截对象的任意操作，包括属性读取、设置值、属性枚举等，而不仅仅是获取和设置属性。这使得 Vue 3 的响应式系统更为强大和高效，同时也支持数组索引和 <code>Map</code>, <code>Set</code> 等数据结构的响应式变化。</li>
<li>与 Vue 2 类似，Vue 3 通过追踪渲染函数中的属性访问来建立依赖，并在属性变化时触发更新。</li>
</ul>
</li>
<li><p><strong><code>v-model</code> 指令</strong>：</p>
<ul>
<li>Vue 3 中 <code>v-model</code> 的用法与 Vue 2 类似，但提供了更多的自定义选项。例如，可以自定义 <code>v-model</code> 更新的事件或属性。</li>
<li>Vue 3 支持在同一个组件上使用多个 <code>v-model</code> 绑定，这对于开发复杂组件非常有用。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这行代码的背后逻辑和 Vue 2 类似，但得益于 <code>Proxy</code> 的能力，Vue 3 的内部机制更为高效和强大。</p>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Vue 的双向绑定通过其响应式系统和特殊的指令（如 <code>v-model</code>）实现。Vue 2 依赖 <code>Object.defineProperty()</code> 来追踪依赖和通知变更，而 Vue 3 则使用了 <code>Proxy</code>，提供了更全面的语言级别的拦截能力。这些机制共同协作，使得开发者可以简单、高效地在用户界面和数据状态之间建立双向</p>
<p>连接。</p>
<h1 id="Vue3与Vue2的区别？Vue3的响应式与Vue2的有什么不同？"><a href="#Vue3与Vue2的区别？Vue3的响应式与Vue2的有什么不同？" class="headerlink" title="Vue3与Vue2的区别？Vue3的响应式与Vue2的有什么不同？"></a>Vue3与Vue2的区别？Vue3的响应式与Vue2的有什么不同？</h1><p>Vue 3 是对 Vue.js 框架的一次重大更新，它在许多方面都有所改进和增强。这些变化不仅涉及到内部架构的优化，也包括了API的更新，以及对响应式系统的重构。下面详细介绍 Vue 2 与 Vue 3 之间的主要区别以及响应式系统的不同。</p>
<h2 id="Vue-3-与-Vue-2-的主要区别"><a href="#Vue-3-与-Vue-2-的主要区别" class="headerlink" title="Vue 3 与 Vue 2 的主要区别"></a>Vue 3 与 Vue 2 的主要区别</h2><h3 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a><strong>性能提升</strong></h3><ul>
<li>Vue 3 提供了更好的性能，包括更快的挂载时间、更小的打包大小以及更高效的组件初始化速度。这得益于 Vue 3 的响应式系统重写和虚拟DOM的优化。</li>
</ul>
<h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a><strong>Composition API</strong></h3><ul>
<li>Vue 3 引入了一个新的组合式 API（Composition API），这是一种新的方式来组织组件逻辑。相比于 Vue 2 使用的选项式 API（Options API），Composition API 提供了更好的逻辑复用和代码组织方式，特别是在处理复杂组件时更加灵活。</li>
</ul>
<h3 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a><strong>更好的 TypeScript 支持</strong></h3><ul>
<li>Vue 3 从一开始就考虑了对 TypeScript 的支持。Vue 3 的源代码完全使用 TypeScript 编写，提供了更好的类型推断和类型检查。</li>
</ul>
<h3 id="新的响应式系统"><a href="#新的响应式系统" class="headerlink" title="新的响应式系统"></a><strong>新的响应式系统</strong></h3><ul>
<li>Vue 3 的响应式系统基于 Proxy 对象重新实现，取代了 Vue 2 基于 Object.defineProperty 的实现。这使得 Vue 3 的响应式系统更加高效和强大，支持对更多类型的数据结构，如 Maps、Sets 等。</li>
</ul>
<h4 id="片段-Fragments"><a href="#片段-Fragments" class="headerlink" title="片段 (Fragments)"></a><strong>片段 (Fragments)</strong></h4><ul>
<li>Vue 3 支持多个根节点的组件，这意味着你可以在单个组件的模板中返回多个元素，而无需一个额外的根元素包裹它们。</li>
</ul>
<h4 id="改进的虚拟-DOM"><a href="#改进的虚拟-DOM" class="headerlink" title="改进的虚拟 DOM"></a><strong>改进的虚拟 DOM</strong></h4><ul>
<li>Vue 3 的虚拟 DOM 重写了 diff 算法，减少了内存占用并提高了渲染效率。</li>
</ul>
<h4 id="自定义渲染器-API"><a href="#自定义渲染器-API" class="headerlink" title="自定义渲染器 API"></a><strong>自定义渲染器 API</strong></h4><ul>
<li>Vue 3 提供了创建自定义渲染器的 API。这使得 Vue 不仅可以用于 web 开发，还可以用来创建跨平台应用。</li>
</ul>
<h3 id="响应式系统的不同"><a href="#响应式系统的不同" class="headerlink" title="响应式系统的不同"></a>响应式系统的不同</h3><p>Vue 2 的响应式系统依赖于 <code>Object.defineProperty</code>，这限制了它只能监测对象的属性变动，不能直接监测到对象属性的添加和删除，也无法监测到数组索引和长度的变化。</p>
<p>Vue 3 使用 <code>Proxy</code> 对象重写了响应式系统，这带来了以下优势：</p>
<ul>
<li><strong>Proxy</strong> 可以拦截更多的操作，包括属性的添加、删除和数组索引的变化。</li>
<li><strong>Proxy</strong> 的性能更优，且没有 <code>Object.defineProperty</code> 那样的初始化成本。</li>
<li><strong>Proxy</strong> 允许 Vue 3 直接支持所有类型的数据结构，包括 Map、Set、WeakMap 和 WeakSet。</li>
</ul>
<p>总的来说，Vue 3 不仅在性能上有所提升，还在开发体验上带来了显著的改进，特别是对于使用 TypeScript 和处理复杂逻辑的大型项目来说，Vue 3 提供了更强大的工具和更灵活的API设计。</p>
<h1 id="前后端登录态如何确定"><a href="#前后端登录态如何确定" class="headerlink" title="前后端登录态如何确定"></a>前后端登录态如何确定</h1><p>前后端管理登录态的方式对于维持用户的登录状态和确保应用安全性至关重要。常见的实现方法包括使用会话（Session）和基于令牌（Token）的策略，如JWT（JSON Web Tokens）。这些方法各有优缺点，具体使用哪种方案取决于应用的需求、安全要求以及开发和维护的便利性。</p>
<h2 id="使用会话（Session）管理登录态"><a href="#使用会话（Session）管理登录态" class="headerlink" title="使用会话（Session）管理登录态"></a>使用会话（Session）管理登录态</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li><strong>会话创建</strong>：用户登录时，服务器验证用户的凭证（如用户名和密码）。验证成功后，服务器创建一个会话，并将其存储在服务器的内存或数据库中。</li>
<li><strong>会话标识</strong>：服务器生成一个唯一的会话ID，并通过HTTP响应，通常在Cookie中，返回给客户端。</li>
<li><strong>会话存储与验证</strong>：客户端后续的每个请求都会携带这个会话ID，服务器接收到请求后，会查找匹配的会话ID，如果找到有效的会话，则认为用户处于登录状态。</li>
<li><strong>会话过期</strong>：会话可以设置超时时间，过期后自动失效。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>简单易实现，服务器控制会话，可以主动管理会话的生命周期和有效性。</li>
<li>安全性相对较高，因为敏感数据如用户权限等存储在服务器端。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>占用服务器资源，尤其是在用户量大时，会对服务器性能产生影响。</li>
<li>不便于在多服务器或分布式环境中共享会话状态，需要额外的会话管理机制。</li>
</ul>
<h2 id="使用令牌（Token）管理登录态（JWT）"><a href="#使用令牌（Token）管理登录态（JWT）" class="headerlink" title="使用令牌（Token）管理登录态（JWT）"></a>使用令牌（Token）管理登录态（JWT）</h2><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li><strong>令牌创建</strong>：用户登录成功后，服务器基于用户的一些信息生成一个令牌，通常包含用户ID、权限标识和令牌过期时间等信息，并将其签名后返回给客户端。<code>token=Header+Payload+Signature</code></li>
<li><strong>客户端存储</strong>：客户端收到令牌后，通常将其存储在LocalStorage、SessionStorage或其他安全的地方。</li>
<li><strong>发送请求</strong>：客户端在随后的请求中通常通过HTTP头（如<code>Authorization: Bearer &lt;token&gt;</code>）携带这个令牌。</li>
<li><strong>服务器验证</strong>：服务器接收到请求后，验证令牌的签名和有效性，如果验证通过，则提取令牌中的用户信息，完成权限验证。</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>无状态和可扩展，不需要在服务器上存储会话信息，易于实现服务的扩展。</li>
<li>客户端和服务器之间交互简单，适合单页应用（SPA）和移动应用。</li>
<li>适用于分布式系统和微服务架构，因为令牌包含了所有用户状态信息。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>安全风险相对较高，如果令牌被截获，攻击者可以获取用户的访问权限。</li>
<li>令牌一旦发出，除非过期，否则无法从服务器端控制其失效。</li>
</ul>
<h3 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h3><p>无论选择哪种方式，都必须注意保护用户数据和凭据的安全性：</p>
<ul>
<li>使用HTTPS来加密客户端和服务器之间的通信，防止数据在传输过程中被窃听或篡改。</li>
<li>对于JWT等令牌，需要确保使用强大的密钥和算法进行签名。</li>
<li>对Cookie进行安全设置，如设置HttpOnly、Secure属性，防止跨站脚本攻击（XSS）读取Cookie。</li>
</ul>
<p>综上所述，选择合适的登录态管理方案需要根据具体情况选择最适合项目需求的工具。在云和微服务架构日益流行的</p>
<h1 id="页面下拉加载数据如何获取正确的数据？"><a href="#页面下拉加载数据如何获取正确的数据？" class="headerlink" title="页面下拉加载数据如何获取正确的数据？"></a>页面下拉加载数据如何获取正确的数据？</h1><p>页面下拉加载数据是现代web和移动应用中常见的功能，它可以提高用户体验和应用性能，尤其是在处理大量数据时。为了实现这个功能，通常需要前端和后端配合，使用适当的策略来确保每次加载都获取正确的数据。下面是实现页面下拉加载数据的一些关键步骤和考虑因素：</p>
<h2 id="确定数据分页策略"><a href="#确定数据分页策略" class="headerlink" title="确定数据分页策略"></a><strong>确定数据分页策略</strong></h2><p>在服务器端，你需要设定一种方法来分页数据。这通常涉及到以下几个关键参数：</p>
<ul>
<li><code>limit</code>（或<code>pageSize</code>）: 每页显示的数据条数。</li>
<li><code>offset</code>（或<code>page</code>）: 当前的偏移量或者页码，用于指定从哪条记录开始获取数据。</li>
</ul>
<p>例如，如果你每次想加载10条记录，你可以在第一次请求中设定<code>limit=10</code>和<code>offset=0</code>，在下一次请求中设定<code>limit=10</code>和<code>offset=10</code>，以此类推。</p>
<h2 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a><strong>前端实现</strong></h2><p>在前端，你需要监听滚动事件，判断用户何时滚动到页面底部，然后触发新的数据加载。这可以通过添加一个滚动事件监听器来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">scrollY</span> + <span class="variable language_">window</span>.<span class="property">innerHeight</span> &gt;= <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetHeight</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已滚动到页面底部</span></span><br><span class="line">        <span class="title function_">loadData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="触发数据加载函数"><a href="#触发数据加载函数" class="headerlink" title="触发数据加载函数"></a><strong>触发数据加载函数</strong></h2><p><code>loadData</code> 函数应当负责发送 AJAX 请求（或使用其他HTTP客户端库，如<code>fetch</code>或<code>axios</code>）到服务器以获取下一批数据。你需要维护一个状态变量来追踪当前的<code>offset</code>或<code>page</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentPage = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> pageSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    currentPage++;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`/api/data?limit=<span class="subst">$&#123;pageSize&#125;</span>&amp;offset=<span class="subst">$&#123;currentPage * pageSize&#125;</span>`</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">displayData</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a><strong>显示数据</strong></h2><p>将加载的数据追加到现有内容的后面，而不是替换它。可以使用DOM操作将新数据添加到列表或容器中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">displayData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;data-container&#x27;</span>);</span><br><span class="line">    data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        element.<span class="property">textContent</span> = item.<span class="property">name</span>; <span class="comment">// 假设数据中有&#x27;name&#x27;字段</span></span><br><span class="line">        container.<span class="title function_">appendChild</span>(element);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理边缘情况"><a href="#处理边缘情况" class="headerlink" title="处理边缘情况"></a><strong>处理边缘情况</strong></h2><ul>
<li><strong>空数据</strong>：如果从服务器接收到的数据少于请求的数量，可能意味着已经没有更多的数据可加载了。这时应停止进一步的数据加载请求。</li>
<li><strong>加载状态指示</strong>：在数据加载期间显示加载指示器（如旋转的加载图标），以提高用户体验。</li>
<li><strong>错误处理</strong>：添加错误处理逻辑，以防网络请求失败。</li>
</ul>
<h2 id="优化和增强"><a href="#优化和增强" class="headerlink" title="优化和增强"></a><strong>优化和增强</strong></h2><ul>
<li><strong>防抖和节流</strong>：优化滚动事件处理，防止在短时间内多次触发数据加载。</li>
<li><strong>无限滚动库</strong>：考虑使用现成的无限滚动库，如<code>react-infinite-scroll-component</code>或<code>vue-infinite-loading</code>等，这些库提供了封装好的无限滚动功能和更多自定义选项。</li>
</ul>
<p>通过遵循这些步骤，你可以实现一个有效并且用户友好的下拉加载数据功能，适用于需要处理大量数据的应用场景。</p>
<h1 id="页面需要展示多张图片，如何优化显示效果？"><a href="#页面需要展示多张图片，如何优化显示效果？" class="headerlink" title="页面需要展示多张图片，如何优化显示效果？"></a>页面需要展示多张图片，如何优化显示效果？</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="git-reset和git-rework有什么区别？"><a href="#git-reset和git-rework有什么区别？" class="headerlink" title="git reset和git rework有什么区别？"></a>git reset和git rework有什么区别？</h1><p>在使用Git进行版本控制时，<code>git reset</code> 和 <code>git rework</code> 是常见的命令，但实际上，<code>git rework</code> 不是一个存在的Git命令。你可能是想要指的是 <code>git rebase</code>。这里我将解释 <code>git reset</code> 和 <code>git rebase</code> 的区别，它们是两个功能强大且用途各异的命令。</p>
<h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p><code>git reset</code> 主要用于撤销更改。它可以改变当前分支的HEAD指向，选择性地更改索引（暂存区）或工作目录中的文件。它常用于取消暂存的更改或回退到某个特定的提交。<code>git reset</code> 可以有三种不同的模式：</p>
<ul>
<li><code>--soft</code>：此模式会将HEAD移动到指定的提交，但不会更改索引或工作目录。这意味着所有从原HEAD到新HEAD之间的提交将作为暂存状态，适合重新提交。</li>
<li><code>--mixed</code>（默认）：将HEAD移动到指定的提交，并重置索引以匹配该提交，但不会更改工作目录。这会撤销暂存的所有更改，并让这些更改保持在工作目录中，未暂存。</li>
<li><code>--hard</code>：将HEAD移动到指定的提交，重置索引以匹配该提交，并清空所有工作目录中的更改。这是一种危险操作，因为它会丢失所有当前未提交的更改。</li>
</ul>
<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p><code>git rebase</code> 是一个用于重写历史的强大命令，它的目的是将一系列的提交按照另外一个基点重新应用。<code>git rebase</code> 常用于将本地更改整理成一个整洁的历史，或者在将更改推送到远程仓库前，更新本地仓库以匹配远程仓库的状态。它的常见用法包括：</p>
<ul>
<li>将本地分支的更改应用到更新的上游状态（如master或main分支）上。</li>
<li>清理提交历史，通过合并、修改或删除一些不需要的提交。</li>
</ul>
<p><code>git rebase</code> 在操作过程中会临时移除一些提交，然后将它们重新应用在新的基点之上。这个过程可能会产生冲突，需要手动解决。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><strong>用途</strong>：<code>git reset</code> 主要用于撤销更改或回到某个旧的提交点，而 <code>git rebase</code> 用于整理提交历史或将更改应用于另一基点。</li>
<li><strong>影响</strong>：<code>git reset</code> 可以改变当前分支的HEAD位置，并可能丢弃一些提交，而 <code>git rebase</code> 则是重新应用提交在不同的基点，常常用于历史的重写。</li>
<li><strong>安全性</strong>：使用 <code>git reset --hard</code> 或 <code>git rebase</code> 都需要小心，因为不当操作可能导致数据丢失。特别是在公共分支上进行 <code>git rebase</code> 应该避免，因为它会改变公共历史。</li>
</ul>
<p>在使用这些命令时，确保你理解了它们的行为和后果，尤其是在涉及到修改历史记录的操作时。在团队环境中，最好与团队成员协调一致，以避免因历史更改引发的合作问题。</p>
<h1 id="解决过webpack的哪些问题？"><a href="#解决过webpack的哪些问题？" class="headerlink" title="解决过webpack的哪些问题？"></a>解决过webpack的哪些问题？</h1><h1 id="为什么要使用TypeScript"><a href="#为什么要使用TypeScript" class="headerlink" title="为什么要使用TypeScript"></a>为什么要使用TypeScript</h1><p>TypeScript 的使用带来了多种好处，尤其对于构建大规模的应用程序、提高代码质量和团队协作效率方面非常有用。下面详细解释为什么要使用 TypeScript：</p>
<h3 id="1-静态类型检查"><a href="#1-静态类型检查" class="headerlink" title="1. 静态类型检查"></a>1. <strong>静态类型检查</strong></h3><p>TypeScript 是 JavaScript 的一个超集，它添加了静态类型检查。这意味着你可以在代码运行之前识别出潜在的类型错误。这种早期错误检测可以减少运行时错误，提高代码质量。</p>
<h3 id="2-更好的协作"><a href="#2-更好的协作" class="headerlink" title="2. 更好的协作"></a>2. <strong>更好的协作</strong></h3><p>在大型项目或团队中，静态类型系统可以帮助开发者更好地理解代码。类型注释和编译时检查使得代码更易读、更易维护，并减少了合作时的摩擦。</p>
<h3 id="3-IDE-支持"><a href="#3-IDE-支持" class="headerlink" title="3. IDE 支持"></a>3. <strong>IDE 支持</strong></h3><p>TypeScript 提供了优秀的集成开发环境（IDE）支持，包括自动完成、导航到定义、重构工具等。这些工具可以大大提高开发效率和代码质量。</p>
<h3 id="4-更好的代码组织"><a href="#4-更好的代码组织" class="headerlink" title="4. 更好的代码组织"></a>4. <strong>更好的代码组织</strong></h3><p>TypeScript 支持最新的和即将推出的 JavaScript 特性，包括 ES6 和未来的提案。它还支持模块、命名空间和接口等高级功能，这些都有助于组织复杂的代码。</p>
<h3 id="5-适应性和可扩展性"><a href="#5-适应性和可扩展性" class="headerlink" title="5. 适应性和可扩展性"></a>5. <strong>适应性和可扩展性</strong></h3><p>TypeScript 可以编译成纯 JavaScript，这使得它可以运行在任何支持 JavaScript 的平台上。你可以逐步地将现有的 JavaScript 项目迁移到 TypeScript，这提供了极大的灵活性和扩展性。</p>
<h3 id="6-强大的社区和生态系统"><a href="#6-强大的社区和生态系统" class="headerlink" title="6. 强大的社区和生态系统"></a>6. <strong>强大的社区和生态系统</strong></h3><p>TypeScript 由 Microsoft 维护，并且有一个活跃的开发社区。许多流行的库和框架（如 Angular、Vue、React）都支持 TypeScript，这意味着你可以获得丰富的资源和社区支持。</p>
<h3 id="7-错误减少"><a href="#7-错误减少" class="headerlink" title="7. 错误减少"></a>7. <strong>错误减少</strong></h3><p>由于类型系统的存在，TypeScript 可以在编译阶段捕捉到许多错误，而这些错误在使用纯 JavaScript 时可能只有在运行时才会被发现。这可以减少生产中的错误和潜在的系统故障。</p>
<h3 id="8-提高维护性"><a href="#8-提高维护性" class="headerlink" title="8. 提高维护性"></a>8. <strong>提高维护性</strong></h3><p>随着应用程序的增长，使用 TypeScript 可以帮助维持代码的可维护性。类型检查和高级特性如泛型和装饰器，使得大规模的代码库更易于管理和扩展。</p>
<h3 id="9-企业级开发"><a href="#9-企业级开发" class="headerlink" title="9. 企业级开发"></a>9. <strong>企业级开发</strong></h3><p>对于企业级应用程序，TypeScript 提供了必要的工具和特性，如强类型系统、接口和抽象类，这些都是构建复杂、可靠和可扩展应用程序的关键要素。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>使用 TypeScript 可以带来更结构化、可预测和易于管理的代码基础。虽然引入 TypeScript 需要一定的学习曲线和初始设置，但它在长期开发过程中提供的好处远远超过了这些成本。对于希望提高代码质量、增强开发者工具支持，并减少运行时错误的团队或项目，TypeScript 是一个极好的选择。</p>
<h1 id="XSS防范攻击"><a href="#XSS防范攻击" class="headerlink" title="XSS防范攻击"></a>XSS防范攻击</h1><p>跨站脚本攻击（Cross-Site Scripting, XSS）是一种常见的网络安全威胁，它允许攻击者在用户浏览器中执行恶意脚本。这些脚本能够访问存储在浏览器中的会话令牌、Cookie、或其他敏感信息，甚至能够重新定向用户到恶意网站。防范XSS攻击主要集中在正确处理用户输入和输出的数据。以下是一些常见的防范措施：</p>
<h3 id="1-对用户输入进行编码"><a href="#1-对用户输入进行编码" class="headerlink" title="1. 对用户输入进行编码"></a>1. <strong>对用户输入进行编码</strong></h3><p>对所有的用户输入进行HTML实体编码，特别是那些会被直接插入到HTML中的数据。编码能够确保任何输入的数据在渲染时不会被当作代码执行。常见的编码方式包括将字符如 <code>&lt;</code> 转换为 <code>&amp;lt;</code>，<code>&gt;</code> 转换为 <code>&amp;gt;</code>，以及 <code>&quot;</code> 转换为 <code>&amp;quot;</code> 等。</p>
<h3 id="2-使用适当的内容安全策略（CSP）"><a href="#2-使用适当的内容安全策略（CSP）" class="headerlink" title="2. 使用适当的内容安全策略（CSP）"></a>2. <strong>使用适当的内容安全策略（CSP）</strong></h3><p>内容安全策略（Content Security Policy, CSP）是一个额外的安全层，用于帮助检测和减轻某些类型的攻击，包括XSS和数据注入攻击。CSP允许你指定哪些动态资源可以加载和执行，你可以通过HTTP响应头部<code>Content-Security-Policy</code>来设置策略。例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span><span class="punctuation">: </span>script-src &#x27;self&#x27;; object-src &#x27;none&#x27;</span><br></pre></td></tr></table></figure>

<p>这告诉浏览器只执行来自同源的脚本，不执行或加载任何外部插件（如Flash）。</p>
<h3 id="3-验证和过滤输入"><a href="#3-验证和过滤输入" class="headerlink" title="3. 验证和过滤输入"></a>3. <strong>验证和过滤输入</strong></h3><p>尽管对输入进行编码是首选的防范措施，验证和过滤输入也很重要。确保对进入应用的数据进行严格的格式验证，如使用正则表达式验证电子邮件地址、电话号码等。</p>
<h3 id="4-逃避JavaScript的直接输出"><a href="#4-逃避JavaScript的直接输出" class="headerlink" title="4. 逃避JavaScript的直接输出"></a>4. <strong>逃避JavaScript的直接输出</strong></h3><p>避免直接在JavaScript中嵌入不可信的数据。如果必须这么做，应该确保数据被正确的JavaScript编码。可以使用适当的库来处理这些数据，例如在JavaScript中可以使用<code>encodeURIComponent</code>。</p>
<h3 id="5-使用HTTPOnly-Cookie"><a href="#5-使用HTTPOnly-Cookie" class="headerlink" title="5. 使用HTTPOnly Cookie"></a>5. <strong>使用HTTPOnly Cookie</strong></h3><p>设置Cookie的<code>HTTPOnly</code>属性可以防止JavaScript访问这些Cookie。这不是防止XSS的方法，但可以减少XSS攻击造成的损害，因为即使发生了XSS，攻击者也无法读取这些Cookie。</p>
<h3 id="6-避免使用内联脚本"><a href="#6-避免使用内联脚本" class="headerlink" title="6. 避免使用内联脚本"></a>6. <strong>避免使用内联脚本</strong></h3><p>尽可能避免在你的HTML中使用内联JavaScript脚本。内联脚本使得实施CSP变得复杂，同时它们也更容易成为XSS攻击的目标。</p>
<h3 id="7-更新和维护"><a href="#7-更新和维护" class="headerlink" title="7. 更新和维护"></a>7. <strong>更新和维护</strong></h3><p>保持所有使用的库和框架更新到最新版本。许多现代框架（如React、Angular、Vue.js）都自带一定的XSS保护措施。例如，这些框架通常会在渲染时自动进行数据绑定和编码。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>XSS防范要求开发者在编写Web应用时必须持续保持警惕，实施上述措施可以大大降低XSS攻击的风险。最关键的是要理解数据从输入到输出的完整流程，确保在每一个环节都实施适当的保护措施。通过教育开发人员关于安全最佳实践，并使用自动化工具来帮助识别潜在的安全漏洞，可以进一步增强应用的安全性。</p>
<h1 id="PNG和JPEG图片格式的区别"><a href="#PNG和JPEG图片格式的区别" class="headerlink" title="PNG和JPEG图片格式的区别"></a>PNG和JPEG图片格式的区别</h1><p>PNG（Portable Network Graphics）格式和JPG（或JPEG，全称 Joint Photographic Experts Group）格式是两种常用的图像文件格式，它们各有优点和适用场景。以下是PNG和JPG之间的一些主要区别：</p>
<h3 id="1-压缩方法"><a href="#1-压缩方法" class="headerlink" title="1. 压缩方法"></a>1. <strong>压缩方法</strong></h3><ul>
<li><strong>PNG</strong>：使用无损压缩，这意味着在压缩过程中不会丢失图像数据。这使得PNG格式非常适合需要频繁编辑的图像，因为文件不会因多次保存而失真。</li>
<li><strong>JPG</strong>：使用有损压缩，会在压缩过程中丢失一部分图像数据。有损压缩使得JPG文件在保持相对较高图像质量的同时，文件大小可以非常小，适合存储照片和复杂的颜色渐变图像。</li>
</ul>
<h3 id="2-文件大小"><a href="#2-文件大小" class="headerlink" title="2. 文件大小"></a>2. <strong>文件大小</strong></h3><ul>
<li><strong>PNG</strong>：由于采用无损压缩，PNG文件的大小通常比同等尺寸的JPG文件大，特别是对于大图像和详细内容图像。</li>
<li><strong>JPG</strong>：文件大小通常比PNG小，适合网络上传输和存储，但质量取决于压缩级别。压缩级别越高，图像质量损失越大。</li>
</ul>
<h3 id="3-图像质量"><a href="#3-图像质量" class="headerlink" title="3. 图像质量"></a>3. <strong>图像质量</strong></h3><ul>
<li><strong>PNG</strong>：保持原始图像的完整质量，支持高动态范围（HDR）和大色深。</li>
<li><strong>JPG</strong>：在高压缩率下，图像质量可能会显著下降，表现为模糊和压缩伪影。</li>
</ul>
<h3 id="4-透明支持"><a href="#4-透明支持" class="headerlink" title="4. 透明支持"></a>4. <strong>透明支持</strong></h3><ul>
<li><strong>PNG</strong>：支持透明度，可以显示不同级别的透明和半透明图像，这使得PNG非常适合网页设计和需要叠加多层图像的场景。</li>
<li><strong>JPG</strong>：不支持透明，背景总是不透明的。</li>
</ul>
<h3 id="5-颜色范围"><a href="#5-颜色范围" class="headerlink" title="5. 颜色范围"></a>5. <strong>颜色范围</strong></h3><ul>
<li><strong>PNG</strong>：可以处理更广泛的颜色和更高的位深，支持24位或32位色（RGB或RGBA）。</li>
<li><strong>JPG</strong>：通常使用24位色，足以显示约1600万色，适合照片。</li>
</ul>
<h3 id="6-适用场景"><a href="#6-适用场景" class="headerlink" title="6. 适用场景"></a>6. <strong>适用场景</strong></h3><ul>
<li><strong>PNG</strong>：非常适合需要高图像质量，例如图形设计、网页图标、屏幕截图和需要透明背景的图像。</li>
<li><strong>JPG</strong>：由于文件大小小，加载速度快，非常适合用于摄影、在线媒体展示和打印媒体。</li>
</ul>
<h3 id="7-编辑和重新保存"><a href="#7-编辑和重新保存" class="headerlink" title="7. 编辑和重新保存"></a>7. <strong>编辑和重新保存</strong></h3><ul>
<li><strong>PNG</strong>：每次编辑和保存时，图像质量不会降低。</li>
<li><strong>JPG</strong>：每次编辑和重新保存时，图像可能会进一步失真，因为每次保存都会经历一次有损压缩。</li>
</ul>
<p>总结来说，选择PNG还是JPG取决于你的具体需求，包括是否需要透明支持、图像质量的重要性以及对文件大小的敏感度。对于高质量图像和图形设计，PNG是更好的选择；而对于需要经常处理大量照片且存储空间有限的场景，JPG可能更合适。</p>
<h1 id="HTTP1-0-x2F-HTTP1-1-x2F-HTTP2-0"><a href="#HTTP1-0-x2F-HTTP1-1-x2F-HTTP2-0" class="headerlink" title="HTTP1.0&#x2F;HTTP1.1&#x2F;HTTP2.0"></a>HTTP1.0&#x2F;HTTP1.1&#x2F;HTTP2.0</h1><p>HTTP（超文本传输协议）是Web上数据通信的基础。随着时间的推移，HTTP协议经历了几个主要版本的更新，每个版本都增加了新的功能和性能改进。这里简要概述HTTP 1.0、HTTP 1.1 和 HTTP&#x2F;2的主要区别：</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><ul>
<li><strong>连接方式</strong>：非持久连接。每个HTTP请求&#x2F;响应对完成后，连接就被关闭，再次通信需要重新建立连接。</li>
<li><strong>功能限制</strong>：由于每次请求都需要建立新的连接，导致开销大和响应慢。</li>
<li><strong>无宿主头</strong>：HTTP 1.0不支持虚拟主机（多个域名共享同一IP地址的技术），因为它不要求请求中包含<code>Host</code>头。</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><ul>
<li><strong>连接方式</strong>：持久连接。默认情况下，连接在传输多个请求和响应后保持打开状态，减少了建立和关闭连接的开销。</li>
<li><strong>管线化</strong>：支持请求的管线化处理，允许客户端在等待第一个响应完成之前发送多个请求，以提高速度。</li>
<li><strong>缓存处理</strong>：增强了缓存控制选项，如<code>ETag</code>、<code>Cache-Control</code>等，允许更精细的缓存策略。</li>
<li><strong>Host头和其他新头</strong>：引入<code>Host</code>头，允许虚拟主机的支持；同时增加了<code>Connection</code>、<code>Transfer-Encoding</code>等新的头部字段。</li>
</ul>
<h3 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><ul>
<li><strong>二进制格式</strong>：HTTP&#x2F;2使用二进制而非文本格式传输数据，提高了解析效率和网络性能。</li>
<li><strong>多路复用</strong>：在同一连接中同时发送多个请求和响应，不必等待一个事务完成就可以开始下一个，极大地减少了延迟。</li>
<li><strong>服务器推送</strong>：服务器可以对一个客户端请求发送多个响应。例如，服务器可以主动推送网页所需的资源，而无需客户端显式请求。</li>
<li><strong>头部压缩</strong>：HTTP&#x2F;2引入了HPACK压缩格式，对请求和响应头部进行压缩，减少了传输的数据量。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>HTTP 1.0</strong> 至 <strong>HTTP 1.1</strong> 的变化主要是持久连接和更好的缓存管理。</li>
<li><strong>HTTP 1.1</strong> 至 <strong>HTTP&#x2F;2</strong> 的升级着重于性能的大幅提升，包括二进制传输、多路复用和头部压缩。</li>
</ul>
<p>这些进化显著提高了Web通信的效率和速度，每个版本都针对当时网络环境中的问题提供了解决方案。随着互联网技术的不断进步，HTTP协议也在不断发展，以满足日益增长的网络应用需求。</p>
<h1 id="nextTick原理"><a href="#nextTick原理" class="headerlink" title="nextTick原理"></a>nextTick原理</h1><p>在 Vue.js 中，<code>nextTick()</code> 是一个非常重要的方法，它用于处理 DOM 更新后的异步操作。由于 Vue 的响应式原理，数据的改变并不会立即反映到 DOM 上，而是异步更新。这就意味着如果你直接在数据变化后尝试操作新的 DOM 结构，可能会遇到问题，因为那些变化可能还没被应用到 DOM 上。<code>nextTick()</code> 方法就是用来解决这个时序问题的。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Vue 使用异步更新队列的方式来处理数据变更后的 DOM 更新。每当观察到数据变化，Vue 会开启一个队列，并缓冲在同一个事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种去重行为可以避免不必要的计算和 DOM 操作。然后，在下一个事件循环“tick”中，Vue 刷新队列并执行实际的（已去重的）工作。</p>
<p>Vue 尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code>，或是 <code>setImmediate</code>，如果上述都不可用，则会采用 <code>setTimeout(fn, 0)</code> 来异步延迟队列的处理。这些方法基本上涵盖了宏任务和微任务的管理，确保了异步执行的效率和时效性。</p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>你可能需要在 Vue 的 <code>nextTick()</code> 中执行 DOM 操作的情况包括：</p>
<ul>
<li>在数据变化之后，你需要从 DOM 中获取更新后的元素或计算样式。</li>
<li>在执行 DOM 操作后，需要确保 Vue 完成了相关的更新。</li>
</ul>
<h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h2><p>假设你有一个 Vue 组件，当你更新组件的某个数据后，想要立即使用这些更新后的数据来操作 DOM：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">updateMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;Updated&#x27;</span>;</span><br><span class="line">      <span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The DOM has been updated&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>updateMessage</code> 方法中的 <code>this.message</code> 被更新后，通过 <code>this.$nextTick()</code> 确保 <code>console.log</code> 的执行发生在 DOM 更新之后。</p>
<p>总之，Vue 的 <code>nextTick()</code> 是一个强大的工具，用于处理在数据变化后要执行的 DOM 依赖的操作，确保你的操作是在 Vue 完成数据到 DOM 的更新之后进行的。这个机制让 Vue 可以更高效地处理更新，避免不必要的多次渲染和性能问题。</p>
<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><blockquote>
<p>Vuex 是 Vue.js 应用程序的状态管理模式和库，它主要用于处理 Vue 应用中组件的共享状态。在 Vuex 中，<code>mutations</code> 和 <code>actions</code> 是两种主要的方法用来实现状态的更改和异步操作。它们各自有特定的用途和规则：</p>
</blockquote>
<h2 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h2><ol>
<li><strong>定义</strong>：<code>mutations</code> 是同步函数，用于直接更改存储状态。它们是 Vuex 中唯一可以修改状态的方法。</li>
<li><strong>用法</strong>：每个 <code>mutation</code> 都有一个字符串类型的事件类型 (type) 和一个回调函数。该函数接收当前的 state 作为第一个参数。你可以传递额外的参数到 <code>mutation</code>，这在 Vuex 术语中被称为载荷（payload）。</li>
<li><strong>调用</strong>：<code>mutations</code> 必须通过 <code>commit</code> 方法触发，这强调了它们的同步性质。</li>
<li><strong>特点</strong>：因为所有 <code>mutation</code> 都是同步的，所以任何时候触发一个 <code>mutation</code> 后，状态的更改都是即时可见的。</li>
</ol>
<h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><ol>
<li><strong>定义</strong>：<code>actions</code> 是可以包含任意异步操作的函数。<code>actions</code> 提供了一种方式来处理异步操作然后再改变状态，或者可以包含复杂的同步操作。</li>
<li><strong>用法</strong>：<code>actions</code> 也类似于 <code>mutations</code>，定义为一个事件类型和一个处理函数。不同的是，<code>action</code> 处理函数接收一个与 store 实例具有相同方法和属性的 <code>context</code> 对象，允许你执行 <code>commit</code> 提交 <code>mutation</code>，分发另一个 <code>action</code>，或访问当前 state。</li>
<li><strong>调用</strong>：<code>actions</code> 通过 <code>dispatch</code> 方法触发。它们可以调用多个 <code>mutation</code>，可以通过异步操作控制流程。</li>
<li><strong>特点</strong>：<code>actions</code> 的设计是为了处理异步操作，例如从服务器获取数据，在数据到达后提交 <code>mutation</code> 进行状态更新。</li>
</ol>
<h2 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h2><ul>
<li><strong>异步 vs 同步</strong>：<code>mutations</code> 是同步的，<code>actions</code> 可以是异步的。</li>
<li><strong>用途</strong>：<code>mutations</code> 用于修改状态，<code>actions</code> 用于执行异步操作和&#x2F;或分发多个 <code>mutation</code>。</li>
<li><strong>调用方式</strong>：<code>mutations</code> 通过 <code>commit</code> 调用，而 <code>actions</code> 通过 <code>dispatch</code>。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>increment</code> 是一个 <code>mutation</code>，它同步增加 <code>count</code> 的值。<code>incrementAsync</code> 是一个 <code>action</code>，它延迟 1 秒后提交 <code>increment</code> <code>mutation</code>，展示了如何处理异步操作。</p>
<p>总的来说，<code>mutations</code> 和 <code>actions</code> 在 Vuex 中扮演着协同工作的角色，但它们在应用的数据流和逻辑处理中具有不同的职责和规则。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在JavaScript中，实现继承的方法多样，随着ECMAScript标准的演进，这些方法也在发展变化。下面是一些主要的JavaScript继承实现方式：</p>
<h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><p>原型链继承是最基本的继承方式，通过重新指定原型对象来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parentProperty</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getParentValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">parentProperty</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">childProperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Parent</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getParentValue</span>());  <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure>

<p>这种方法的主要问题是父类的引用属性会被所有实例共享，这可能导致一个实例对属性的修改影响到所有实例。</p>
<h3 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2. 构造函数继承"></a>2. 构造函数继承</h3><p>构造函数继承通过在子类的构造函数中调用父类的构造函数来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>);  <span class="comment">// 输出：Tom</span></span><br></pre></td></tr></table></figure>

<p>这种方法可以避免引用类型的属性被所有实例共享，但是父类原型中定义的方法不会被子类继承。</p>
<h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><p>组合继承结合了原型链继承和构造函数继承的优点，是JavaScript中使用最频繁的继承模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getName</span>());  <span class="comment">// 输出：Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">age</span>);  <span class="comment">// 输出：20</span></span><br></pre></td></tr></table></figure>

<p>这种方法同时解决了父类方法的继承和每个实例有自己的属性的需求。</p>
<h3 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h3><p>原型式继承是借助于原型可以基于已有的对象创建新对象，同时不必因此创建自定义类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>);  <span class="comment">// 输出：[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Rob&quot;, &quot;Barbie&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="5-ES6-类继承"><a href="#5-ES6-类继承" class="headerlink" title="5. ES6 类继承"></a>5. ES6 类继承</h3><p>ES6引入了类的概念，使得继承的实现更接近传统面向对象编程语言的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name);  <span class="comment">// 调用父类的constructor(name)</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getName</span>());  <span class="comment">// 输出：Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">age</span>);  <span class="comment">// 输出：20</span></span><br></pre></td></tr></table></figure>

<p>这种方法是当前最推荐的继承方式，因为它简洁明了，且符合大多数程序员对类的直观理解。</p>
<p>以上就是JavaScript中几种主要的继承方式，根据不同的需求和场景选择适合的继承方法。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Lavender321.github.com">流泪猫猫头</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lavender321.github.com/2024/04/20/%E5%B0%8F%E9%B9%85%E9%80%9A/">http://lavender321.github.com/2024/04/20/%E5%B0%8F%E9%B9%85%E9%80%9A/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Lavender321.github.com" target="_blank">Lavender's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/21/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" title="HTTP相关知识点"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTTP相关知识点</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/19/Javascript%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/" title="Javascript手写代码"><img class="cover" src="https://s2.loli.net/2022/12/31/HYB9fKZPknOqSLz.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Javascript手写代码</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/" title="CSS面试记录"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-22</div><div class="title">CSS面试记录</div></div></a></div><div><a href="/2024/04/19/Javascript%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/" title="Javascript手写代码"><img class="cover" src="https://s2.loli.net/2022/12/31/HYB9fKZPknOqSLz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-19</div><div class="title">Javascript手写代码</div></div></a></div><div><a href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">React面试题</div></div></a></div><div><a href="/2023/02/13/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="TypeScript面试题"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-13</div><div class="title">TypeScript面试题</div></div></a></div><div><a href="/2023/01/27/JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="JavaScript数组常用方法总结"><img class="cover" src="https://s2.loli.net/2022/12/31/HYB9fKZPknOqSLz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-27</div><div class="title">JavaScript数组常用方法总结</div></div></a></div><div><a href="/2023/01/19/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Vue面试题总结"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-19</div><div class="title">Vue面试题总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">流泪猫猫头</div><div class="author-info__description">THE TORTURED POETS DEPARTMENT</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lavender321"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lavender321" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:r1727439300@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%81%9ASEO%E4%BC%98%E5%8C%96%E5%90%97"><span class="toc-number">1.</span> <span class="toc-text">项目页面有做SEO优化吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B3%E9%94%AE%E8%AF%8D%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. 关键词优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AB%98%E8%B4%A8%E9%87%8F%E5%86%85%E5%AE%B9"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. 高质量内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8A%80%E6%9C%AFSEO"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. 技术SEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%88UX%EF%BC%89"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. 用户体验（UX）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%85%E9%93%BE%E5%92%8C%E5%A4%96%E9%93%BE"><span class="toc-number">1.0.5.</span> <span class="toc-text">5. 内链和外链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%85%83%E6%A0%87%E7%AD%BE%E5%92%8C%E6%A0%87%E9%A2%98%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.6.</span> <span class="toc-text">6. 元标签和标题优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96"><span class="toc-number">1.0.7.</span> <span class="toc-text">7. 图像优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%A4%BE%E4%BA%A4%E5%AA%92%E4%BD%93%E6%95%B4%E5%90%88"><span class="toc-number">1.0.8.</span> <span class="toc-text">8. 社交媒体整合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">怎么实现响应式布局？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#position-%E6%9C%89%E4%BB%80%E4%B9%88%E5%B1%9E%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">position 有什么属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6%E7%9A%84Promise%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9FPromise%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">ES6的Promise解决什么问题？Promise原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E4%B8%AD%E7%9A%84Promise%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E2%80%93%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">ES6中的Promise解决的问题–回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">Promise的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">4.2.1.</span> <span class="toc-text">状态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">4.2.2.</span> <span class="toc-text">结果：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%9A"><span class="toc-number">4.2.3.</span> <span class="toc-text">链式调用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">4.3.</span> <span class="toc-text">工作流程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAPromise%EF%BC%9A"><span class="toc-number">4.3.1.</span> <span class="toc-text">创建Promise：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">4.3.2.</span> <span class="toc-text">处理结果：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7%EF%BC%9A"><span class="toc-number">4.3.3.</span> <span class="toc-text">错误捕获：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">4.3.4.</span> <span class="toc-text">链式处理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-all-%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">Promise.all()处理并发？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">基本工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.2.</span> <span class="toc-text">处理并发步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">并行执行：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E8%81%9A%E5%90%88%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">结果聚合：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">5.2.3.</span> <span class="toc-text">错误处理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">5.3.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.4.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.5.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89100%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%AF%8F%E4%B8%AAPromise-all%E5%8F%AA%E8%83%BD%E5%A4%84%E7%90%8610%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">有100个请求，每个Promise.all只能处理10个请求，要怎么实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%AF%8F%E6%89%B9%E8%AF%B7%E6%B1%82"><span class="toc-number">6.1.</span> <span class="toc-text">顺序执行每批请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E6%AF%8F%E6%89%B9%E8%AF%B7%E6%B1%82"><span class="toc-number">6.2.</span> <span class="toc-text">并行执行每批请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">选择实现方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">Vue的双向绑定如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-2-x-%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">7.0.1.</span> <span class="toc-text">Vue 2.x 的双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-3-x-%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">7.0.2.</span> <span class="toc-text">Vue 3.x 的双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">7.0.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3%E4%B8%8EVue2%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FVue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E4%B8%8EVue2%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">Vue3与Vue2的区别？Vue3的响应式与Vue2的有什么不同？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-3-%E4%B8%8E-Vue-2-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.</span> <span class="toc-text">Vue 3 与 Vue 2 的主要区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-number">8.1.1.</span> <span class="toc-text">性能提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composition-API"><span class="toc-number">8.1.2.</span> <span class="toc-text">Composition API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84-TypeScript-%E6%94%AF%E6%8C%81"><span class="toc-number">8.1.3.</span> <span class="toc-text">更好的 TypeScript 支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.1.4.</span> <span class="toc-text">新的响应式系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%87%E6%AE%B5-Fragments"><span class="toc-number">8.1.4.1.</span> <span class="toc-text">片段 (Fragments)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">8.1.4.2.</span> <span class="toc-text">改进的虚拟 DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8-API"><span class="toc-number">8.1.4.3.</span> <span class="toc-text">自定义渲染器 API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">8.1.5.</span> <span class="toc-text">响应式系统的不同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E7%99%BB%E5%BD%95%E6%80%81%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A"><span class="toc-number">9.</span> <span class="toc-text">前后端登录态如何确定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E6%80%81"><span class="toc-number">9.1.</span> <span class="toc-text">使用会话（Session）管理登录态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">9.1.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">9.1.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A4%E7%89%8C%EF%BC%88Token%EF%BC%89%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E6%80%81%EF%BC%88JWT%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">使用令牌（Token）管理登录态（JWT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="toc-number">9.2.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">9.2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">9.2.3.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-number">9.2.4.</span> <span class="toc-text">安全性考虑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E4%B8%8B%E6%8B%89%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">页面下拉加载数据如何获取正确的数据？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="toc-number">10.1.</span> <span class="toc-text">确定数据分页策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.2.</span> <span class="toc-text">前端实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text">触发数据加载函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">10.4.</span> <span class="toc-text">显示数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BE%B9%E7%BC%98%E6%83%85%E5%86%B5"><span class="toc-number">10.5.</span> <span class="toc-text">处理边缘情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%92%8C%E5%A2%9E%E5%BC%BA"><span class="toc-number">10.6.</span> <span class="toc-text">优化和增强</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%9C%80%E8%A6%81%E5%B1%95%E7%A4%BA%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%98%BE%E7%A4%BA%E6%95%88%E6%9E%9C%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">页面需要展示多张图片，如何优化显示效果？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">11.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git-reset%E5%92%8Cgit-rework%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">git reset和git rework有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#git-reset"><span class="toc-number">12.1.</span> <span class="toc-text">git reset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git-rebase"><span class="toc-number">12.2.</span> <span class="toc-text">git rebase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">12.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%BF%87webpack%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">解决过webpack的哪些问题？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8TypeScript"><span class="toc-number">14.</span> <span class="toc-text">为什么要使用TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">14.0.1.</span> <span class="toc-text">1. 静态类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-number">14.0.2.</span> <span class="toc-text">2. 更好的协作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IDE-%E6%94%AF%E6%8C%81"><span class="toc-number">14.0.3.</span> <span class="toc-text">3. IDE 支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-number">14.0.4.</span> <span class="toc-text">4. 更好的代码组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%80%82%E5%BA%94%E6%80%A7%E5%92%8C%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-number">14.0.5.</span> <span class="toc-text">5. 适应性和可扩展性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%A4%BE%E5%8C%BA%E5%92%8C%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">14.0.6.</span> <span class="toc-text">6. 强大的社区和生态系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%94%99%E8%AF%AF%E5%87%8F%E5%B0%91"><span class="toc-number">14.0.7.</span> <span class="toc-text">7. 错误减少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%8F%90%E9%AB%98%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="toc-number">14.0.8.</span> <span class="toc-text">8. 提高维护性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91"><span class="toc-number">14.0.9.</span> <span class="toc-text">9. 企业级开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">14.0.10.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XSS%E9%98%B2%E8%8C%83%E6%94%BB%E5%87%BB"><span class="toc-number">15.</span> <span class="toc-text">XSS防范攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81"><span class="toc-number">15.0.1.</span> <span class="toc-text">1. 对用户输入进行编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E9%80%82%E5%BD%93%E7%9A%84%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%EF%BC%88CSP%EF%BC%89"><span class="toc-number">15.0.2.</span> <span class="toc-text">2. 使用适当的内容安全策略（CSP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81%E5%92%8C%E8%BF%87%E6%BB%A4%E8%BE%93%E5%85%A5"><span class="toc-number">15.0.3.</span> <span class="toc-text">3. 验证和过滤输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%83%E9%81%BFJavaScript%E7%9A%84%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA"><span class="toc-number">15.0.4.</span> <span class="toc-text">4. 逃避JavaScript的直接输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8HTTPOnly-Cookie"><span class="toc-number">15.0.5.</span> <span class="toc-text">5. 使用HTTPOnly Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E8%84%9A%E6%9C%AC"><span class="toc-number">15.0.6.</span> <span class="toc-text">6. 避免使用内联脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9B%B4%E6%96%B0%E5%92%8C%E7%BB%B4%E6%8A%A4"><span class="toc-number">15.0.7.</span> <span class="toc-text">7. 更新和维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">15.0.8.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PNG%E5%92%8CJPEG%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">PNG和JPEG图片格式的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%8B%E7%BC%A9%E6%96%B9%E6%B3%95"><span class="toc-number">16.0.1.</span> <span class="toc-text">1. 压缩方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="toc-number">16.0.2.</span> <span class="toc-text">2. 文件大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F"><span class="toc-number">16.0.3.</span> <span class="toc-text">3. 图像质量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%8F%E6%98%8E%E6%94%AF%E6%8C%81"><span class="toc-number">16.0.4.</span> <span class="toc-text">4. 透明支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%A2%9C%E8%89%B2%E8%8C%83%E5%9B%B4"><span class="toc-number">16.0.5.</span> <span class="toc-text">5. 颜色范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">16.0.6.</span> <span class="toc-text">6. 适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BC%96%E8%BE%91%E5%92%8C%E9%87%8D%E6%96%B0%E4%BF%9D%E5%AD%98"><span class="toc-number">16.0.7.</span> <span class="toc-text">7. 编辑和重新保存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP1-0-x2F-HTTP1-1-x2F-HTTP2-0"><span class="toc-number">17.</span> <span class="toc-text">HTTP1.0&#x2F;HTTP1.1&#x2F;HTTP2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-0"><span class="toc-number">17.0.1.</span> <span class="toc-text">HTTP 1.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1"><span class="toc-number">17.0.2.</span> <span class="toc-text">HTTP 1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-x2F-2"><span class="toc-number">17.0.3.</span> <span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">17.0.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nextTick%E5%8E%9F%E7%90%86"><span class="toc-number">18.</span> <span class="toc-text">nextTick原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">18.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">18.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-number">18.3.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vuex"><span class="toc-number">19.</span> <span class="toc-text">vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutations"><span class="toc-number">19.1.</span> <span class="toc-text">Mutations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Actions"><span class="toc-number">19.2.</span> <span class="toc-text">Actions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">19.3.</span> <span class="toc-text">关键区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">19.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">20.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">20.0.1.</span> <span class="toc-text">1. 原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">20.0.2.</span> <span class="toc-text">2. 构造函数继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">20.0.3.</span> <span class="toc-text">3. 组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">20.0.4.</span> <span class="toc-text">4. 原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-ES6-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">20.0.5.</span> <span class="toc-text">5. ES6 类继承</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/18/58/" title="无题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/09/18/58/" title="无题">无题</a><time datetime="2024-09-18T07:21:55.572Z" title="发表于 2024-09-18 15:21:55">2024-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/31/vite%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="vite相关面试题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vite相关面试题"/></a><div class="content"><a class="title" href="/2024/08/31/vite%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="vite相关面试题">vite相关面试题</a><time datetime="2024-08-31T10:37:40.000Z" title="发表于 2024-08-31 18:37:40">2024-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95/" title="小程序面试"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小程序面试"/></a><div class="content"><a class="title" href="/2024/08/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95/" title="小程序面试">小程序面试</a><time datetime="2024-08-31T07:30:26.000Z" title="发表于 2024-08-31 15:30:26">2024-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/06/2025-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="2025-前端面试总结"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-前端面试总结"/></a><div class="content"><a class="title" href="/2024/08/06/2025-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="2025-前端面试总结">2025-前端面试总结</a><time datetime="2024-08-06T03:22:45.000Z" title="发表于 2024-08-06 11:22:45">2024-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/05/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/" title="hexo创建博客"><img src="https://s2.loli.net/2023/01/29/yz4ZcjfxPlEMnUD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo创建博客"/></a><div class="content"><a class="title" href="/2024/08/05/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/" title="hexo创建博客">hexo创建博客</a><time datetime="2024-08-05T14:43:08.713Z" title="发表于 2024-08-05 22:43:08">2024-08-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 流泪猫猫头</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>