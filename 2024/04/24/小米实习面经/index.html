<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>小米实习面经 | Lavender's blog</title><meta name="author" content="流泪猫猫头"><meta name="copyright" content="流泪猫猫头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTML语义化新标签webworkerspostmessage onmessage websocket一次连接 WebSocket 协议本身并没有内置的短线重连机制，但可以通过在客户端实现相应的重连逻辑来实现短线重连。通常，客户端会在连接断开后尝试重新连接到 WebSocket 服务器，并且在一定的策略下进行重连，以确保连接的稳定性和可靠性。 以下是一种简单的 WebSocket 短线重连的实现方">
<meta property="og:type" content="article">
<meta property="og:title" content="小米实习面经">
<meta property="og:url" content="http://lavender321.github.com/2024/04/24/%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="Lavender&#39;s blog">
<meta property="og:description" content="HTML语义化新标签webworkerspostmessage onmessage websocket一次连接 WebSocket 协议本身并没有内置的短线重连机制，但可以通过在客户端实现相应的重连逻辑来实现短线重连。通常，客户端会在连接断开后尝试重新连接到 WebSocket 服务器，并且在一定的策略下进行重连，以确保连接的稳定性和可靠性。 以下是一种简单的 WebSocket 短线重连的实现方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png">
<meta property="article:published_time" content="2024-04-24T11:15:49.000Z">
<meta property="article:modified_time" content="2024-08-05T14:43:08.721Z">
<meta property="article:author" content="流泪猫猫头">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png"><link rel="shortcut icon" href="https://s2.loli.net/2022/10/08/k5M7H1NdmnZgtlY.png"><link rel="canonical" href="http://lavender321.github.com/2024/04/24/%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 流泪猫猫头","link":"链接: ","source":"来源: Lavender's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '小米实习面经',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-05 22:43:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Lavender's blog"><span class="site-name">Lavender's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">小米实习面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-24T11:15:49.000Z" title="发表于 2024-04-24 19:15:49">2024-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-05T14:43:08.721Z" title="更新于 2024-08-05 22:43:08">2024-08-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="小米实习面经"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><h2 id="新标签"><a href="#新标签" class="headerlink" title="新标签"></a>新标签</h2><h2 id="webworkers"><a href="#webworkers" class="headerlink" title="webworkers"></a>webworkers</h2><p>postmessage</p>
<p>onmessage</p>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>一次连接</p>
<p>WebSocket 协议本身并没有内置的短线重连机制，但可以通过在客户端实现相应的重连逻辑来实现短线重连。通常，客户端会在连接断开后尝试重新连接到 WebSocket 服务器，并且在一定的策略下进行重连，以确保连接的稳定性和可靠性。</p>
<p>以下是一种简单的 WebSocket 短线重连的实现方式：</p>
<ol>
<li><p><strong>重连策略</strong>：<br>客户端可以实现一个重连策略，决定在何种情况下进行重连，以及重连的间隔时间。例如，可以在连接断开后立即进行第一次重连，然后采用指数退避的方式进行后续重连，即每次重连间隔时间逐渐增加。</p>
</li>
<li><p><strong>监听连接状态</strong>：<br>客户端需要监听 WebSocket 连接的状态，包括连接成功、连接断开、连接错误等。当连接断开时，触发重连逻辑。</p>
</li>
<li><p><strong>重连逻辑</strong>：<br>当连接断开时，客户端根据重连策略进行重连。通常，客户端会尝试重新连接到服务器，并且在连接失败后等待一定的时间后再次尝试重连。可以根据实际情况设定重连的最大次数，避免无限重连造成资源浪费。</p>
</li>
<li><p><strong>断线检测</strong>：<br>客户端可以周期性地向服务器发送心跳包，以检测连接是否断开。如果连续一定次数（如三次）心跳失败，则认为连接已经断开，并触发重连逻辑。</p>
</li>
<li><p><strong>避免重复连接</strong>：<br>在重连过程中，避免重复建立多个连接，可以在重连前检查当前是否已经存在有效的连接，如果存在则不再进行重连。</p>
</li>
</ol>
<p>通过实现上述短线重连机制，可以提高 WebSocket 连接的稳定性和可靠性，确保在网络不稳定或服务器故障等情况下能够及时恢复连接。</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex：1&#x3D;flex-grow,flex-shrink,flex-basic；</p>
<h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>111</p>
<h2 id="Margin塌陷"><a href="#Margin塌陷" class="headerlink" title="Margin塌陷"></a>Margin塌陷</h2><p>一、当父元素中第一个子元素设置margin-top时，目的是设置子元素与父元素顶部的距离，实际上却实现的是父元素和上一个元素的顶部距离，这种现象称之为margin塌陷。</p>
<p>解决方案：</p>
<p>1、在父元素中书写：overflow：hidden；</p>
<p>2、使用父元素的padding-top替代子元素的margin-top;</p>
<p>3、为父元素添加透明边框border:solid 1px transparent</p>
<p>二、兄弟元素之间的margin塌陷问题：</p>
<p>上方元素设置 margin-bottom，下方设置margin-top,最终两个元素之间的距离不等于两个margin之和。</p>
<p>解决方案：</p>
<p>无需解决，当需要设置两个元素之间的垂直距离时，为其中的一个元素设置margin即可。</p>
<p>三、元素自身的塌陷问题</p>
<p>当父元素的高度设置为auto或不写，同时内部子元素设置了浮动属性时，父元素的高度会发生自身塌陷。</p>
<p>解决方案：</p>
<p>1、内部子元素不使用浮动属性，可以使用display将子元素设置为内联块；</p>
<p>2、在父元素上添加overflow：hidden，</p>
<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(value) &#123;</span><br><span class="line">  return JSON.parse(JSON.stringify(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局限性：</p>
<ul>
<li>它无法复制函数。</li>
<li>它无法复制循环引用。</li>
<li>它不会拷贝 <code>undefined</code>。</li>
<li>它无法处理特定属性（如 <code>Symbol</code> 属性、属性名为 <code>Symbol</code> 类型的属性等）。</li>
</ul>
<p>递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;object&quot;</span> || value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value; <span class="comment">// 返回原始值类型</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">    <span class="comment">// 使用 hasOwnProperty 检查以避免原型链中的键</span></span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 递归复制每个属性值</span></span><br><span class="line">      result[key] = <span class="title function_">deepClone</span>(value[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="浏览器的缓存"><a href="#浏览器的缓存" class="headerlink" title="浏览器的缓存"></a>浏览器的缓存</h2><p><code>Cache-Control</code> 是 HTTP 头部中控制缓存行为的重要指令。它可以指示客户端和代理服务器如何缓存响应以及在缓存中存储多长时间。</p>
<p>下面是 <code>Cache-Control</code> 头部常见的指令：</p>
<ol>
<li><p><strong>public</strong>：指示响应可以被任何缓存（包括代理服务器）缓存。</p>
</li>
<li><p><strong>private</strong>：指示响应只能被终端用户缓存，不允许代理服务器缓存。这意味着每个用户都可以看到自己的个性化响应。</p>
</li>
<li><p><strong>no-cache</strong>：指示客户端在使用缓存之前必须先验证响应的有效性，即使缓存中有对应的响应也不例外。</p>
</li>
<li><p><strong>no-store</strong>：指示客户端和代理服务器不得缓存任何版本的响应。</p>
</li>
<li><p>**max-age&#x3D;&lt;seconds&gt;**：指示响应在被认为过期之前可以在缓存中存储的时间，以秒为单位。</p>
</li>
<li><p>**s-maxage&#x3D;&lt;seconds&gt;**：类似于 <code>max-age</code>，但它只适用于共享缓存，例如代理服务器。</p>
</li>
<li><p><strong>must-revalidate</strong>：指示客户端在使用缓存之前必须重新验证响应的有效性，如果验证失败，则必须从服务器获取新的响应。</p>
</li>
<li><p><strong>proxy-revalidate</strong>：类似于 <code>must-revalidate</code>，但它只适用于代理服务器。</p>
</li>
<li><p><strong>immutable</strong>：指示响应的内容不会随时间的推移而改变，这意味着客户端可以安全地假定缓存中的响应是不变的。</p>
</li>
</ol>
<p>这些指令可以单独使用，也可以组合使用，以控制缓存的行为。例如，您可以使用 <code>Cache-Control: max-age=3600, public</code> 指令来允许公共缓存（包括代理服务器）在 3600 秒（1 小时）内缓存响应。</p>
<p>使用 <code>Cache-Control</code> 头部可以有效地管理浏览器和代理服务器的缓存行为，提高网站性能和用户体验。</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>promise.all</p>
<p>promise.race</p>
<p>promise.reslove</p>
<p>promise.rejected</p>
<p>promise.then</p>
<h2 id="fetch、axios、ajax"><a href="#fetch、axios、ajax" class="headerlink" title="fetch、axios、ajax"></a>fetch、axios、ajax</h2><p>在处理前端的HTTP请求时，<code>fetch</code>、<code>axios</code>和<code>ajax</code>（通常指使用jQuery的$.ajax）是三种常见的技术。每种技术都有其独特之处，适用于不同的场景：</p>
<h3 id="1-Fetch"><a href="#1-Fetch" class="headerlink" title="1. Fetch"></a>1. Fetch</h3><p><code>fetch</code>是现代浏览器内置的一个原生API，用于异步请求。它不依赖于任何外部库，是XMLHttpRequest的现代替代品。<code>fetch</code>提供了一个更加强大和灵活的特性集，支持Promise，使得异步代码更容易编写和管理。</p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>原生支持Promise。</li>
<li>语法简洁，易于理解和使用。</li>
<li>不需要额外的库或框架。</li>
<li>支持流，允许请求和响应体进行流处理。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>默认不发送cookies，需要额外配置。</li>
<li>不支持请求取消（直到最近的AbortController出现）。</li>
<li>错误处理较为复杂，需要额外的代码来处理非200状态码。</li>
</ul>
</li>
</ul>
<h3 id="2-Axios"><a href="#2-Axios" class="headerlink" title="2. Axios"></a>2. Axios</h3><p><code>axios</code>是一个基于Promise的HTTP客户端，适用于浏览器和node.js。它是一个独立的第三方库，可以通过npm或CDN进行安装。</p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>支持浏览器和Node.js。</li>
<li>可以拦截请求和响应，便于添加通用处理逻辑。</li>
<li>自动转换JSON数据。</li>
<li>支持请求和响应的配置，如超时设置。</li>
<li>支持请求取消。</li>
<li>更全面的错误处理。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>需要额外安装，增加项目的依赖。</li>
<li>体积相对较大，尤其是在只需要简单功能的场景中。</li>
</ul>
</li>
</ul>
<h3 id="3-Ajax-jQuery"><a href="#3-Ajax-jQuery" class="headerlink" title="3. Ajax (jQuery)"></a>3. Ajax (jQuery)</h3><p><code>ajax</code>方法通常是指jQuery库中的$.ajax函数，这是处理异步HTTP请求的早期方式之一。虽然jQuery已经不如以前那么流行，但$.ajax依然在许多遗留项目中广泛使用。</p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>在jQuery生态系统中集成良好。</li>
<li>简单的配置和调用方式。</li>
<li>广泛的浏览器支持。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>依赖于jQuery，对于不使用jQuery的现代项目来说可能是额外的负担。</li>
<li>不支持Promise，虽然可以使用<code>$.Deferred()</code>。</li>
<li>体积相对较大，特别是对于需要轻量级库的现代前端应用来说。</li>
</ul>
</li>
</ul>
<p>在选择这三种技术时，应考虑项目需求、浏览器支持以及开发团队对这些技术的熟悉程度。对于现代Web应用，推荐使用<code>fetch</code>或<code>axios</code>，因为它们更符合当前的开发趋势和性能要求。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h2 id="四叉树和游程编码"><a href="#四叉树和游程编码" class="headerlink" title="四叉树和游程编码"></a>四叉树和游程编码</h2><p>四叉树（Quadtree）和游程编码（Run-Length Encoding，RLE）是两种不同的数据结构和编码方式，用于在计算机科学和图形学中处理图像和空间数据。</p>
<h3 id="四叉树（Quadtree）："><a href="#四叉树（Quadtree）：" class="headerlink" title="四叉树（Quadtree）："></a>四叉树（Quadtree）：</h3><p>四叉树是一种树状数据结构，它将二维空间递归地划分为四个象限（或子节点），每个节点可以继续划分为四个子节点，以此类推。四叉树通常用于表示二维空间中的点、区域或图像等数据结构，具有以下特点：</p>
<ul>
<li><strong>递归划分</strong>：四叉树递归地将空间划分为四个象限，直到达到某个终止条件。</li>
<li><strong>空间分割</strong>：每个节点代表了空间中的一个矩形区域，通过四个子节点来表示该区域的四个子区域。</li>
<li><strong>空间查询</strong>：四叉树可以用于空间查询，例如快速查找某个点所在的区域、查找覆盖某个区域的所有点等。</li>
</ul>
<p>四叉树在图像处理中常用于表示图像的分层结构，可以用于图像压缩、碰撞检测、空间索引等方面。</p>
<h3 id="游程编码（Run-Length-Encoding，RLE）："><a href="#游程编码（Run-Length-Encoding，RLE）：" class="headerlink" title="游程编码（Run-Length Encoding，RLE）："></a>游程编码（Run-Length Encoding，RLE）：</h3><p>游程编码是一种简单的无损数据压缩技术，它通过记录连续重复出现的数据项来减少数据的存储空间。游程编码通常应用于处理二值图像或具有大量重复值的数据，具有以下特点：</p>
<ul>
<li><strong>连续重复值编码</strong>：游程编码将连续重复出现的数据项用一个计数值和一个重复的数据值来表示，从而减少存储空间。</li>
<li><strong>简单高效</strong>：游程编码是一种简单而高效的压缩算法，适用于处理大量重复值的数据。</li>
</ul>
<p>游程编码在图像处理中常用于黑白图像的压缩，尤其是在处理文档扫描图像或简单图形图像时，可以显著减少图像的存储空间。</p>
<p>综上所述，四叉树和游程编码是两种不同的数据结构和压缩算法，分别用于处理空间数据和减少数据存储空间。它们在不同的领域和应用场景中发挥着重要的作用。</p>
<h2 id="二叉树-K"><a href="#二叉树-K" class="headerlink" title="二叉树-K"></a>二叉树-K</h2><p>当我们说到二叉树的前序遍历时，我们指的是按照根节点 - 左子树 - 右子树的顺序遍历整个树。这里给出两种不同的实现方式：</p>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>递归是最直接的方法之一，它基于以下思想：对于每个节点，先访问根节点，然后递归地遍历左子树和右子树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">root</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        result.extend(preorderTraversal(root.left))</span><br><span class="line">        result.extend(preorderTraversal(root.right))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">root = TreeNode(<span class="number">1</span>)</span><br><span class="line">root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">root.left.left = TreeNode(<span class="number">4</span>)</span><br><span class="line">root.left.right = TreeNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(preorderTraversal(root))  <span class="comment"># 输出: [1, 2, 4, 5, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代实现（使用栈）"><a href="#迭代实现（使用栈）" class="headerlink" title="迭代实现（使用栈）"></a>迭代实现（使用栈）</h3><p>另一种实现方式是使用迭代，我们可以使用栈来模拟递归的过程。具体做法是维护一个栈，将右子节点和左子节点按相反的顺序压入栈中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    stack = [root]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        result.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法（使用相同的二叉树）</span></span><br><span class="line"><span class="built_in">print</span>(preorderTraversal(root))  <span class="comment"># 输出: [1, 2, 4, 5, 3]</span></span><br></pre></td></tr></table></figure>

<p>这两种方法都可以用来实现二叉树的前序遍历，具体选择哪种方法取决于您的偏好和实际需求。</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h2><p>Vue.js 的双向数据绑定是其核心特性之一，它允许数据的变化驱动视图更新，同时视图的交互也能改变数据。这种双向绑定在 Vue 2 和 Vue 3 中都是通过一些底层原理和技术实现的，其中就包括发布-订阅者模式。</p>
<p>发布-订阅者模式</p>
<p>发布-订阅者模式是一种消息通信模式，其中发送者（发布者）不直接发送消息给特定的接收者（订阅者），而是将消息发送到一个中介（通常是消息队列或事件中心），而接收者则从该中介获取消息。这种模式允许发送者和接收者之间的解耦，因为发送者不需要知道哪些接收者会收到消息，同样，接收者也不需要知道消息是从哪里发送的。</p>
<p>在 Vue 的上下文中，数据对象可以被视为发布者，当数据发生变化时，它会发布一个事件。Vue 的依赖追踪系统则充当了中介的角色，它跟踪了哪些组件依赖于哪些数据。当数据变化时，依赖追踪系统会将这个变化通知给所有相关的组件，这些组件就是订阅者。</p>
<p>实现一个发布订阅模式</p>
<p>在JavaScript中，实现一个简单的发布-订阅模式可以通过使用事件和回调函数来完成。下面是一个简单的实现，其中Publisher类负责发布事件，Subscriber类负责订阅事件并接收通知。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个存储所有订阅者的对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅事件</span></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果该事件还没有订阅者，则初始化一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">subscribers</span>[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将回调函数添加到订阅者数组中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>[event].<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">subscribers</span>[event]) &#123;</span><br><span class="line">      <span class="comment">// 查找回调函数并移除</span></span><br><span class="line">      <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">subscribers</span>[event].<span class="title function_">indexOf</span>(callback);</span><br><span class="line">      <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subscribers</span>[event].<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布事件</span></span><br><span class="line">  <span class="title function_">publish</span>(<span class="params">event, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果有订阅了该事件的订阅者，则通知他们</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">subscribers</span>[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>[event].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(...args);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subscriber</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅事件时需要的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置回调函数</span></span><br><span class="line">  <span class="title function_">setCallback</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span> = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅事件</span></span><br><span class="line">  <span class="title function_">subscribeTo</span>(<span class="params">publisher, event</span>) &#123;</span><br><span class="line">    publisher.<span class="title function_">subscribe</span>(event, <span class="variable language_">this</span>.<span class="property">callback</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  <span class="title function_">unsubscribeFrom</span>(<span class="params">publisher, event</span>) &#123;</span><br><span class="line">    publisher.<span class="title function_">unsubscribe</span>(event, <span class="variable language_">this</span>.<span class="property">callback</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> publisher = <span class="keyword">new</span> <span class="title class_">Publisher</span>();</span><br><span class="line"><span class="keyword">const</span> subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置订阅者的回调函数</span></span><br><span class="line">subscriber.<span class="title function_">setCallback</span>(<span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received message: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者订阅事件</span></span><br><span class="line">subscriber.<span class="title function_">subscribeTo</span>(publisher, <span class="string">&#x27;messageEvent&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者发布事件</span></span><br><span class="line">publisher.<span class="title function_">publish</span>(<span class="string">&#x27;messageEvent&#x27;</span>, <span class="string">&#x27;Hello, World!&#x27;</span>); <span class="comment">// 输出: Received message: Hello, World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">subscriber.<span class="title function_">unsubscribeFrom</span>(publisher, <span class="string">&#x27;messageEvent&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次发布事件，订阅者不会收到通知</span></span><br><span class="line">publisher.<span class="title function_">publish</span>(<span class="string">&#x27;messageEvent&#x27;</span>, <span class="string">&#x27;Another message&#x27;</span>); <span class="comment">// 无输出</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，Publisher类负责管理事件和订阅者，Subscriber类则用于订阅和取消订阅事件。subscribe方法用于订阅事件，它将回调函数存储在subscribers对象中，每个事件对应一个回调函数数组。unsubscribe方法用于取消订阅，它从相应的回调数组中移除指定的回调函数。publish方法用于发布事件，它会遍历所有订阅了该事件的回调函数，并调用它们。</p>
<p>请注意，这个简单的发布-订阅模式实现没有考虑诸如异步通知、错误处理、取消订阅特定事件的所有回调等高级功能。在实际应用中，可能需要使用更复杂和健壮的实现，比如使用现成的库（如EventEmitter3、lodash的_.events等）或者使用更高级的异步编程模式（如Promises和async&#x2F;await）。</p>
<p>Vue 2 的双向绑定原理</p>
<p>在 Vue 2 中，双向数据绑定主要依赖于以下几个部分：</p>
<p>数据劫持：Vue 使用 Object.defineProperty() 方法劫持了各个属性的 setter 和 getter，在数据变动时发布消息给订阅者。<br>依赖收集：当组件渲染时，会遍历其依赖的数据，并为这些数据添加一个订阅者（通常是组件的 watcher）。这样，当数据变化时，就可以通知到这个组件。<br>发布-订阅者模式：如上所述，当数据变化时，会发布一个事件，所有依赖这个数据的组件（订阅者）都会收到通知并更新。<br>Vue 3 的双向绑定原理</p>
<p>Vue 3 在数据绑定方面进行了很多优化和改进，主要依赖于 Proxy 对象来实现。</p>
<p>Proxy 对象：Vue 3 使用 Proxy 对象来劫持数据对象的所有属性，包括新增和删除的属性。这使得 Vue 3 在处理数据变化时更加高效和灵活。<br>Reactive 和 Ref API：Vue 3 提供了 Reactive 和 Ref API 来创建响应式数据。Reactive 用于创建响应式对象，而 Ref 则用于创建响应式引用。<br>依赖收集和通知更新：与 Vue 2 类似，Vue 3 也使用了依赖收集和发布-订阅者模式来实现数据的变化驱动视图更新。但由于使用了 Proxy，这个过程在 Vue 3 中更加高效和简洁。</p>
<p>总的来说，无论是 Vue 2 还是 Vue 3，双向数据绑定都是通过发布-订阅者模式实现的，但具体的实现细节和技术有所不同。Vue 3 在这方面进行了很多优化和改进，使得数据绑定更加高效和可靠。</p>
<h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>Vue.js 的 diff 算法是一个核心机制，用于有效地更新真实 DOM，尤其是在数据改变时更新视图。Vue 使用虚拟 DOM 来表示界面上的结构，虚拟 DOM 是一个轻量级的 JavaScript 对象结构。当数据发生变化时，Vue 会生成一个新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行比较，这个比较过程称为 “diffing”。Vue 的 diff 算法基于以下几个关键步骤和原则：</p>
<ol>
<li><p><strong>节点比较</strong>：</p>
<ul>
<li>Vue diff 算法首先比较根节点，如果根节点的类型（如元素类型、组件类型）或 key 值不同，则直接替换整个节点。</li>
<li>如果节点类型相同，则进一步比较其子节点。</li>
</ul>
</li>
<li><p><strong>同级比较</strong>：</p>
<ul>
<li>Vue 的 diff 算法主要关注同级别的子节点比较。对于子节点，Vue 使用 “updateChildren” 函数来进行高效的比较和更新。</li>
<li>Vue 采用 “双端比较” 策略。算法维护四个指针：两个指向旧节点的开始和结束位置，两个指向新节点的开始和结束位置。在比较过程中，根据不同情况移动这些指针并相应地更新 DOM。</li>
</ul>
</li>
<li><p><strong>关键优化</strong>：</p>
<ul>
<li><strong>头头比较</strong>（oldStartVnode vs. newStartVnode）</li>
<li><strong>尾尾比较</strong>（oldEndVnode vs. newEndVnode）</li>
<li><strong>头尾比较</strong>（oldStartVnode vs. newEndVnode）</li>
<li><strong>尾头比较</strong>（oldEndVnode vs. newStartVnode）</li>
<li>在以上四种基本比较中，一旦发现节点匹配，就会进行适当的 DOM 操作，如移动 DOM 节点或更新节点等，并调整指针继续比较。</li>
</ul>
</li>
<li><p><strong>列表中的 key 值</strong>：</p>
<ul>
<li>Vue 推荐为每个使用 v-for 指令的元素指定一个唯一的 key 值，这可以极大地提高 diff 算法的效率。有了 key，Vue 可以更快地识别节点是否可以重用，从而减少不必要的 DOM 操作。</li>
</ul>
</li>
<li><p><strong>性能考虑</strong>：</p>
<ul>
<li>Vue 的 diff 算法尽量减少遍历次数和最小化 DOM 操作，以保证高效的性能。通过智能比较和有条件的节点重用，Vue 可以快速准确地更新 DOM。</li>
</ul>
</li>
</ol>
<p>总之，Vue 的 diff 算法通过比较旧的虚拟 DOM 和新的虚拟 DOM 的差异，有效地更新真实 DOM，只改变必要的部分，而不是重建整个 DOM 树，从而保证了应用的性能和响应速度。这种机制是现代前端框架中提高效率的关键。</p>
<h2 id="watch和computed"><a href="#watch和computed" class="headerlink" title="watch和computed"></a>watch和computed</h2><ul>
<li>computed（计算属性）用于声明式地声明一个依赖于其他数据属性的值，这个值是基于其他数据属性的计算结果，只有在依赖的数据属性发生变化时才会重新计算，computed支持缓存，可以提高性能，适用于需要缓存计算结果的场景，如购物车商品结算等。</li>
<li>watch则用于观察和响应数据属性的变化，当指定的数据属性发生变化时，它会执行相应的回调函数，watch更适合用于执行异步操作或开销较大的操作，如网络请求或动画效果等，它不支持缓存，且可以设置为立即执行或在数据对象内部发生变化时深度监听，适用于需要对数据进行复杂处理或异步操作的场景。</li>
</ul>
<h2 id="Nexttick"><a href="#Nexttick" class="headerlink" title="Nexttick"></a>Nexttick</h2><p>Vue.nextTick 是 Vue.js 中的一个方法，它用于延迟执行一段代码，直到下次 DOM 更新循环结束。这有助于我们在修改数据后获取更新后的 DOM 状态。</p>
<p>原理：Vue.nextTick 是通过 JavaScript 的 Promise 和 MutationObserver 实现的。如果浏览器不支持 Promise 和 MutationObserver，Vue 会使用 setTimeout 作为回退方案。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Vue.nextTick 的主要用途包括：</p>
<ol>
<li><strong>获取更新后的 DOM 状态</strong>：如果你需要在数据变化后获取更新后的 DOM 元素或计算属性，可以使用 Vue.nextTick 来确保你获取的是最新的状态。</li>
<li><strong>执行依赖于更新后 DOM 的操作</strong>：例如，你可能需要在数据变化后立即执行某些动画或者测量 DOM 元素的大小。在这些情况下，使用 Vue.nextTick 可以确保你的代码在 DOM 更新后执行。</li>
<li><strong>确保多个 DOM 更新顺序执行</strong>：有时你可能需要顺序执行多个更新操作，并且希望它们都在 DOM 更新后执行。通过使用 Vue.nextTick，你可以确保这些操作按照预期的顺序执行。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个 Vue 实例</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">updateMessage</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;Updated message&#x27;</span>;</span><br><span class="line">      <span class="comment">// 使用 Vue.nextTick 获取更新后的 DOM</span></span><br><span class="line">      <span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// DOM 更新了</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">div</span>.<span class="property">textContent</span>); <span class="comment">// 输出: Updated message</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当 updateMessage 方法被调用时，它会更新 message 属性。然后使用 this.$nextTick 来注册一个回调函数，这个回调会在 DOM 更新完成后执行，此时我们可以安全地读取更新后的 DOM 元素内容。</p>
<h2 id="ref和reactive区别"><a href="#ref和reactive区别" class="headerlink" title="ref和reactive区别"></a>ref和reactive区别</h2><ul>
<li>定义类型和数据类型不同。<code>ref</code>主要用于定义基本类型（如字符串、数字、布尔值等）的数据，而<code>reactive</code>主要用于定义对象和数组等复杂类型的数据。如果<code>ref</code>传入的是引用类型，其内部源码也是调用<code>reactive</code>来实现的。</li>
<li>使用方式和访问不同。在使用上，<code>ref</code>需要在模板中使用<code>ref</code>指令，在JavaScript代码中使用<code>ref</code>函数进行创建和使用。而<code>reactive</code>则需要通过调用Vue.js提供的<code>reactive</code>函数进行包装和创建。对于通过<code>ref</code>函数创建的响应式数据，需要通过<code>.value</code>属性来访问值；而对于通过<code>reactive</code>函数创建的响应式对象，可以直接访问其属性或调用其方法。</li>
<li>设计理念不同。<code>ref</code>主要解决单一元素&#x2F;数据的响应式问题，而<code>reactive</code>则是为了解决JavaScript对象和数组等复杂数据结构的响应式问题。</li>
</ul>
<p>当涉及到 Vue.js 中的 <code>ref</code> 和 <code>reactive</code>，它们都是 Vue.js 提供的函数，用于创建响应式数据和引用。下面我将为您提供具体的实现讲解。</p>
<h3 id="使用-ref"><a href="#使用-ref" class="headerlink" title="使用 ref"></a>使用 <code>ref</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个响应式引用</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问引用的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>); <span class="comment">// 输出: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改引用的值</span></span><br><span class="line">count.<span class="property">value</span>++; <span class="comment">// 现在 count 的值为 1</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用 <code>ref()</code> 函数创建了一个名为 <code>count</code> 的响应式引用，其初始值为 <code>0</code>。注意在访问引用的值时，我们需要使用 <code>.value</code> 属性。修改引用的值也需要通过 <code>.value</code> 属性。这样做的好处是，Vue.js 可以追踪到这个引用的变化。</p>
<h3 id="使用-reactive"><a href="#使用-reactive" class="headerlink" title="使用 reactive"></a>使用 <code>reactive</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个普通 JavaScript 对象</span></span><br><span class="line"><span class="keyword">const</span> state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将普通对象转换为响应式对象</span></span><br><span class="line"><span class="keyword">const</span> reactiveState = <span class="title function_">reactive</span>(state);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问响应式对象的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reactiveState.<span class="property">count</span>); <span class="comment">// 输出: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改响应式对象的属性</span></span><br><span class="line">reactiveState.<span class="property">count</span>++; <span class="comment">// 现在 reactiveState.count 的值为 1</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个普通的 JavaScript 对象 <code>state</code>，其中包含一个属性 <code>count</code>。然后，我们使用 <code>reactive()</code> 函数将这个普通对象转换为一个响应式对象 <code>reactiveState</code>。与 <code>ref</code> 不同，<code>reactive</code> 可以将整个对象转换为响应式，而不仅仅是其中的一个值。这意味着当我们修改 <code>reactiveState</code> 对象的属性时，Vue.js 会自动追踪这些变化，并且更新相关的视图。</p>
<p>通过以上示例，您可以了解到如何在 Vue.js 中使用 <code>ref</code> 和 <code>reactive</code> 函数来创建响应式数据和引用。</p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="Fiber架构是什么，以及它解决了React之前版本中的哪些问题"><a href="#Fiber架构是什么，以及它解决了React之前版本中的哪些问题" class="headerlink" title="Fiber架构是什么，以及它解决了React之前版本中的哪些问题"></a>Fiber架构是什么，以及它解决了React之前版本中的哪些问题</h2><p>Fiber架构是React16中引入的新的核心算法，它重新实现了React的调和和渲染过程，使得React能够更高效地处理大型和复杂的组件树。Fiber解决了React16之前版本中存在的一些关键问题，如：</p>
<ol>
<li><strong>不可中断的渲染过程</strong>：在React16之前，一旦开始渲染，React会阻塞主线程直到渲染完成。这可能导致UI冻结，特别是在处理大型组件树或高优先级任务（比如用户输入）时。</li>
<li><strong>固定的任务优先级</strong>：之前的React版本无法区分任务的优先级，导致所有任务都按照相同的顺序执行。这不利于响应性，因为高优先级的任务（比如用户交互）可能会被低优先级的任务（比如数据获取）阻塞。</li>
</ol>
<p>Fiber通过以下方式解决了这些问题：</p>
<ul>
<li><strong>任务拆分与中断</strong>：Fiber架构将渲染过程拆分成多个小任务，并且可以在任意时间点中断和恢复这些任务。这使得React能够在渲染过程中响应其他高优先级任务，提高了应用的响应性。</li>
<li><strong>优先级调度</strong>：Fiber架构引入了任务优先级的概念，允许React根据任务的优先级来调度工作。高优先级的任务会优先得到处理，从而确保用户交互等关键任务的流畅执行。</li>
</ul>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>props、回调函数</p>
<p>context</p>
<p>redux</p>
<p>event bus</p>
<h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><p>usestate  </p>
<p>useeffect</p>
<p>useref 使用原因</p>
<blockquote>
<p>使用 state 会造成没必要的重新渲染，用全局变量又会造成闭包问题</p>
</blockquote>
<p>usememo  缓存值</p>
<p>usecallback  缓存函数</p>
<p>usecontext</p>
<h2 id="获取原生DOM节点的方法"><a href="#获取原生DOM节点的方法" class="headerlink" title="获取原生DOM节点的方法"></a>获取原生DOM节点的方法</h2><p>getElementById</p>
<p>getElementByTagName</p>
<p>getElementByName</p>
<p>getElementByClassName</p>
<p>querySelector</p>
<p>querySelectorAll</p>
<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>entry</p>
<p>output</p>
<p>derServe</p>
<p>loader–css部分-对象+plugin–js–全程–数组</p>
<p>loader:modules</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="页面阻塞"><a href="#页面阻塞" class="headerlink" title="页面阻塞"></a>页面阻塞</h2><p>页面渲染阻塞是Web性能优化中常见的问题，这会影响到页面加载时间和用户体验。通常，渲染阻塞的原因与资源的加载、解析以及执行方式有关。以下是一些常见的原因：</p>
<h3 id="1-同步加载的JavaScript"><a href="#1-同步加载的JavaScript" class="headerlink" title="1. 同步加载的JavaScript"></a>1. 同步加载的JavaScript</h3><ul>
<li><strong>阻塞解析</strong>：当浏览器在HTML文档中遇到一个<code>&lt;script&gt;</code>标签时，它会停止HTML的解析，转而去加载并执行JavaScript文件。如果这些脚本是同步加载的（没有<code>async</code>或<code>defer</code>属性），它们会阻塞页面的渲染直到脚本执行完毕。</li>
<li><strong>依赖于DOM的脚本</strong>：如果脚本需要在DOM完全解析后才能运行，它们同样会导致页面渲染的延迟。</li>
</ul>
<h3 id="2-非异步的CSS文件"><a href="#2-非异步的CSS文件" class="headerlink" title="2. 非异步的CSS文件"></a>2. 非异步的CSS文件</h3><ul>
<li><strong>CSS是渲染阻塞的</strong>：CSS必须被下载和解析完成后，浏览器才能正确渲染页面内容，因为浏览器需要知道如何显示页面中的所有元素。如果CSS资源加载延迟，页面渲染也会被延迟。</li>
</ul>
<h3 id="3-大量DOM元素"><a href="#3-大量DOM元素" class="headerlink" title="3. 大量DOM元素"></a>3. 大量DOM元素</h3><ul>
<li><strong>DOM复杂性</strong>：页面上DOM元素数量过多或结构过于复杂，会导致浏览器在构建DOM树和渲染树时花费更多时间，从而延迟了页面渲染。</li>
</ul>
<h3 id="4-重定向和网络延迟"><a href="#4-重定向和网络延迟" class="headerlink" title="4. 重定向和网络延迟"></a>4. 重定向和网络延迟</h3><ul>
<li><strong>重定向</strong>：HTTP重定向增加了额外的网络请求，这不仅增加了页面加载时间，也可能阻塞页面渲染，直到重定向完成。</li>
<li><strong>网络问题</strong>：网络延迟或连接问题会延迟资源的下载，包括HTML、CSS、JavaScript等，从而影响页面的首次渲染时间。</li>
</ul>
<h3 id="5-大型资源和未优化的内容"><a href="#5-大型资源和未优化的内容" class="headerlink" title="5. 大型资源和未优化的内容"></a>5. 大型资源和未优化的内容</h3><ul>
<li><strong>未压缩的资源</strong>：大型的JavaScript和CSS文件，特别是未经压缩或优化的，需要更多时间加载和解析。</li>
<li><strong>图片和媒体内容</strong>：大型的图片和视频资源没有进行适当的优化和懒加载，会占用大量带宽，延迟页面内容的可见时间。</li>
</ul>
<h3 id="6-JavaScript执行占用主线程"><a href="#6-JavaScript执行占用主线程" class="headerlink" title="6. JavaScript执行占用主线程"></a>6. JavaScript执行占用主线程</h3><ul>
<li><strong>长时间运行的JavaScript</strong>：复杂的脚本或大量的同步JavaScript代码可以占用浏览器主线程，阻止页面的进一步渲染直到脚本执行完成。</li>
</ul>
<h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><p>为了避免这些阻塞，通常会采取以下优化策略：</p>
<ul>
<li>使用<code>async</code>或<code>defer</code>属性加载JavaScript，以非阻塞方式执行脚本。</li>
<li>确保关键CSS尽可能早地加载，并使用媒体查询或条件加载非关键CSS。</li>
<li>简化DOM结构，减少页面复杂性。</li>
<li>优化重定向，减少不必要的中间跳转。</li>
<li>压缩资源，包括JavaScript、CSS和图片，减少文件大小和下载时间。</li>
<li>对于大型的媒体文件，实施懒加载策略，只有在需要时才加载这些资源。</li>
</ul>
<p>通过这些方法，可以显著提升页面的加载速度和用户体验。</p>
<h2 id="文件上传-X"><a href="#文件上传-X" class="headerlink" title="文件上传-X"></a>文件上传-X</h2><p>文件上传是 Web 开发中常见的功能之一，可以通过一些优化来提升用户体验和系统性能。以下是一些文件上传的优化方法和实现方式：</p>
<ol>
<li><p><strong>进度条显示</strong>：<br>显示上传进度条可以让用户清楚地知道文件上传的进度，提升用户体验。您可以使用 HTML5 的 <code>progress</code> 元素或 JavaScript 库（如 Axios、jQuery 等）来实现上传进度的动态更新。</p>
</li>
<li><p><strong>分片上传</strong>：<br>对大文件进行分片上传可以减少单个请求的负载，提高上传速度。前端可以将大文件切分成多个小块，然后分别上传到服务器，服务器端再将这些小块合并成完整的文件。</p>
</li>
<li><p><strong>并发上传</strong>：<br>如果服务器支持，可以使用并发上传来同时上传多个文件或多个文件分片，以提高上传效率。通过使用多线程或异步处理，可以更快地完成文件上传过程。</p>
</li>
<li><p><strong>压缩文件</strong>：<br>如果用户上传的文件支持压缩，可以在上传之前对文件进行压缩处理，减小文件大小，从而降低上传时间和网络带宽的消耗。</p>
</li>
<li><p><strong>文件类型限制</strong>：<br>在前端和后端都进行文件类型的限制，防止用户上传不安全或不支持的文件类型，可以提高系统安全性和稳定性。</p>
</li>
<li><p><strong>服务端缓存</strong>：<br>在服务器端设置文件上传的临时缓存，减少文件传输和处理过程中的数据传输量和IO操作，提高系统性能。</p>
</li>
<li><p><strong>CDN 加速</strong>：<br>使用 CDN（内容分发网络）来加速文件上传过程中的数据传输，减少网络延迟和提高数据传输速度。</p>
</li>
<li><p><strong>断点续传</strong>：<br>实现断点续传功能可以让用户在上传中断后恢复上传进度，而不需要重新上传整个文件。可以通过记录已上传的文件分片信息或使用第三方库来实现。</p>
</li>
<li><p><strong>本地预处理</strong>：<br>在文件上传之前进行客户端的本地预处理，例如压缩、校验、格式转换等，减轻服务器的压力和网络带宽的消耗。</p>
</li>
</ol>
<p>综上所述，文件上传的优化可以从多个方面入手，包括显示上传进度、分片上传、并发上传、压缩文件、文件类型限制、服务端缓存、CDN 加速、断点续传和本地预处理等。根据具体的业务需求和系统架构，选择合适的优化方法来提升文件上传的性能和用户体验。</p>
<p>Web Workers 是一种在后台运行 JavaScript 代码的机制，可以在单独的线程中执行长时间运行的任务，而不会阻塞页面的主线程。通过结合 Web Workers 和文件上传，可以实现文件上传的性能优化，特别是在处理大文件时。</p>
<p>以下是结合 Web Workers 实现文件上传性能优化的一般步骤：</p>
<ol>
<li><p><strong>分片上传</strong>：<br>使用 Web Workers 将大文件切分成多个小块，并在后台并行上传这些小块，以提高上传速度。每个 Web Worker 负责上传一个文件分片，这样可以避免单个请求过于庞大，减少网络延迟和提高上传效率。</p>
</li>
<li><p><strong>并发上传</strong>：<br>创建多个 Web Workers 来并发上传多个文件分片，以充分利用浏览器的多线程能力，进一步提高上传效率。通过设置适当的并发数，可以在不过度消耗系统资源的情况下实现最大化的上传速度。</p>
</li>
<li><p><strong>断点续传</strong>：<br>在 Web Workers 中实现断点续传功能，可以让用户在上传中断后恢复上传进度，而不需要重新上传整个文件。Web Workers 可以记录已上传的文件分片信息，以便在中断后能够恢复上传进度。</p>
</li>
<li><p><strong>本地预处理</strong>：<br>在 Web Workers 中进行文件的本地预处理，例如文件的压缩、校验、格式转换等，可以减轻服务器的压力和网络带宽的消耗，提高上传效率。</p>
</li>
<li><p><strong>进度报告</strong>：<br>使用 Web Workers 实时报告上传进度，以便用户可以清晰地了解文件上传的进展。可以通过在 Web Workers 中监听上传事件并发送进度信息到主线程，然后在页面上更新进度条或显示上传百分比。</p>
</li>
</ol>
<p>综上所述，结合 Web Workers 可以实现文件上传的性能优化，特别是在处理大文件时。通过分片上传、并发上传、断点续传、本地预处理和进度报告等方式，可以提高文件上传的效率、减少用户等待时间，并且减轻服务器的压力。</p>
<h2 id="如何保留上传文件的状态"><a href="#如何保留上传文件的状态" class="headerlink" title="如何保留上传文件的状态"></a>如何保留上传文件的状态</h2><p>在网页开发中，保留已经上传的文件状态是一种常见的需求，特别是在用户需要在表单中填写大量信息或处理大文件时。以下是一些技术和方法，可以在刷新页面后保持文件的上传状态：</p>
<h3 id="1-使用浏览器的本地存储"><a href="#1-使用浏览器的本地存储" class="headerlink" title="1. 使用浏览器的本地存储"></a>1. <strong>使用浏览器的本地存储</strong></h3><ul>
<li><strong>LocalStorage或IndexedDB</strong>：在文件上传前，可以将文件数据存储在浏览器的LocalStorage或IndexedDB中。这种方式适合存储较小的文件或文件的元数据。对于大文件，IndexedDB更为合适，因为它提供了更大的存储空间。</li>
</ul>
<h3 id="2-将文件分片后上传"><a href="#2-将文件分片后上传" class="headerlink" title="2. 将文件分片后上传"></a>2. <strong>将文件分片后上传</strong></h3><ul>
<li><strong>分片上传</strong>：对于大文件，可以在客户端将文件分成多个小片段，然后逐个上传。每上传完一个片段，就可以在服务器上标记该片段的上传状态，并在本地存储已上传的片段信息。如果页面刷新，上传过程可以从上次中断的地方恢复。</li>
</ul>
<h3 id="3-使用Session或Cookies"><a href="#3-使用Session或Cookies" class="headerlink" title="3. 使用Session或Cookies"></a>3. <strong>使用Session或Cookies</strong></h3><ul>
<li><strong>Session或Cookies</strong>：将文件的相关信息（如文件名、大小、已上传的片段索引等）存储在Session或Cookies中。这种方法适合跟踪小型数据，但由于Cookies和Session的存储限制，它们不适合直接存储文件内容。</li>
</ul>
<h3 id="4-服务器端的文件恢复机制"><a href="#4-服务器端的文件恢复机制" class="headerlink" title="4. 服务器端的文件恢复机制"></a>4. <strong>服务器端的文件恢复机制</strong></h3><ul>
<li><strong>服务器存储状态</strong>：服务器可以跟踪每个文件的上传进度。当用户重新加载页面时，可以通过一个API调用询问服务器关于当前上传状态的信息，并据此恢复上传过程。</li>
</ul>
<h3 id="5-使用JavaScript库或框架"><a href="#5-使用JavaScript库或框架" class="headerlink" title="5. 使用JavaScript库或框架"></a>5. <strong>使用JavaScript库或框架</strong></h3><ul>
<li><strong>Resumable.js</strong>：这是一个JavaScript库，允许对大文件进行分片上传，并且能在上传过程中断后恢复。它通过在客户端存储文件的上传状态来实现这一功能。</li>
</ul>
<h3 id="6-创建持久的前端状态"><a href="#6-创建持久的前端状态" class="headerlink" title="6. 创建持久的前端状态"></a>6. <strong>创建持久的前端状态</strong></h3><ul>
<li><strong>Vue.js、React等前端框架</strong>：可以利用现代前端框架的状态管理库（如Vuex、Redux）来持久保存文件的状态。结合本地存储或其他客户端存储解决方案，可以在页面刷新后恢复这些状态。</li>
</ul>
<h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h3><p>假设您使用的是分片上传方法，以下是使用JavaScript进行实现的基本步骤：</p>
<ol>
<li><p><strong>文件选择并分片</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sliceFile</span>(<span class="params">file, size</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> chunks = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(file.<span class="property">size</span> / size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> chunk = file.<span class="title function_">slice</span>(size * i, size * (i + <span class="number">1</span>));</span><br><span class="line">        chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chunks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>上传每个分片</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uploadChunk</span>(<span class="params">chunk, index</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>, chunk);</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&quot;index&quot;</span>, index);</span><br><span class="line">    <span class="comment">// 使用 fetch 或其他 AJAX 方法上传</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;upload_url&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: formData &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Chunk uploaded&#x27;</span>, data))</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error uploading chunk&#x27;</span>, error));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在本地存储中跟踪已上传的分片</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateUploadProgress</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;uploadedChunks&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;uploadedChunks&#x27;</span>) || <span class="string">&#x27;[]&#x27;</span>), index]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>刷新页面后检查上传状态，并恢复</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkAndResumeUpload</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> uploadedChunks = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;uploadedChunks&#x27;</span>) || <span class="string">&#x27;[]&#x27;</span>));</span><br><span class="line">    <span class="keyword">let</span> chunks = <span class="title function_">sliceFile</span>(file, <span class="variable constant_">CHUNK_SIZE</span>);</span><br><span class="line">    chunks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">chunk, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!uploadedChunks.<span class="title function_">has</span>(index)) &#123;</span><br><span class="line">            <span class="title function_">uploadChunk</span>(chunk, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些方法提供了不同的方式来处理页面刷新时文件上传状态的保留问题，具体选择哪</p>
<p>种方法取决于应用的需求、文件大小以及用户体验的考量。</p>
<h2 id="说说-weback-与-vite"><a href="#说说-weback-与-vite" class="headerlink" title="说说 weback 与 vite"></a>说说 weback 与 vite</h2><p>Webpack 和 Vite 都是现代前端开发中常用的构建工具，它们有一些相似之处，但也有一些显著的区别。</p>
<h3 id="Webpack："><a href="#Webpack：" class="headerlink" title="Webpack："></a>Webpack：</h3><p>Webpack 是一个功能强大的静态模块打包工具，可以处理 JavaScript、CSS、图片等多种资源，并且支持代码分割、懒加载、热模块替换（HMR）等功能。Webpack 使用配置文件来定义构建过程，可以通过配置文件来配置各种加载器（loader）和插件（plugin），对各种资源进行处理和优化。</p>
<p>优点：</p>
<ul>
<li>功能强大：Webpack 提供了丰富的功能和插件生态系统，可以满足各种复杂项目的构建需求。</li>
<li>灵活性高：Webpack 的配置灵活，可以根据项目需求进行定制和优化。</li>
<li>社区庞大：Webpack 是目前最流行的前端构建工具之一，拥有庞大的社区支持和丰富的插件资源。</li>
</ul>
<p>缺点：</p>
<ul>
<li>配置复杂：Webpack 的配置相对复杂，学习曲线较陡峭，初学者可能需要花费一些时间来理解和掌握其用法。</li>
<li>构建速度慢：由于 Webpack 需要对整个项目进行构建和打包，对于大型项目而言，构建速度可能较慢。</li>
</ul>
<h3 id="Vite："><a href="#Vite：" class="headerlink" title="Vite："></a>Vite：</h3><p>Vite 是一个由 Vue.js 核心团队开发的新型前端构建工具，它专注于快速开发环境和快速构建速度。Vite 基于现代浏览器的原生 ES 模块导入功能，采用了“即时编译”（Instant Build）的模式，可以实现快速的开发和热更新。</p>
<p>优点：</p>
<ul>
<li>极速开发：Vite 基于原生 ES 模块导入，利用现代浏览器的原生支持，可以实现毫秒级的冷启动和热更新，极大地提高了开发效率。</li>
<li>简单配置：Vite 的配置相对简单，不需要复杂的配置文件，使用默认配置即可快速启动项目。</li>
<li>支持 Vue 3：作为 Vue.js 核心团队开发的工具，Vite 对 Vue 3 的支持非常友好，并且提供了一些针对 Vue 3 的优化和扩展。</li>
</ul>
<p>缺点：</p>
<ul>
<li>生态相对较弱：相比于 Webpack，Vite 的生态相对较新，插件资源相对较少，可能不适用于某些复杂的项目需求。</li>
<li>对传统项目支持有限：由于 Vite 基于原生 ES 模块导入，对于传统的 CommonJS 模块导入的项目支持有限。</li>
</ul>
<p>总的来说，Webpack 和 Vite 都是优秀的前端构建工具，具有各自的特点和优势。选择合适的工具取决于项目的需求和团队的偏好，有些项目可能更适合使用 Webpack，而有些项目可能更适合使用 Vite。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Lavender321.github.com">流泪猫猫头</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lavender321.github.com/2024/04/24/%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/">http://lavender321.github.com/2024/04/24/%E5%B0%8F%E7%B1%B3%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Lavender321.github.com" target="_blank">Lavender's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/25/%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%A2%98/" title="代码输出题"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">代码输出题</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/21/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" title="HTTP相关知识点"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HTTP相关知识点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/18/%E8%85%BE%E8%AE%AF%E9%9D%A2%E7%BB%8F/" title="腾讯面经"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-18</div><div class="title">腾讯面经</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">流泪猫猫头</div><div class="author-info__description">THE TORTURED POETS DEPARTMENT</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lavender321"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lavender321" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:r1727439300@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML"><span class="toc-number">1.</span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">语义化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.</span> <span class="toc-text">新标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webworkers"><span class="toc-number">1.3.</span> <span class="toc-text">webworkers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket"><span class="toc-number">1.4.</span> <span class="toc-text">websocket</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS"><span class="toc-number">2.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#flex"><span class="toc-number">2.1.</span> <span class="toc-text">flex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Grid"><span class="toc-number">2.2.</span> <span class="toc-text">Grid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">2.3.</span> <span class="toc-text">清除浮动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Margin%E5%A1%8C%E9%99%B7"><span class="toc-number">2.4.</span> <span class="toc-text">Margin塌陷</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Javascript"><span class="toc-number">3.</span> <span class="toc-text">Javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.1.</span> <span class="toc-text">深浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">浏览器的缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-number">3.3.</span> <span class="toc-text">promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetch%E3%80%81axios%E3%80%81ajax"><span class="toc-number">3.4.</span> <span class="toc-text">fetch、axios、ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Fetch"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. Fetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Axios"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. Axios</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Ajax-jQuery"><span class="toc-number">3.4.3.</span> <span class="toc-text">3. Ajax (jQuery)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">3.5.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8F%89%E6%A0%91%E5%92%8C%E6%B8%B8%E7%A8%8B%E7%BC%96%E7%A0%81"><span class="toc-number">3.6.</span> <span class="toc-text">四叉树和游程编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%8F%89%E6%A0%91%EF%BC%88Quadtree%EF%BC%89%EF%BC%9A"><span class="toc-number">3.6.1.</span> <span class="toc-text">四叉树（Quadtree）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E7%A8%8B%E7%BC%96%E7%A0%81%EF%BC%88Run-Length-Encoding%EF%BC%8CRLE%EF%BC%89%EF%BC%9A"><span class="toc-number">3.6.2.</span> <span class="toc-text">游程编码（Run-Length Encoding，RLE）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-K"><span class="toc-number">3.7.</span> <span class="toc-text">二叉树-K</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.7.1.</span> <span class="toc-text">递归实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BD%BF%E7%94%A8%E6%A0%88%EF%BC%89"><span class="toc-number">3.7.2.</span> <span class="toc-text">迭代实现（使用栈）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-number">4.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">4.1.</span> <span class="toc-text">响应式数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch%E5%92%8Ccomputed"><span class="toc-number">4.3.</span> <span class="toc-text">watch和computed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nexttick"><span class="toc-number">4.4.</span> <span class="toc-text">Nexttick</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">4.4.1.</span> <span class="toc-text">用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ref%E5%92%8Creactive%E5%8C%BA%E5%88%AB"><span class="toc-number">4.5.</span> <span class="toc-text">ref和reactive区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ref"><span class="toc-number">4.5.1.</span> <span class="toc-text">使用 ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-reactive"><span class="toc-number">4.5.2.</span> <span class="toc-text">使用 reactive</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React"><span class="toc-number">5.</span> <span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Fiber%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E8%A7%A3%E5%86%B3%E4%BA%86React%E4%B9%8B%E5%89%8D%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">Fiber架构是什么，以及它解决了React之前版本中的哪些问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">5.2.</span> <span class="toc-text">组件通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hooks"><span class="toc-number">5.3.</span> <span class="toc-text">hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8E%9F%E7%94%9FDOM%E8%8A%82%E7%82%B9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">获取原生DOM节点的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Webpack"><span class="toc-number">6.</span> <span class="toc-text">Webpack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%98%BB%E5%A1%9E"><span class="toc-number">7.1.</span> <span class="toc-text">页面阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%9A%84JavaScript"><span class="toc-number">7.1.1.</span> <span class="toc-text">1. 同步加载的JavaScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%9E%E5%BC%82%E6%AD%A5%E7%9A%84CSS%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.2.</span> <span class="toc-text">2. 非异步的CSS文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%A7%E9%87%8FDOM%E5%85%83%E7%B4%A0"><span class="toc-number">7.1.3.</span> <span class="toc-text">3. 大量DOM元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F"><span class="toc-number">7.1.4.</span> <span class="toc-text">4. 重定向和网络延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%A7%E5%9E%8B%E8%B5%84%E6%BA%90%E5%92%8C%E6%9C%AA%E4%BC%98%E5%8C%96%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">7.1.5.</span> <span class="toc-text">5. 大型资源和未优化的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-JavaScript%E6%89%A7%E8%A1%8C%E5%8D%A0%E7%94%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.1.6.</span> <span class="toc-text">6. JavaScript执行占用主线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.7.</span> <span class="toc-text">优化策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-X"><span class="toc-number">7.2.</span> <span class="toc-text">文件上传-X</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E7%95%99%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">7.3.</span> <span class="toc-text">如何保留上传文件的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text">1. 使用浏览器的本地存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B0%86%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E5%90%8E%E4%B8%8A%E4%BC%A0"><span class="toc-number">7.3.2.</span> <span class="toc-text">2. 将文件分片后上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8Session%E6%88%96Cookies"><span class="toc-number">7.3.3.</span> <span class="toc-text">3. 使用Session或Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.4.</span> <span class="toc-text">4. 服务器端的文件恢复机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8JavaScript%E5%BA%93%E6%88%96%E6%A1%86%E6%9E%B6"><span class="toc-number">7.3.5.</span> <span class="toc-text">5. 使用JavaScript库或框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%9B%E5%BB%BA%E6%8C%81%E4%B9%85%E7%9A%84%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81"><span class="toc-number">7.3.6.</span> <span class="toc-text">6. 创建持久的前端状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.3.7.</span> <span class="toc-text">实现示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-weback-%E4%B8%8E-vite"><span class="toc-number">7.4.</span> <span class="toc-text">说说 weback 与 vite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack%EF%BC%9A"><span class="toc-number">7.4.1.</span> <span class="toc-text">Webpack：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vite%EF%BC%9A"><span class="toc-number">7.4.2.</span> <span class="toc-text">Vite：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">8.</span> <span class="toc-text">计算机网络</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/%E9%93%B6%E8%A1%8C/" title="银行"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="银行"/></a><div class="content"><a class="title" href="/2024/10/22/%E9%93%B6%E8%A1%8C/" title="银行">银行</a><time datetime="2024-10-22T02:15:44.000Z" title="发表于 2024-10-22 10:15:44">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/16/nodejs%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="nodejs面试笔记"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nodejs面试笔记"/></a><div class="content"><a class="title" href="/2024/10/16/nodejs%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="nodejs面试笔记">nodejs面试笔记</a><time datetime="2024-10-16T02:23:20.000Z" title="发表于 2024-10-16 10:23:20">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/16/%E5%B0%8F%E7%B1%B3/" title="小米"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小米"/></a><div class="content"><a class="title" href="/2024/10/16/%E5%B0%8F%E7%B1%B3/" title="小米">小米</a><time datetime="2024-10-16T02:12:12.000Z" title="发表于 2024-10-16 10:12:12">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/" title="华为前端面试合集"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="华为前端面试合集"/></a><div class="content"><a class="title" href="/2024/10/15/%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/" title="华为前端面试合集">华为前端面试合集</a><time datetime="2024-10-15T08:35:34.000Z" title="发表于 2024-10-15 16:35:34">2024-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/14/%E6%95%B0%E5%AD%97/" title="数字"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数字"/></a><div class="content"><a class="title" href="/2024/10/14/%E6%95%B0%E5%AD%97/" title="数字">数字</a><time datetime="2024-10-14T08:44:56.000Z" title="发表于 2024-10-14 16:44:56">2024-10-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 流泪猫猫头</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>