<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>leetcode 100 | Lavender's blog</title><meta name="author" content="流泪猫猫头"><meta name="copyright" content="流泪猫猫头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="链表反转链表单链表的头节点 head ，请反转链表，返回反转后的链表。 12345678910111213var reverseList &#x3D; function (head) &amp;#123;    if (!head) return null; &#x2F;&#x2F; 返回 null 而不是空数组    let cur &#x3D; head;    let pre &#x3D; null;    while (cur) &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode 100">
<meta property="og:url" content="http://lavender321.github.com/2024/05/20/leetcode-100/index.html">
<meta property="og:site_name" content="Lavender&#39;s blog">
<meta property="og:description" content="链表反转链表单链表的头节点 head ，请反转链表，返回反转后的链表。 12345678910111213var reverseList &#x3D; function (head) &amp;#123;    if (!head) return null; &#x2F;&#x2F; 返回 null 而不是空数组    let cur &#x3D; head;    let pre &#x3D; null;    while (cur) &amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png">
<meta property="article:published_time" content="2024-05-20T15:50:20.000Z">
<meta property="article:modified_time" content="2024-10-27T14:35:45.494Z">
<meta property="article:author" content="流泪猫猫头">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="leetcode 100">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="力扣">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png"><link rel="shortcut icon" href="https://s2.loli.net/2022/10/08/k5M7H1NdmnZgtlY.png"><link rel="canonical" href="http://lavender321.github.com/2024/05/20/leetcode-100/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 流泪猫猫头","link":"链接: ","source":"来源: Lavender's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'leetcode 100',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-27 22:35:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Lavender's blog"><span class="site-name">Lavender's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">leetcode 100</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-20T15:50:20.000Z" title="发表于 2024-05-20 23:50:20">2024-05-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-27T14:35:45.494Z" title="更新于 2024-10-27 22:35:45">2024-10-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/leetcode-book/">leetcode book</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="leetcode 100"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>单链表的头节点 <code>head</code> ，请反转链表，返回反转后的链表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回 null 而不是空数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = cur.<span class="property">next</span>; <span class="comment">// 正确地将 next 设置为 cur.next</span></span><br><span class="line">        cur.<span class="property">next</span> = pre; <span class="comment">// 反转指针</span></span><br><span class="line">        pre = cur; <span class="comment">// 移动 pre 到当前节点</span></span><br><span class="line">        cur = next; <span class="comment">// 移动 cur 到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// pre 成为新链表的头节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表固定区间反转链表"><a href="#链表固定区间反转链表" class="headerlink" title="链表固定区间反转链表"></a>链表固定区间反转链表</h2><ol>
<li><strong>遍历到第 <code>m-1</code> 个节点</strong>：这个节点是反转开始节点的前一个节点。</li>
<li><strong>反转第 <code>m</code> 到 <code>n</code> 个节点</strong>：我们需要通过迭代反转这部分链表的节点。</li>
<li><strong>重新连接链表</strong>：将反转后的子链表正确连接到链表的前半部分和后半部分。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseBetween</span>(<span class="params">head, m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m === n) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);  <span class="comment">// 创建一个虚拟节点，便于处理头节点</span></span><br><span class="line">    dummy.<span class="property">next</span> = head;</span><br><span class="line">    <span class="keyword">let</span> prev = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 找到第 m-1 个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        prev = prev.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 开始反转第 m 到 n 的节点</span></span><br><span class="line">    <span class="keyword">let</span> curr = prev.<span class="property">next</span>;  <span class="comment">// 第 m 个节点</span></span><br><span class="line">    <span class="keyword">let</span> nextTemp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">        nextTemp = curr.<span class="property">next</span>;            <span class="comment">// 暂存当前节点的下一个节点</span></span><br><span class="line">        curr.<span class="property">next</span> = nextTemp.<span class="property">next</span>;       <span class="comment">// 当前节点的 next 指向下一个节点的 next</span></span><br><span class="line">        nextTemp.<span class="property">next</span> = prev.<span class="property">next</span>;       <span class="comment">// 将反转的节点插入到 prev 和 curr 之间</span></span><br><span class="line">        prev.<span class="property">next</span> = nextTemp;            <span class="comment">// 将 prev 的 next 指向插入的节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;  <span class="comment">// 返回新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>**创建虚拟节点 <code>dummy</code>**：<ul>
<li>虚拟节点 <code>dummy</code> 是为了方便处理链表头节点的情况，避免单独处理头节点逻辑。</li>
<li><code>dummy.next = head</code>，因此虚拟节点的 <code>next</code> 指向链表的头节点。</li>
</ul>
</li>
<li><strong>找到第 <code>m-1</code> 个节点</strong>：<ul>
<li>使用 <code>for</code> 循环遍历链表，直到找到第 <code>m-1</code> 个节点，并用 <code>prev</code> 指向它。<code>prev.next</code> 就是第 <code>m</code> 个节点，准备开始反转。</li>
</ul>
</li>
<li><strong>反转第 <code>m</code> 到第 <code>n</code> 个节点</strong>：<ul>
<li>使用 <code>for</code> 循环，依次反转这段区间的节点。核心逻辑是逐步将第 <code>m</code> 到第 <code>n</code> 个节点进行插入操作。</li>
<li><code>curr</code> 始终指向正在处理的节点，<code>nextTemp</code> 保存下一个节点。通过调整指针来实现反转。</li>
</ul>
</li>
<li><strong>重新连接</strong>：<ul>
<li>在反转过程中，我们逐步将反转后的节点插入到链表中，维护正确的链表顺序。</li>
</ul>
</li>
<li><strong>返回结果</strong>：<ul>
<li>最后返回 <code>dummy.next</code>，即新链表的头节点。</li>
</ul>
</li>
</ol>
<h3 id="时间复杂度和空间复杂度："><a href="#时间复杂度和空间复杂度：" class="headerlink" title="时间复杂度和空间复杂度："></a>时间复杂度和空间复杂度：</h3><ul>
<li><strong>时间复杂度</strong>：O(n)，我们需要遍历一次链表来找到位置 <code>m</code>，并在第 <code>m</code> 到第 <code>n</code> 个节点之间反转。</li>
<li><strong>空间复杂度</strong>：O(1)，因为我们只用了常数空间来进行操作。</li>
</ul>
<h2 id="判断链表有环"><a href="#判断链表有环" class="headerlink" title="判断链表有环"></a>判断链表有环</h2><p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasCycle</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast !== <span class="literal">null</span> &amp;&amp; fast.<span class="property">next</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;         <span class="comment">// 慢指针每次走一步</span></span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;    <span class="comment">// 快指针每次走两步</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果快慢指针相遇，说明有环</span></span><br><span class="line">        <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果快指针走到了 null，则说明没有环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果链表中存在环，<code>fast</code> 和 <code>slow</code> 最终会在环中某一点相遇。如果链表没有环，<code>fast</code> 会在到达链表末尾时变为 <code>null</code>。</p>
</li>
<li><p><strong>终止条件</strong>：</p>
<ul>
<li>如果 <code>fast</code> 或 <code>fast.next</code> 为 <code>null</code>，则链表中没有环，返回 <code>false</code>。</li>
<li>如果 <code>slow</code> 和 <code>fast</code> 相遇，则表明链表中存在环，返回 <code>true</code>。</li>
</ul>
</li>
</ol>
<h3 id="时间和空间复杂度："><a href="#时间和空间复杂度：" class="headerlink" title="时间和空间复杂度："></a>时间和空间复杂度：</h3><ul>
<li><strong>时间复杂度</strong>：O(n)，因为快慢指针最多遍历链表一次。</li>
<li><strong>空间复杂度</strong>：O(1)，只使用了常量级别的额外空间。</li>
</ul>
<h2 id="链表相加"><a href="#链表相加" class="headerlink" title="链表相加"></a>链表相加</h2><h3 id="反转链表-1"><a href="#反转链表-1" class="headerlink" title="反转链表"></a>反转链表</h3><ul>
<li><strong>反转链表</strong>：首先将两个链表反转，以便从最低位开始相加。</li>
<li><strong>相加过程</strong>：保持你目前的逐位相加逻辑。</li>
<li><strong>再次反转结果链表</strong>：将相加后的结果链表反转回来，以保持数字的正确顺序。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转链表函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseList</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextTemp = curr.<span class="property">next</span>;</span><br><span class="line">        curr.<span class="property">next</span> = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addInList</span>(<span class="params">head1, head2</span>) &#123;</span><br><span class="line">    <span class="comment">// 反转两个链表，使其从最低位开始相加</span></span><br><span class="line">    <span class="keyword">let</span> revHead1 = <span class="title function_">reverseList</span>(head1);</span><br><span class="line">    <span class="keyword">let</span> revHead2 = <span class="title function_">reverseList</span>(head2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> p = dummyHead;</span><br><span class="line">    <span class="keyword">let</span> p1 = revHead1, p2 = revHead2;</span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐位相加</span></span><br><span class="line">    <span class="keyword">while</span> (p1 !== <span class="literal">null</span> || p2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = (p1 !== <span class="literal">null</span>) ? p1.<span class="property">val</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> y = (p2 !== <span class="literal">null</span>) ? p2.<span class="property">val</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> sum = x + y + carry;</span><br><span class="line">        carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sum / <span class="number">10</span>); <span class="comment">// 计算进位</span></span><br><span class="line">        p.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>); <span class="comment">// 新节点保存个位数字</span></span><br><span class="line"></span><br><span class="line">        p = p.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span> (p1 !== <span class="literal">null</span>) p1 = p1.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span> (p2 !== <span class="literal">null</span>) p2 = p2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最后还有进位，追加新节点</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        p.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果链表再反转回来，恢复为从高位到低位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverseList</span>(dummyHead.<span class="property">next</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ol>
<li><p><strong>反转链表</strong>：我们首先使用 <code>reverseList</code> 函数反转两个输入链表，使得最低位的数字在链表头部，便于逐位相加。</p>
</li>
<li><p><strong>相加过程</strong>：保持原有的加法逻辑，逐位相加两个链表节点值，同时处理进位。如果一个链表较长，未匹配的位数会和 0 相加。</p>
</li>
<li><p><strong>处理进位</strong>：每次相加时计算是否有进位，并将进位保留到下一轮相加。</p>
</li>
<li><p><strong>反转结果链表</strong>：相加结束后，再次反转结果链表，使得返回的链表恢复为从高位到低位的顺序。</p>
</li>
</ol>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>假设输入链表为：</p>
<ul>
<li><code>head1: 1 -&gt; 2 -&gt; 3</code>（表示 <code>123</code>）</li>
<li><code>head2: 4 -&gt; 5 -&gt; 6</code>（表示 <code>456</code>）</li>
</ul>
<ol>
<li><p>反转链表：</p>
<ul>
<li><code>head1</code> 反转为：<code>3 -&gt; 2 -&gt; 1</code></li>
<li><code>head2</code> 反转为：<code>6 -&gt; 5 -&gt; 4</code></li>
</ul>
</li>
<li><p>逐位相加：</p>
<ul>
<li><code>3 + 6 = 9</code></li>
<li><code>2 + 5 = 7</code></li>
<li><code>1 + 4 = 5</code></li>
</ul>
</li>
<li><p>结果链表为：<code>9 -&gt; 7 -&gt; 5</code></p>
</li>
<li><p>再次反转结果链表，得到最终结果：</p>
<ul>
<li><code>5 -&gt; 7 -&gt; 9</code>，表示 <code>579</code>。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是链表中较长的那个链表的长度。反转和相加的操作都是线性时间。</li>
<li><strong>空间复杂度</strong>：O(1)，除了结果链表外，算法只使用了常数级别的额外空间。</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>确实，反转链表虽然有效，但你希望寻找更简单的解法。可以使用栈的方式来解决这个问题。利用栈的“后进先出”特性，可以方便地从链表的尾部开始进行加法，而无需反转链表。</p>
<h3 id="使用栈的解法："><a href="#使用栈的解法：" class="headerlink" title="使用栈的解法："></a>使用栈的解法：</h3><p>我们可以将两个链表的所有节点值分别压入两个栈中。这样，栈顶就是链表的尾节点。然后，我们逐步弹出栈中的元素进行相加，同时处理进位，最后生成结果链表。</p>
<h3 id="解法步骤："><a href="#解法步骤：" class="headerlink" title="解法步骤："></a>解法步骤：</h3><ol>
<li>使用两个栈 <code>stack1</code> 和 <code>stack2</code>，将两个链表的所有节点值分别压入栈中。</li>
<li>逐步从栈中弹出节点值进行相加，同时处理进位。</li>
<li>最后将结果链表按正确的顺序连接。</li>
</ol>
<h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ListNode</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addInList</span>(<span class="params">head1, head2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表1的所有节点值压入栈中</span></span><br><span class="line">    <span class="keyword">while</span> (head1) &#123;</span><br><span class="line">        stack1.<span class="title function_">push</span>(head1.<span class="property">val</span>);</span><br><span class="line">        head1 = head1.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表2的所有节点值压入栈中</span></span><br><span class="line">    <span class="keyword">while</span> (head2) &#123;</span><br><span class="line">        stack2.<span class="title function_">push</span>(head2.<span class="property">val</span>);</span><br><span class="line">        head2 = head2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始逐位相加，直到两个栈都为空且没有进位</span></span><br><span class="line">    <span class="keyword">while</span> (stack1.<span class="property">length</span> &gt; <span class="number">0</span> || stack2.<span class="property">length</span> &gt; <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = stack1.<span class="property">length</span> &gt; <span class="number">0</span> ? stack1.<span class="title function_">pop</span>() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> y = stack2.<span class="property">length</span> &gt; <span class="number">0</span> ? stack2.<span class="title function_">pop</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> sum = x + y + carry;</span><br><span class="line">        carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sum / <span class="number">10</span>); <span class="comment">// 计算进位</span></span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>); <span class="comment">// 当前位的值</span></span><br><span class="line">        newNode.<span class="property">next</span> = dummyHead; <span class="comment">// 将新节点连接到前面</span></span><br><span class="line">        dummyHead = newNode; <span class="comment">// 更新头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">addInList</span>: addInList,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法思路："><a href="#解法思路：" class="headerlink" title="解法思路："></a>解法思路：</h3><ol>
<li><strong>利用栈</strong>：我们将两个链表的节点值依次压入两个栈中，这样可以从链表的尾部开始相加，而无需反转链表。</li>
<li><strong>逐位相加</strong>：通过逐步弹出栈中的元素，进行相加操作，同时处理进位。</li>
<li><strong>结果链表构建</strong>：每次生成新节点，将其插入到结果链表的前面，从而保持最终链表的顺序。</li>
</ol>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>无需反转链表，代码更直观、简洁。</li>
<li>保证从尾部开始相加的正确顺序。</li>
<li>时间复杂度为 O(n)，空间复杂度为 O(n)，其中 <code>n</code> 是较长的链表的长度。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>假设输入链表为：</p>
<ul>
<li><code>head1: 1 -&gt; 2 -&gt; 3</code>（表示 <code>123</code>）</li>
<li><code>head2: 4 -&gt; 5 -&gt; 6</code>（表示 <code>456</code>）</li>
</ul>
<ol>
<li><p>将链表节点值压入栈中：</p>
<ul>
<li><code>stack1: [1, 2, 3]</code></li>
<li><code>stack2: [4, 5, 6]</code></li>
</ul>
</li>
<li><p>逐位相加：</p>
<ul>
<li>3 + 6 &#x3D; 9</li>
<li>2 + 5 &#x3D; 7</li>
<li>1 + 4 &#x3D; 5</li>
</ul>
</li>
<li><p>生成结果链表：<code>5 -&gt; 7 -&gt; 9</code>，表示 <code>579</code>。</p>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这种方法避免了链表的反转，使用栈的方式使得加法过程变得简单明了。如果你希望简化实现，这个解法更加直接并且易于理解。</p>
<h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个升序链表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeTwoLists</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个虚拟头节点</span></span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> current = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历两个链表</span></span><br><span class="line">  <span class="keyword">while</span> (l1 !== <span class="literal">null</span> &amp;&amp; l2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.<span class="property">val</span> &lt; l2.<span class="property">val</span>) &#123;</span><br><span class="line">      current.<span class="property">next</span> = l1;</span><br><span class="line">      l1 = l1.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current.<span class="property">next</span> = l2;</span><br><span class="line">      l2 = l2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接剩余部分</span></span><br><span class="line">  <span class="keyword">if</span> (l1 !== <span class="literal">null</span>) &#123;</span><br><span class="line">    current.<span class="property">next</span> = l1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    current.<span class="property">next</span> = l2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回结果链表的头节点</span></span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并-k-个链表"><a href="#合并-k-个链表" class="headerlink" title="合并 k 个链表"></a>合并 k 个链表</h2><p>合并 <code>K</code> 个升序链表的问题可以通过不同的策略来解决。这里有几种常见的方法：</p>
<h3 id="方法-1-两两合并"><a href="#方法-1-两两合并" class="headerlink" title="方法 1: 两两合并"></a>方法 1: 两两合并</h3><ol>
<li><strong>逐对合并</strong>：每次合并两个链表，直到只剩一个链表。</li>
<li><strong>时间复杂度</strong>：O(K * N * logK)，其中 <code>N</code> 是每个链表的平均长度，<code>K</code> 是链表的数量。最坏情况下，合并每对链表需要 O(N) 时间，总共有 K-1 次合并操作。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeTwoLists</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 !== <span class="literal">null</span> &amp;&amp; l2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.<span class="property">val</span> &lt; l2.<span class="property">val</span>) &#123;</span><br><span class="line">            cur.<span class="property">next</span> = l1;</span><br><span class="line">            l1 = l1.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.<span class="property">next</span> = l2;</span><br><span class="line">            l2 = l2.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        cur.<span class="property">next</span> = l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur.<span class="property">next</span> = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergeKLists = <span class="keyword">function</span>(<span class="params">lists</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (lists.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> mergedLists = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lists.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; lists.<span class="property">length</span>) &#123;</span><br><span class="line">                mergedLists.<span class="title function_">push</span>(<span class="title function_">mergeTwoLists</span>(lists[i], lists[i + <span class="number">1</span>]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mergedLists.<span class="title function_">push</span>(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lists = mergedLists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归合并链表"><a href="#递归合并链表" class="headerlink" title="递归合并链表"></a>递归合并链表</h3><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><strong><code>mergeTwoLists</code> 函数</strong>：<ul>
<li>合并两个已排序的链表。</li>
<li>使用递归的方式比较两个链表的头节点，并将较小的节点连接到合并结果上。</li>
<li>递归处理两个链表的其余部分。</li>
</ul>
</li>
<li><strong><code>mergeKLists</code> 函数</strong>：<ul>
<li>使用分治法（Divide and Conquer）将链表数组分为两半，递归合并每一半的链表。</li>
<li>调用 <code>mergeTwoLists</code> 来合并两个部分，直到所有链表被合并为一个。</li>
</ul>
</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>这种方法相对简洁，没有使用额外的优先队列数据结构。</li>
<li>递归和分治法使代码简洁易懂。</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>时间复杂度为 O(Nlog⁡K)O(N \log K)O(NlogK)，其中 NNN 是所有链表节点的总数，KKK 是链表的数量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个已排序的链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeTwoLists</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l1.<span class="property">val</span> &lt; l2.<span class="property">val</span>) &#123;</span><br><span class="line">        l1.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(l1.<span class="property">next</span>, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(l1, l2.<span class="property">next</span>);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并多个已排序链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode[]</span>&#125; <span class="variable">lists</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeKLists = <span class="keyword">function</span>(<span class="params">lists</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归合并链表</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mergeRange</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left === right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> l1 = <span class="title function_">mergeRange</span>(left, mid);</span><br><span class="line">        <span class="keyword">const</span> l2 = <span class="title function_">mergeRange</span>(mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">mergeTwoLists</span>(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mergeRange</span>(<span class="number">0</span>, lists.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="方法-2-使用最小堆（优先队列）"><a href="#方法-2-使用最小堆（优先队列）" class="headerlink" title="方法 2: 使用最小堆（优先队列）"></a>方法 2: 使用最小堆（优先队列）</h3><ol>
<li><strong>最小堆</strong>：将每个链表的头节点插入最小堆，然后每次从堆中取出最小节点，并将该节点的下一个节点插入堆中。</li>
<li><strong>时间复杂度</strong>：O(N * logK)，其中 <code>N</code> 是所有链表节点的总数，<code>K</code> 是链表的数量。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">push</span>(node);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">heapifyUp</span>(<span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> min = <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">heapifyUp</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> parentIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">heap</span>[index].<span class="property">val</span> &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[parentIndex].<span class="property">val</span>) &#123;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">heap</span>[index], <span class="variable language_">this</span>.<span class="property">heap</span>[parentIndex]] = [<span class="variable language_">this</span>.<span class="property">heap</span>[parentIndex], <span class="variable language_">this</span>.<span class="property">heap</span>[index]];</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">heapifyUp</span>(parentIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">heapifyDown</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> leftIndex = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> rightIndex = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">let</span> smallest = index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftIndex &lt; <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">heap</span>[leftIndex].<span class="property">val</span> &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[smallest].<span class="property">val</span>) &#123;</span><br><span class="line">            smallest = leftIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">heap</span>[rightIndex].<span class="property">val</span> &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[smallest].<span class="property">val</span>) &#123;</span><br><span class="line">            smallest = rightIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (smallest !== index) &#123;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">heap</span>[index], <span class="variable language_">this</span>.<span class="property">heap</span>[smallest]] = [<span class="variable language_">this</span>.<span class="property">heap</span>[smallest], <span class="variable language_">this</span>.<span class="property">heap</span>[index]];</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(smallest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergeKLists = <span class="keyword">function</span>(<span class="params">lists</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> cur = dummy;</span><br><span class="line">    <span class="keyword">let</span> minHeap = <span class="keyword">new</span> <span class="title class_">MinHeap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> list <span class="keyword">of</span> lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list) &#123;</span><br><span class="line">            minHeap.<span class="title function_">push</span>(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">let</span> minNode = minHeap.<span class="title function_">pop</span>();</span><br><span class="line">        cur.<span class="property">next</span> = minNode;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span> (minNode.<span class="property">next</span>) &#123;</span><br><span class="line">            minHeap.<span class="title function_">push</span>(minNode.<span class="property">next</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法-3-分治法"><a href="#方法-3-分治法" class="headerlink" title="方法 3: 分治法"></a>方法 3: 分治法</h3><ol>
<li><strong>递归分治</strong>：将链表数组分为两半，递归合并每半部分，最后合并这两半。</li>
<li><strong>时间复杂度</strong>：O(N * logK)，其中 <code>N</code> 是所有链表节点的总数，<code>K</code> 是链表的数量。与最小堆相似，分治法也具有 O(N * logK) 的复杂度，但实现上可能稍复杂。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeKLists = <span class="keyword">function</span>(<span class="params">lists</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">left, right</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.<span class="property">val</span> &lt; right.<span class="property">val</span>) &#123;</span><br><span class="line">                cur.<span class="property">next</span> = left;</span><br><span class="line">                left = left.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.<span class="property">next</span> = right;</span><br><span class="line">                right = right.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.<span class="property">next</span> = left || right;</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">mergeLists</span> = (<span class="params">lists, left, right</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (left === right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> l1 = <span class="title function_">mergeLists</span>(lists, left, mid);</span><br><span class="line">        <span class="keyword">const</span> l2 = <span class="title function_">mergeLists</span>(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">merge</span>(l1, l2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mergeLists</span>(lists, <span class="number">0</span>, lists.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>选择哪种方法取决于具体的应用场景和性能需求。两两合并实现简单，但效率可能较低；最小堆适用于需要高效合并的场景；分治法则在处理较大的链表集合时表现良好。</p>
<p>对于合并 <code>K</code> 个升序链表，最推荐的方法是使用<strong>最小堆（优先队列）</strong>。原因如下：</p>
<h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ol>
<li><strong>时间复杂度较低</strong>：最小堆的时间复杂度是 O(N * logK)，其中 <code>N</code> 是所有链表节点的总数，<code>K</code> 是链表的数量。相比于两两合并的方法，最小堆在处理大规模数据时表现更优。</li>
<li><strong>代码结构简洁</strong>：最小堆方法的代码通常较为简洁，易于理解和实现。尤其是处理链表节点时，通过最小堆自动保证了节点的升序。</li>
<li><strong>适用于大规模数据</strong>：最小堆在处理大量链表时能够更有效地管理内存和计算复杂度，相较于递归方法和两两合并方法更具优势。</li>
</ol>
<h2 id="相交链表–两个链表相交的节点"><a href="#相交链表–两个链表相交的节点" class="headerlink" title="相交链表–两个链表相交的节点"></a>相交链表–两个链表相交的节点</h2><p>两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<h3 id="解题思想：双指针"><a href="#解题思想：双指针" class="headerlink" title="解题思想：双指针"></a>解题思想：双指针</h3><p>初始化两个指针 <code>p1</code> 和 <code>p2</code>，分别指向链表 A 和链表 B 的头节点。</p>
<p>遍历链表，当指针 <code>p1</code> 到达链表 A 的末端时，将其指向链表 B 的头节点；当指针 <code>p2</code> 到达链表 B 的末端时，将其指向链表 A 的头节点。</p>
<p>当两个指针相遇时，返回相遇的节点；如果两个指针都为 <code>null</code>，则返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p1 = headA;</span><br><span class="line">    <span class="keyword">let</span> p2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 !== p2) &#123;</span><br><span class="line">        p1 = p1 ? p1.<span class="property">next</span> : headB;</span><br><span class="line">        p2 = p2 ? p2.<span class="property">next</span> : headA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1; <span class="comment">// 或者 return p2，因为 p1 和 p2 相等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h2><p>链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<ol>
<li><strong>分组反转</strong>：<ul>
<li>通过遍历链表，将链表分成若干长度为 <code>k</code> 的小段。</li>
<li>对每一小段进行反转操作。</li>
<li>反转后的小段重新链接到整体链表上。</li>
</ul>
</li>
<li><strong>辅助哑节点</strong>：<ul>
<li>引入一个哑节点（dummy node），它的 <code>next</code> 指向链表的头节点。这使得在处理头节点的反转时可以避免特殊处理，简化了代码的逻辑。</li>
</ul>
</li>
<li><strong>双指针技巧</strong>：<ul>
<li>使用两个指针 <code>pre</code> 和 <code>end</code> 来标记需要反转的小段的起始和结束位置。</li>
<li><code>pre</code> 用于标记当前小段的前一个节点。</li>
<li><code>end</code> 用于遍历到当前小段的结束节点。</li>
</ul>
</li>
<li><strong>反转操作</strong>：<ul>
<li>通过辅助函数 <code>reverse</code> 实现对从节点 <code>a</code> 到节点 <code>b</code> 之间的部分链表的反转。</li>
<li>反转后，将这部分链表重新连接到原链表上。</li>
</ul>
</li>
<li><strong>链表遍历和反转</strong>：<ul>
<li>遍历链表，每次找到 <code>k</code> 个节点，进行反转操作。</li>
<li>如果剩余节点不足 <code>k</code> 个，则保持其原有顺序。</li>
</ul>
</li>
</ol>
<p>下面是这个思路的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseKGroup = <span class="keyword">function</span>(<span class="params">head, k</span>) &#123;</span><br><span class="line">    <span class="comment">// 辅助函数，用来反转从节点 a 到节点 b 之间的链表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reverse</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> cur = a;</span><br><span class="line">        <span class="keyword">while</span> (cur! == b) &#123;</span><br><span class="line">            <span class="keyword">const</span> next = cur.<span class="property">next</span>;</span><br><span class="line">            cur.<span class="property">next</span> = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表为空或者 k 为 1，不需要进行任何操作，直接返回原链表</span></span><br><span class="line">    <span class="keyword">if</span> (!head || k === <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个哑节点(dummy)，指向链表头节点，方便操作</span></span><br><span class="line">    <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy.<span class="property">next</span> = head;</span><br><span class="line">    <span class="keyword">let</span> pre = dummy, end = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当链表还剩下至少 k 个节点时进行处理</span></span><br><span class="line">    <span class="keyword">while</span> (end !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 end 指针向前移动 k 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end !== <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            end = end.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 end 为空，说明剩下的节点不足 k 个，不需要翻转，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (end === <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录需要翻转的子链表的开始和结束</span></span><br><span class="line">        <span class="keyword">const</span> start = pre.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">const</span> next = end.<span class="property">next</span>;</span><br><span class="line">        <span class="comment">// 断开子链表与后续链表的连接</span></span><br><span class="line">        end.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 翻转子链表</span></span><br><span class="line">        pre.<span class="property">next</span> = <span class="title function_">reverse</span>(start, end.<span class="property">next</span>);</span><br><span class="line">        <span class="comment">// 将翻转后的子链表重新连接到原链表上</span></span><br><span class="line">        start.<span class="property">next</span> = next;</span><br><span class="line">        <span class="comment">// 将 pre 指针移动到翻转后的子链表的尾部，为下一轮翻转做准备</span></span><br><span class="line">        pre = start;</span><br><span class="line">        <span class="comment">// 将 end 指针重新指向 pre</span></span><br><span class="line">        end = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度是 O(n)，其中 n 是链表的长度。因为需要遍历每个节点一次。</p>
<ol>
<li><strong>分组</strong>：<ul>
<li>使用 <code>for</code> 循环将 <code>end</code> 指针向前移动 <code>k</code> 次，找到每个需要反转的小段。如果 <code>end</code> 到达链表末尾且不足 <code>k</code> 个节点，则跳出循环，不再进行反转。</li>
</ul>
</li>
<li><strong>反转</strong>：<ul>
<li>使用辅助函数 <code>reverse</code> 反转找到的小段链表。</li>
<li>断开当前小段与链表的连接，反转后重新连接到主链表上。</li>
</ul>
</li>
<li><strong>调整指针</strong>：<ul>
<li>将 <code>pre</code> 和 <code>end</code> 指针调整到新的位置，准备处理下一个小段。</li>
</ul>
</li>
</ol>
<p>这种方法通过局部反转来实现整体链表的反转，确保了每个小段的反转操作独立且高效，并且代码简洁易读。</p>
<h2 id="链表中倒数最后k个结点"><a href="#链表中倒数最后k个结点" class="headerlink" title="链表中倒数最后k个结点"></a>链表中倒数最后k个结点</h2><p>输入一个长度为 n 的链表，返回该链表中倒数第k个节点。如果该链表长度小于k，请返回一个长度为 0 的链表。</p>
<ol>
<li>使用两个指针 <code>fast</code> 和 <code>slow</code>，两者都从链表的头节点开始。</li>
<li>先让 <code>fast</code> 指针向前移动 <code>k</code> 步。</li>
<li>然后同时移动 <code>fast</code> 和 <code>slow</code>，直到 <code>fast</code> 到达链表的末尾。</li>
<li>当 <code>fast</code> 到达末尾时，<code>slow</code> 指针所指向的节点就是倒数第K个节点。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FindKthToTail</span>(<span class="params">pHead, k</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果链表为空或者k不合法，返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!pHead || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> fast = pHead;</span><br><span class="line">    <span class="keyword">let</span> slow = pHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先让fast指针移动k步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果k大于链表长度，直接返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时移动fast和slow，直到fast到达链表末尾</span></span><br><span class="line">    <span class="keyword">while</span> (fast !== <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slow此时指向的是倒数第K个节点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先检查链表头节点是否为空，如果是的话，直接返回 <code>null</code>。</li>
<li>然后我们让 <code>fast</code> 指针向前移动 <code>k</code> 步。如果在移动过程中 <code>fast</code> 变成了 <code>null</code>，说明 <code>k</code> 大于链表长度，直接返回 <code>null</code>。</li>
<li>接下来同时移动 <code>fast</code> 和 <code>slow</code>，直到 <code>fast</code> 到达链表的末尾。此时，<code>slow</code> 就指向了倒数第K个节点。</li>
<li>最后返回 <code>slow</code> 指针指向的节点。</li>
</ol>
<p>这个算法的时间复杂度是 O(n)，空间复杂度是 O(1)，其中 <code>n</code> 是链表的长度。</p>
<h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span> (<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个哑节点，其next指向head</span></span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy.<span class="property">next</span> = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化双指针</span></span><br><span class="line">    <span class="keyword">let</span> first = dummy;</span><br><span class="line">    <span class="keyword">let</span> second = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让first指针先前进n+1步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        first = first.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让first和second同时前进，直到first到达链表末尾</span></span><br><span class="line">    <span class="keyword">while</span> (first !== <span class="literal">null</span>) &#123;</span><br><span class="line">        first = first.<span class="property">next</span>;</span><br><span class="line">        second = second.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时second的next就是要删除的节点，调整指针以删除该节点</span></span><br><span class="line">    second.<span class="property">next</span> = second.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回链表头部</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针法："><a href="#双指针法：" class="headerlink" title="双指针法："></a>双指针法：</h3><ul>
<li>时间复杂度：<code>O(L)</code>，其中 <code>L</code> 是链表的长度。</li>
<li>空间复杂度：<code>O(1)</code>。</li>
<li>只需遍历一次链表。</li>
</ul>
<h2 id="两两交换链表的节点"><a href="#两两交换链表的节点" class="headerlink" title="两两交换链表的节点"></a>两两交换链表的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<h3 id="解法1：迭代"><a href="#解法1：迭代" class="headerlink" title="解法1：迭代"></a>解法1：迭代</h3><p>使用迭代实现，通过迭代地遍历链表，并在每次迭代中交换当前节点和下一个节点的位置来达到相邻节点交换的目的。具体步骤如下：</p>
<ol>
<li>首先，检查链表是否为空或者只有一个节点，如果是，则直接返回原链表。</li>
<li>创建一个哨兵节点 <code>dummy</code>，将它的 <code>next</code> 指向头节点 <code>head</code>。这样做是为了简化处理头节点的情况。</li>
<li>使用一个指针 <code>current</code> 指向哨兵节点，初始化时也指向头节点。</li>
<li>在循环中，每次处理两个相邻节点：<ul>
<li>将 <code>first</code> 指向当前节点的下一个节点。</li>
<li>将 <code>second</code> 指向当前节点的下两个节点（即 <code>first</code> 的下一个节点）。</li>
<li>交换 <code>first</code> 和 <code>second</code> 节点的位置。</li>
<li>更新指针 <code>current</code>，使其指向交换后的第一个节点，即 <code>first</code>。</li>
</ul>
</li>
<li>当链表中剩余的节点不足两个时，停止循环。</li>
<li>返回哨兵节点的 <code>next</code>，即新的头节点。</li>
</ol>
<p>这个方法的关键点在于使用迭代遍历链表，并在每次迭代中交换相邻的两个节点的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head; <span class="comment">// 如果链表为空或只有一个节点，则无需交换，直接返回原链表。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 创建一个哨兵节点 d，用于简化头节点的处理。</span></span><br><span class="line">    d.<span class="property">next</span> = head; <span class="comment">// 将哨兵节点的 next 指向原链表的头节点。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cur = d; <span class="comment">// 初始化 cur 指针指向哨兵节点。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur.<span class="property">next</span> &amp;&amp; cur.<span class="property">next</span>.<span class="property">next</span>) &#123; <span class="comment">// 当 cur 后至少有两个节点时，继续交换操作。</span></span><br><span class="line">        <span class="keyword">let</span> first = cur.<span class="property">next</span>; <span class="comment">// first 指向待交换的第一个节点。</span></span><br><span class="line">        <span class="keyword">let</span> second = cur.<span class="property">next</span>.<span class="property">next</span>; <span class="comment">// second 指向待交换的第二个节点。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行节点交换</span></span><br><span class="line">        first.<span class="property">next</span> = second.<span class="property">next</span>; <span class="comment">// 将 first 的 next 指向 second 的 next，断开 first 与 second 之间的连接。</span></span><br><span class="line">        cur.<span class="property">next</span> = second; <span class="comment">// 将 cur 的 next 指向 second，即将 second 放到 first 的前面。</span></span><br><span class="line">        cur.<span class="property">next</span>.<span class="property">next</span> = first; <span class="comment">// 将 second 的 next 指向 first，完成交换。</span></span><br><span class="line">        </span><br><span class="line">        cur = cur.<span class="property">next</span>.<span class="property">next</span>; <span class="comment">// 将 cur 指针向前移动两个节点，准备下一次交换。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d.<span class="property">next</span>; <span class="comment">// 返回新的头节点，即哨兵节点的 next。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法二–递归"><a href="#解法二–递归" class="headerlink" title="解法二–递归"></a>解法二–递归</h3><p>一种更简单的递归解法可以用于交换链表中的每两个相邻节点。递归方法直接对每对节点进行处理，而不需要显式地使用哨兵节点。下面是递归实现的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果链表为空或者只有一个节点，则不需要交换，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存第二个节点</span></span><br><span class="line">    <span class="keyword">let</span> second = head.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地交换后续节点</span></span><br><span class="line">    head.<span class="property">next</span> = <span class="title function_">swapPairs</span>(second.<span class="property">next</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第二个节点的 next 指向第一个节点</span></span><br><span class="line">    second.<span class="property">next</span> = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回第二个节点作为新的头节点</span></span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li>
</ul>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<p>这道题的解题思想是使用<strong>两次遍历原链表</strong>来创建新链表。在第一次遍历中，我们创建了新节点，并使用 Map 数据结构将原节点和新节点进行了映射。在第二次遍历中，我们设置了新节点的 <code>next</code> 和 <code>random</code> 指针，根据原节点的指针找到对应的新节点，并将其指针设置到新节点上。最后，我们返回新链表的头节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copyRandomList = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果原链表为空，则返回空</span></span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个 Map 数据结构，用于存储原节点和拷贝节点的映射关系</span></span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次遍历，创建新节点并建立映射关系</span></span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="comment">// 将原节点和对应的新节点存入 Map 中</span></span><br><span class="line">        map.<span class="title function_">set</span>(cur, <span class="keyword">new</span> <span class="title class_">ListNode</span>(cur.<span class="property">val</span>));</span><br><span class="line">        <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二次遍历，设置新节点的 next 和 random 指针</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="comment">// 设置新节点的 next 指针，如果原节点的下一个节点不为空，则将新节点的 next 指针指向对应的新节点，否则为 null</span></span><br><span class="line">        map.<span class="title function_">get</span>(cur).<span class="property">next</span> = map.<span class="title function_">get</span>(cur.<span class="property">next</span>) || <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 设置新节点的 random 指针，如果原节点的随机指针不为空，则将新节点的 random 指针指向对应的新节点，否则为 null</span></span><br><span class="line">        map.<span class="title function_">get</span>(cur).<span class="property">random</span> = map.<span class="title function_">get</span>(cur.<span class="property">random</span>) || <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)，因为我们需要遍历原链表两次，并且在每次遍历中，对每个节点进行常数时间的操作。</p>
<h2 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h2><p>请你设计并实现一个满足 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<blockquote>
<p>这个题目是实现一个LRU（Least Recently Used）缓存。LRU缓存是一种缓存策略，最近使用的数据会被保留，而最久未使用的数据会被淘汰。我们需要实现两个操作：<code>get(key)</code>和<code>put(key, value)</code>。</p>
</blockquote>
<ul>
<li><code>get(key)</code>：如果缓存中存在这个键，则返回对应的值，否则返回-1。</li>
<li><code>put(key, value)</code>：如果缓存中存在这个键，更新其值；如果不存在，插入这个键值对。如果缓存达到容量限制，移除最久未使用的键值对。</li>
</ul>
<p>为了实现这个功能，可以使用JavaScript的<code>Map</code>对象。<code>Map</code>对象按插入顺序保存键值对，因此可以用于实现LRU缓存。</p>
<p>以下是具体的实现步骤和代码：</p>
<ol>
<li><p><strong>创建LRUCache类：</strong></p>
<ul>
<li>初始化时，创建一个<code>Map</code>对象来存储缓存数据。</li>
<li>保存缓存的容量限制。</li>
</ul>
</li>
<li><p><strong>实现<code>get</code>方法：</strong></p>
<ul>
<li>如果键存在，将其移到<code>Map</code>的末尾以表示最近使用。</li>
<li>返回对应的值，如果键不存在返回-1。</li>
</ul>
</li>
<li><p><strong>实现<code>put</code>方法：</strong></p>
<ul>
<li>如果键存在，先删除旧的键值对。</li>
<li>将新的键值对插入<code>Map</code>的末尾。</li>
<li>如果缓存超过容量限制，移除<code>Map</code>的第一个键值对（最久未使用的）。</li>
</ul>
</li>
</ol>
<h3 id="code："><a href="#code：" class="headerlink" title="code："></a>code：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">capacity</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">LRUCache</span> = <span class="keyword">function</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 如果键不存在，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="comment">// 先删除旧的键值对，再重新插入，以表示最近使用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        <span class="comment">// 如果键存在，先删除旧的键值对</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">size</span> &gt;= <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果缓存已满，移除最久未使用的键值对</span></span><br><span class="line">        <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(oldestKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新的键值对</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new LRUCache(capacity)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"> * obj.put(key,value)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="逐行解释代码"><a href="#逐行解释代码" class="headerlink" title="逐行解释代码"></a>逐行解释代码</h3><ul>
<li><p><code>var LRUCache = function(capacity) &#123; ... &#125;;</code></p>
<ul>
<li>构造函数，用于初始化LRU缓存。</li>
<li><code>this.capacity = capacity;</code> 保存缓存容量。</li>
<li><code>this.cache = new Map();</code> 创建一个<code>Map</code>对象来存储缓存数据。</li>
</ul>
</li>
<li><p><code>LRUCache.prototype.get = function(key) &#123; ... &#125;;</code></p>
<ul>
<li><code>if (!this.cache.has(key)) &#123; return -1; &#125;</code>：如果<code>Map</code>中没有这个键，返回-1。</li>
<li><code>const value = this.cache.get(key);</code>：获取键对应的值。</li>
<li><code>this.cache.delete(key);</code>：删除旧的键值对。</li>
<li><code>this.cache.set(key, value);</code>：重新插入这个键值对，以表示最近使用。</li>
<li><code>return value;</code>：返回值。</li>
</ul>
</li>
<li><p><code>LRUCache.prototype.put = function(key, value) &#123; ... &#125;;</code></p>
<ul>
<li><code>if (this.cache.has(key)) &#123; this.cache.delete(key); &#125;</code>：如果键存在，删除旧的键值对。</li>
<li><code>else if (this.cache.size &gt;= this.capacity) &#123; ... &#125;</code>：如果缓存已满，删除最久未使用的键值对。</li>
<li><code>const oldestKey = this.cache.keys().next().value;</code>：获取<code>Map</code>中第一个键（最久未使用的键）。</li>
<li><code>this.cache.delete(oldestKey);</code>：删除最久未使用的键值对。</li>
<li><code>this.cache.set(key, value);</code>：插入新的键值对。</li>
</ul>
</li>
</ul>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li><code>get</code>操作：由于<code>Map</code>对象的<code>delete</code>和<code>set</code>操作的时间复杂度都是O(1)，所以<code>get</code>操作的时间复杂度为O(1)。</li>
<li><code>put</code>操作：同样由于<code>Map</code>对象的<code>delete</code>和<code>set</code>操作的时间复杂度都是O(1)，所以<code>put</code>操作的时间复杂度为O(1)。</li>
</ul>
<p>因此，LRU缓存的整体时间复杂度是O(1)。</p>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。必须在不复制数组的情况下原地对数组进行操作。</p>
<p>这个问题的目标是将数组中的所有零元素移动到数组的末尾，同时保持非零元素的相对顺序不变。下面是完整的解决方案：</p>
<ol>
<li>使用两个指针：<code>slow</code> 和 <code>fast</code>。<code>slow</code> 指针用来记录下一个非零元素要放置的位置，而 <code>fast</code> 指针用于遍历数组。</li>
<li>当 <code>fast</code> 指针找到非零元素时，将该元素与 <code>slow</code> 指针位置的元素交换，并将 <code>slow</code> 指针向前移动。</li>
<li>当所有非零元素移动完毕后，剩下的元素全部填充为 0。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有非零元素移动到数组前面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="property">length</span>; fast++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] !== <span class="number">0</span>) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将剩余位置填充为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = slow; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个 <code>for</code> 循环遍历数组中的每个元素，当遇到非零元素时，将该元素移动到 <code>slow</code> 指针所指的位置，并将 <code>slow</code> 指针前移。</li>
<li>当所有非零元素都处理完毕后，第二个 <code>for</code> 循环将数组剩下的部分填充为零。</li>
</ul>
<p>这个方案的时间复杂度是 <strong>O(n)<strong>，并且是</strong>原地修改数组</strong>的。</p>
<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p>
<blockquote>
<p> <strong>说明：</strong>你不能倾斜容器。</p>
</blockquote>
<p>你正在编写一个解决「盛最多水的容器」问题的函数。这个问题要求找到两个垂直线，使它们与 x 轴共同构成的容器能容纳最多的水。你已经设置了变量 <code>left</code> 和 <code>right</code> 来表示容器的左右边界，并且还开始了 <code>maxArea</code> 的初始化工作。</p>
<ol>
<li>使用两个指针，<code>left</code> 和 <code>right</code>，分别指向数组的左右两端。</li>
<li>计算当前 <code>left</code> 和 <code>right</code> 所能形成的容器面积，然后更新最大面积 <code>maxArea</code>。</li>
<li>移动指针：为了找到可能更大的容积，总是移动高度较小的那个指针。这样确保有可能获得更大的面积，因为移动较高的指针只会减少宽度，无法增大容积。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 计算当前面积</span></span><br><span class="line">        <span class="keyword">const</span> currentHeight = <span class="title class_">Math</span>.<span class="title function_">min</span>(height[left], height[right]);</span><br><span class="line">        <span class="keyword">const</span> currentWidth = right - left;</span><br><span class="line">        <span class="keyword">const</span> currentArea = currentHeight * currentWidth;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新最大面积</span></span><br><span class="line">        maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, currentArea);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移动较矮的指针</span></span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>**<code>left</code> 和 <code>right</code>**：这两个指针分别指向数组的两端，逐步向中间靠拢。</li>
<li>**<code>Math.min(height[left], height[right])</code>**：计算当前容器的高度，取决于较矮的那根柱子。</li>
<li>**<code>right - left</code>**：计算当前容器的宽度。</li>
<li>**<code>maxArea = Math.max(maxArea, currentArea)</code>**：不断更新最大容器的面积。</li>
<li><strong>移动指针</strong>：每次比较 <code>left</code> 和 <code>right</code> 指向的高度，移动较矮的那一个以期找到更大的容积。</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>：O(n)，因为我们只遍历数组一次。</li>
<li><strong>空间复杂度</strong>：O(1)，只使用了常数空间。</li>
</ul>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<h3 id="方法1–解题思路"><a href="#方法1–解题思路" class="headerlink" title="方法1–解题思路"></a>方法1–解题思路</h3><ol>
<li><p><strong>排序</strong>：</p>
<ul>
<li>首先将数组排序。这一步是为了方便使用双指针查找和跳过重复元素。</li>
</ul>
</li>
<li><p><strong>遍历数组</strong>：</p>
<ul>
<li>使用一个循环遍历数组，每次选择一个元素作为三元组的第一个元素。</li>
<li>跳过重复的元素，以避免结果中出现重复的三元组。</li>
</ul>
</li>
<li><p><strong>双指针查找</strong>：</p>
<ul>
<li>对于每个选定的第一个元素，使用两个指针分别指向该元素之后的两个位置。</li>
<li>移动两个指针以查找满足和为零的三元组。</li>
<li>如果和为零，将该三元组加入结果数组，并移动两个指针，同时跳过重复的元素。</li>
<li>如果和小于零，左指针右移以增加和。</li>
<li>如果和大于零，右指针左移以减小和。</li>
</ul>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);  <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;  <span class="comment">// 跳过重复元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], nums[left], nums[right]]);  <span class="comment">// 添加三元组到结果数组</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) left++;  <span class="comment">// 跳过重复元素</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) right--;  <span class="comment">// 跳过重复元素</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right--;  <span class="comment">// 移动右指针</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;  <span class="comment">// 移动左指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ol>
<li><strong>排序</strong>：确保数组有序以方便跳过重复元素和使用双指针。</li>
<li><strong>双指针查找</strong>：有效地缩小查找范围，避免重复结果。</li>
<li><strong>跳过重复元素</strong>：避免结果中出现重复的三元组。</li>
</ol>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li>排序的时间复杂度为 (O(nlog n))。</li>
<li>遍历数组和双指针查找的时间复杂度为 (O(n^2))。具体来说，对于每个元素，双指针需要遍历剩余的元素。</li>
<li>总的时间复杂度为 (O(nlog n) + O(n^2))，即 (O(n^2))。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>由于排序算法需要一些额外的空间，空间复杂度为 (O(n))。</li>
<li>结果数组的空间复杂度取决于结果的数量，但不超过 (O(n^2))。</li>
<li>总的空间复杂度为 (O(n))（不包括结果数组所需的空间）。</li>
</ul>
</li>
</ol>
<h3 id="方法2–解题思路"><a href="#方法2–解题思路" class="headerlink" title="方法2–解题思路"></a>方法2–解题思路</h3><p>将三数之和的问题转换为两数之和的问题确实可以使解决方案更为直观和简单。具体步骤如下：</p>
<ol>
<li><strong>排序数组</strong>：和之前的方法一样，首先对数组进行排序。</li>
<li><strong>遍历数组</strong>：将每个元素作为三元组中的第一个元素。</li>
<li><strong>两数之和</strong>：对于每个固定的第一个元素，将问题转化为寻找两个数之和为目标值的问题。</li>
<li><strong>使用哈希表查找</strong>：在寻找两数之和时，可以使用哈希表来记录已经遍历过的元素，从而高效地查找满足条件的两数。</li>
</ol>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><strong>排序</strong>：对数组进行排序。</li>
<li><strong>遍历</strong>：遍历数组，固定一个元素作为三元组的第一个元素。</li>
<li><strong>查找两数之和</strong>：使用哈希表查找剩余元素中是否存在满足条件的两个数。</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);  <span class="comment">// 排序数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 跳过重复元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> target = -nums[i];</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> complement = target - nums[j];</span><br><span class="line">            <span class="keyword">if</span> (seen.<span class="title function_">has</span>(complement)) &#123;</span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], complement, nums[j]]);</span><br><span class="line">                <span class="comment">// 跳过重复元素</span></span><br><span class="line">                <span class="keyword">while</span> (j + <span class="number">1</span> &lt; nums.<span class="property">length</span> &amp;&amp; nums[j] === nums[j + <span class="number">1</span>]) j++;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.<span class="title function_">add</span>(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li>排序的时间复杂度为 (O(n \log n))。</li>
<li>遍历数组并查找两数之和的时间复杂度为 (O(n^2))。</li>
<li>总的时间复杂度为 (O(n \log n) + O(n^2))，即 (O(n^2))。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>额外使用的哈希表空间复杂度为 (O(n))。</li>
<li>总的空间复杂度为 (O(n))。</li>
</ul>
</li>
</ol>
<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ol>
<li><strong>排序</strong>：确保数组有序以方便跳过重复元素。</li>
<li><strong>两数之和</strong>：将三数之和的问题转换为两数之和的问题。</li>
<li><strong>哈希表</strong>：使用哈希表高效地查找满足条件的两个数。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>将三数之和的问题转化为两数之和的问题，通过使用哈希表，可以简化查找过程，并且有效地跳过重复元素，从而避免结果中出现重复的三元组。</p>
<h2 id="删除链表的峰值"><a href="#删除链表的峰值" class="headerlink" title="删除链表的峰值"></a>删除链表的峰值</h2><p>峰值节点的定义通常是指某个节点的值大于它前后的节点的值。在单链表中，由于只能单向遍历，不能直接访问前一个节点。因此，需要在遍历时记录前一个节点以便比较。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deletePeaks</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head; <span class="comment">// 如果链表为空或者只有一个节点，则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 创建一个虚拟头节点</span></span><br><span class="line">    dummy.<span class="property">next</span> = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prev = dummy; <span class="comment">// 记录前一个节点，初始化为 dummy</span></span><br><span class="line">    <span class="keyword">let</span> cur = head; <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">let</span> next = cur.<span class="property">next</span>; <span class="comment">// 下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev !== dummy &amp;&amp; cur.<span class="property">val</span> &gt; prev.<span class="property">val</span> &amp;&amp; cur.<span class="property">val</span> &gt; next.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点是峰值，跳过当前节点</span></span><br><span class="line">            prev.<span class="property">next</span> = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点不是峰值，正常前进</span></span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前进到下一个节点</span></span><br><span class="line">        cur = next;</span><br><span class="line">        next = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>; <span class="comment">// 返回新的链表头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>**虚拟头节点 (<code>dummy</code>)**：</p>
<ul>
<li>使用虚拟头节点来处理删除头节点（如果头节点是峰值）的特殊情况。</li>
<li><code>dummy.next</code> 最终指向的是链表的新的头节点。</li>
</ul>
</li>
<li><p><strong>三指针遍历</strong>：</p>
<ul>
<li>使用 <code>prev</code>、<code>cur</code> 和 <code>next</code> 三个指针来遍历链表：<ul>
<li><code>prev</code>：指向当前节点的前一个节点。</li>
<li><code>cur</code>：指向当前节点。</li>
<li><code>next</code>：指向当前节点的下一个节点。</li>
</ul>
</li>
<li>通过比较 <code>cur</code> 和 <code>prev</code>、<code>next</code> 的值来判断 <code>cur</code> 是否为峰值节点。</li>
</ul>
</li>
<li><p><strong>删除峰值节点</strong>：</p>
<ul>
<li>如果当前节点 <code>cur</code> 的值大于前一个节点 <code>prev</code> 和下一个节点 <code>next</code> 的值，则当前节点 <code>cur</code> 被视为峰值节点，跳过它（即将 <code>prev.next = next</code>）。</li>
<li>如果当前节点不是峰值节点，则指针正常向前推进。</li>
</ul>
</li>
<li><p><strong>返回新的链表头</strong>：</p>
<ul>
<li>返回 <code>dummy.next</code>，即链表的新的头节点。</li>
</ul>
</li>
</ol>
<p>假设链表是 <code>[1 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 1]</code>，删除峰值节点（值为 3 和 4）后的链表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">head.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">head.<span class="property">next</span>.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">head.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">head.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">deletePeaks</span>(head)); <span class="comment">// 输出链表：[1 -&gt; 2 -&gt; 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是链表的节点数。我们只遍历链表一次。</li>
<li><strong>空间复杂度</strong>：O(1)，因为我们只使用了常数级别的额外空间。</li>
</ul>
<p>这个方法通过三指针的方式，删除链表中的所有峰值节点。如果你对峰值的定义或具体场景有不同的需求，欢迎进一步说明，我可以帮助调整解决方案。</p>
<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p>这个问题要求判断字符串 <code>s</code> 是否为字符串 <code>t</code> 的子序列。子序列的定义是：从 <code>t</code> 中删除一些字符（或不删除），而剩下的字符顺序和 <code>s</code> 相同。你需要保持字符的相对顺序不变。</p>
<p>我们可以通过使用<strong>双指针</strong>来解决这个问题。双指针法的基本思想是同时遍历字符串 <code>s</code> 和 <code>t</code>，检查 <code>t</code> 中的字符是否能依次匹配 <code>s</code> 的每一个字符。</p>
<ul>
<li>初始化两个指针 <code>i</code> 和 <code>j</code>，分别指向字符串 <code>s</code> 和 <code>t</code> 的开头。</li>
<li>每次比较 <code>s[i]</code> 和 <code>t[j]</code>：<ul>
<li>如果它们相等，移动指针 <code>i</code> 和 <code>j</code>，即匹配到了一个字符。</li>
<li>如果它们不相等，移动 <code>t</code> 的指针 <code>j</code>，继续寻找下一个可能的匹配字符。</li>
</ul>
</li>
<li>最后，如果 <code>s</code> 的所有字符都能在 <code>t</code> 中按顺序找到（即 <code>i == s.length</code>），那么 <code>s</code> 是 <code>t</code> 的子序列。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSubsequence = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="property">length</span> &amp;&amp; j &lt; t.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === t[j]) &#123;</span><br><span class="line">            i++;  <span class="comment">// s的字符匹配到了，移动s的指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        j++;  <span class="comment">// 无论是否匹配，t的指针都向前移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果s的所有字符都匹配到了，说明s是t的子序列</span></span><br><span class="line">    <span class="keyword">return</span> i === s.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于 <code>s = &quot;abc&quot;</code> 和 <code>t = &quot;ahbgdc&quot;</code>：</p>
<ul>
<li><code>s[0] = &#39;a&#39;</code> 与 <code>t[0] = &#39;a&#39;</code> 匹配，<code>i</code> 和 <code>j</code> 同时向前移动。</li>
<li><code>s[1] = &#39;b&#39;</code> 与 <code>t[2] = &#39;b&#39;</code> 匹配，<code>i</code> 和 <code>j</code> 同时向前移动。</li>
<li><code>s[2] = &#39;c&#39;</code> 与 <code>t[4] = &#39;c&#39;</code> 匹配，<code>i</code> 和 <code>j</code> 同时向前移动。</li>
<li>最终 <code>i</code> 到达了 <code>s.length</code>，所以 <code>s</code> 是 <code>t</code> 的子序列。</li>
</ul>
</li>
<li><p>对于 <code>s = &quot;axc&quot;</code> 和 <code>t = &quot;ahbgdc&quot;</code>：</p>
<ul>
<li><code>s[0] = &#39;a&#39;</code> 与 <code>t[0] = &#39;a&#39;</code> 匹配，<code>i</code> 和 <code>j</code> 同时向前移动。</li>
<li><code>s[1] = &#39;x&#39;</code> 无法匹配 <code>t</code> 中的任何字符，遍历完 <code>t</code> 后 <code>i != s.length</code>，所以 <code>s</code> 不是 <code>t</code> 的子序列。</li>
</ul>
</li>
</ul>
<h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><ul>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是字符串 <code>t</code> 的长度。因为我们最多只会遍历字符串 <code>t</code> 一次。</li>
<li><strong>空间复杂度</strong>：O(1)，只需要常数的额外空间来存储指针。</li>
</ul>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在二分查找的过程中，<code>left</code> 最终的位置实际上就是目标值应插入的位置。让我们详细解释一下为什么会这样：</p>
<h3 id="解释为什么返回-left"><a href="#解释为什么返回-left" class="headerlink" title="解释为什么返回 left"></a>解释为什么返回 <code>left</code></h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>left</code> 指针初始化为数组的开始，即 <code>0</code>。</li>
<li><code>right</code> 指针初始化为数组的末尾，即 <code>nums.length - 1</code>。</li>
</ul>
</li>
<li><p><strong>二分查找过程</strong>：</p>
<ul>
<li>每次循环中，我们计算中间索引 <code>mid</code>。</li>
<li>如果 <code>nums[mid] == target</code>，直接返回 <code>mid</code>。</li>
<li>如果 <code>nums[mid] &lt; target</code>，说明目标值在 <code>mid</code> 右边，所以我们将 <code>left</code> 更新为 <code>mid + 1</code>。</li>
<li>如果 <code>nums[mid] &gt; target</code>，说明目标值在 <code>mid</code> 左边，所以我们将 <code>right</code> 更新为 <code>mid - 1</code>。</li>
</ul>
</li>
<li><p><strong>终止条件</strong>：</p>
<ul>
<li>循环在 <code>left</code> 超过 <code>right</code> 时终止。</li>
<li>终止时，<code>left</code> 指向的就是目标值应该插入的位置。这是因为：<ul>
<li>在 <code>left</code> 更新为 <code>mid + 1</code> 时，意味着 <code>left</code> 指针已经移动到所有小于目标值的元素之后。</li>
<li>在 <code>right</code> 更新为 <code>mid - 1</code> 时，意味着 <code>right</code> 指针已经移动到所有大于目标值的元素之前。</li>
<li>最终，<code>left</code> 指向的就是目标值应该插入的位置，不会影响数组的排序。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>假设数组为 <code>[1, 3, 5, 6]</code>，目标值为 <code>2</code>。</p>
<ul>
<li>初始化：<code>left = 0</code>, <code>right = 3</code></li>
<li>第一次循环：<ul>
<li><code>mid = 1</code>（索引）</li>
<li><code>nums[mid] = 3</code></li>
<li>因为 <code>3 &gt; 2</code>，所以更新 <code>right = mid - 1 = 0</code></li>
</ul>
</li>
<li>第二次循环：<ul>
<li><code>mid = 0</code></li>
<li><code>nums[mid] = 1</code></li>
<li>因为 <code>1 &lt; 2</code>，所以更新 <code>left = mid + 1 = 1</code></li>
</ul>
</li>
<li>循环终止条件：<ul>
<li><code>left = 1</code>, <code>right = 0</code></li>
<li>退出循环，返回 <code>left = 1</code></li>
</ul>
</li>
</ul>
<p>结果是目标值 <code>2</code> 应该插入到索引 <code>1</code> 位置，保证数组有序。</p>
<p>这个实现确保了在 <code>left</code> 超过 <code>right</code> 后，<code>left</code> 就是目标值应该插入的位置，保证数组依旧有序。</p>
<h2 id="查找数组的峰值"><a href="#查找数组的峰值" class="headerlink" title="查找数组的峰值"></a>查找数组的峰值</h2><p>给定一个长度为n的数组nums，找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。</p>
<p>要在数组中找到一个<strong>峰值元素</strong>（比邻近元素大的元素）的位置，并返回它的索引。可以使用二分查找来实现这一点，时间复杂度为 O(log n)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findPeakElement</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果数组长度为1，直接返回第一个元素的索引0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 如果中间元素大于右侧元素，峰值在左侧</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果中间元素小于右侧元素，峰值在右侧</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环结束时，left 和 right 会指向同一位置，即峰值元素的位置</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>边界检查</strong>：如果数组长度为 1，直接返回 0。</li>
<li><strong>二分查找</strong>：<ul>
<li>计算 <code>mid</code> 的位置，将数组分为两部分。</li>
<li>如果 <code>nums[mid] &gt; nums[mid + 1]</code>，说明峰值在左侧（包括 <code>mid</code>），因此将 <code>right</code> 移动到 <code>mid</code>。</li>
<li>否则，峰值在右侧，将 <code>left</code> 移动到 <code>mid + 1</code>。</li>
</ul>
</li>
<li><strong>结束条件</strong>：当 <code>left == right</code> 时，<code>left</code> 指向的元素就是峰值，返回它的索引。</li>
</ol>
<h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h2><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>要在满足以下条件的 <code>m x n</code> 整数矩阵中搜索目标值 <code>target</code>：</p>
<ol>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ol>
<p>可以使用二分查找算法，这样可以在 O(log(mn)) 的时间复杂度内完成搜索。因为矩阵的每一行和每一列都是有序的，可以将其视为一个扁平化的有序数组，然后在这个数组中进行二分查找。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>将二维矩阵视为一维数组</strong>：</p>
<ul>
<li>假设矩阵有 <code>m</code> 行 <code>n</code> 列，可以将其视为一个长度为 <code>m * n</code> 的一维数组。</li>
<li>对于矩阵中的任何元素 <code>matrix[i][j]</code>，可以映射到一维数组中的索引 <code>i * n + j</code>。</li>
</ul>
</li>
<li><p><strong>进行二分查找</strong>：</p>
<ul>
<li>使用两个指针 <code>left</code> 和 <code>right</code> 来表示一维数组的搜索范围，初始时 <code>left = 0</code>，<code>right = m * n - 1</code>。</li>
<li>计算中间索引 <code>mid</code>，然后将其映射回二维矩阵中的位置，即 <code>matrix[mid // n][mid % n]</code>。</li>
<li>比较 <code>matrix[mid // n][mid % n]</code> 和 <code>target</code>：<ul>
<li>如果相等，则返回 <code>true</code>。</li>
<li>如果小于 <code>target</code>，则移动左指针 <code>left = mid + 1</code>。</li>
<li>如果大于 <code>target</code>，则移动右指针 <code>right = mid - 1</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>如果在搜索范围内没有找到 <code>target</code>，返回 <code>false</code>。</li>
</ul>
</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="keyword">function</span>(<span class="params">matrix, target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix.<span class="property">length</span> || !matrix[<span class="number">0</span>].<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> m = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = m * n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> midValue = matrix[<span class="title class_">Math</span>.<span class="title function_">floor</span>(mid / n)][mid % n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (midValue === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midValue &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(log(mn))，其中 <code>m</code> 是矩阵的行数，<code>n</code> 是矩阵的列数。因为使用的是二分查找，算法的时间复杂度是对元素总数的对数。</li>
<li><strong>空间复杂度</strong>：O(1)，因为我们只使用了常数级别的额外空间。</li>
</ul>
<p>这个方法利用了矩阵的有序性质，通过二分查找高效地搜索目标值。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用右上角值的特性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="keyword">function</span>(<span class="params">matrix, target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix.<span class="property">length</span> || !matrix[<span class="number">0</span>].<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> m = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> col = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = matrix[row][col];</span><br><span class="line">        <span class="keyword">if</span> (target === tmp) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; target) &#123;</span><br><span class="line">            col--; <span class="comment">// 目标值在当前列的左侧</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++; <span class="comment">// 目标值在当前行的下方</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解释和逻辑调整"><a href="#解释和逻辑调整" class="headerlink" title="解释和逻辑调整"></a>解释和逻辑调整</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>row</code> 初始化为 <code>0</code>，即从矩阵的第一行开始查找。</li>
<li><code>col</code> 初始化为 <code>n - 1</code>，即从矩阵的最后一列开始查找。</li>
</ul>
</li>
<li><p><strong>迭代查找</strong>：</p>
<ul>
<li>在每一次迭代中，检查当前位置 <code>matrix[row][col]</code>：<ul>
<li>如果 <code>matrix[row][col] === target</code>，直接返回 <code>true</code>。</li>
<li>如果 <code>matrix[row][col] &gt; target</code>，说明目标值在当前列的左侧，所以将 <code>col</code> 减小。</li>
<li>如果 <code>matrix[row][col] &lt; target</code>，说明目标值在当前行的下方，所以将 <code>row</code> 增加。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>终止条件</strong>：</p>
<ul>
<li>循环在 <code>row &gt;= m</code> 或 <code>col &lt; 0</code> 时终止，表示查找超出了矩阵的边界，此时返回 <code>false</code>。</li>
</ul>
</li>
</ol>
<p>这种方法利用了矩阵的有序性质，在时间复杂度为 O(m + n) 的情况下完成了目标值的搜索。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="keyword">function</span>(<span class="params">matrix, target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix.<span class="property">length</span> || !matrix[<span class="number">0</span>].<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> m = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> col = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = matrix[row][col];</span><br><span class="line">        <span class="keyword">if</span> (tmp === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; target) &#123;</span><br><span class="line">            col--; <span class="comment">// 目标值在当前列的左侧</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++; <span class="comment">// 目标值在当前行的下方</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><strong>使用两次二分查找</strong>：<ul>
<li><strong>第一次查找左边界</strong>：找到第一个大于等于目标值的位置。</li>
<li><strong>第二次查找右边界</strong>：找到最后一个等于目标值的位置。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>初始化 <code>left</code> 和 <code>right</code> 指针分别指向数组的起始和末尾。</li>
<li>在第一次二分查找中，如果 <code>nums[mid] &gt;= target</code>，则向左移动 <code>right</code>，否则向右移动 <code>left</code>。</li>
<li>在第二次二分查找中，如果 <code>nums[mid] &lt;= target</code>，则向右移动 <code>left</code>，否则向左移动 <code>right</code>。</li>
</ul>
</li>
<li><strong>返回结果</strong>：<ul>
<li>如果找到目标值的左边界和右边界，返回它们的索引。</li>
<li>如果没有找到目标值，返回 <code>[-1, -1]</code> 表示未找到。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchRange = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">leftfound</span>(nums, target);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">rightfound</span>(nums, target);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> [left, right];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">leftfound</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> leftindex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (target === nums[mid]) &#123;</span><br><span class="line">                    leftindex = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftindex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">rightfound</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> rightindex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (target === nums[mid]) &#123;</span><br><span class="line">                    rightindex = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightindex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法的时间复杂度为 O(log n)，其中 <code>n</code> 是数组 <code>nums</code> 的长度。这是因为每个二分查找都是对数组的对数级别的搜索，因此整体的时间复杂度是合理的。</p>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p>
<p>数据范围： 对于 50%50% 的数据, size≤104<em>s<strong>i</strong>z**e</em>≤104，对于 100%100% 的数据, size≤105<em>s<strong>i</strong>z**e</em>≤105，数组中所有数字的值满足 0≤val≤1090≤<em>v<strong>a</strong>l</em>≤109</p>
<p>要求：空间复杂度 O(n)<em>O</em>(<em>n</em>)，时间复杂度 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)</p>
<p>使用改进的归并排序方法。逆序对的定义是当 <code>nums[i] &gt; nums[j]</code> 且 <code>i &lt; j</code> 时，称为一个逆序对。在归并排序的“合并”步骤中，我们可以高效地计算这些逆序对。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">InversePairs</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr, left, right</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="title function_">mergeSort</span>(arr, left, mid);</span><br><span class="line">        <span class="title function_">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="title function_">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">arr, left, mid, right</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = [];</span><br><span class="line">        <span class="keyword">let</span> i = left;</span><br><span class="line">        <span class="keyword">let</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp.<span class="title function_">push</span>(arr[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.<span class="title function_">push</span>(arr[j++]);</span><br><span class="line">                count += mid - i + <span class="number">1</span>; <span class="comment">// 计算逆序对个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理剩余的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) temp.<span class="title function_">push</span>(arr[i++]);</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) temp.<span class="title function_">push</span>(arr[j++]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将排序后的结果拷贝回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            arr[k] = temp[k - left];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">mergeSort</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> count % <span class="number">1000000007</span>; <span class="comment">// 返回结果时对 10^9 + 7 取模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol>
<li><p><strong>归并排序与逆序对统计</strong>：</p>
<ul>
<li>我们使用改进的归并排序，在“合并”两个有序子数组时统计逆序对。</li>
<li>当左半部分的一个元素大于右半部分的一个元素时，可以得出从左边当前元素到中间所有的元素都和右边这个元素形成逆序对。</li>
</ul>
</li>
<li><p><strong>逆序对统计逻辑</strong>：</p>
<ul>
<li>如果 <code>arr[i] &gt; arr[j]</code>，则 <code>mid - i + 1</code> 个元素都满足逆序条件，因为 <code>[i, mid]</code> 区间内的所有元素都比 <code>arr[j]</code> 大。</li>
</ul>
</li>
<li><p><strong>取模运算</strong>：</p>
<ul>
<li>最后返回结果时，对 (10^9 + 7) 取模，以避免结果过大。</li>
</ul>
</li>
</ol>
<p>这种方法的时间复杂度为 (O(n \log n))，适合大规模输入的情况。</p>
<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>要求：时间复杂度为 <code>O(log n)</code></p>
<p>这是一个经典的二分查找问题，要求在旋转排序数组中查找目标值，并且要求时间复杂度为 (O(\log n))。要实现这一点，可以利用二分查找的变种算法。在旋转数组中，每次二分查找都会有一个有序的半区间，利用这个有序区间判断目标值是否在其中，从而决定如何移动左右指针。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>使用两个指针 <code>left</code> 和 <code>right</code> 分别指向数组的起始和末尾。</li>
</ul>
</li>
<li><p><strong>二分查找</strong>：</p>
<ul>
<li>计算中间索引 <code>mid</code>。</li>
<li>判断 <code>nums[mid]</code> 是否等于 <code>target</code>，如果是，返回 <code>mid</code>。</li>
<li>判断左半部分是否有序：<ul>
<li>如果 <code>nums[left] &lt;= nums[mid]</code>，表示左半部分有序：<ul>
<li>如果 <code>target</code> 在 <code>nums[left]</code> 和 <code>nums[mid]</code> 之间，移动 <code>right</code> 指针到 <code>mid - 1</code>。</li>
<li>否则，移动 <code>left</code> 指针到 <code>mid + 1</code>。</li>
</ul>
</li>
</ul>
</li>
<li>如果左半部分无序，则右半部分一定有序：<ul>
<li>如果 <code>target</code> 在 <code>nums[mid]</code> 和 <code>nums[right]</code> 之间，移动 <code>left</code> 指针到 <code>mid + 1</code>。</li>
<li>否则，移动 <code>right</code> 指针到 <code>mid - 1</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>如果找不到目标值，返回 <code>-1</code>。</li>
</ul>
</li>
</ol>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果数组长度为1且不等于目标值，直接返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] !== target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 计算中间索引</span></span><br><span class="line">        <span class="keyword">let</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果中间元素等于目标值，返回索引</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧是否有序</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &gt;= nums[left]) &#123;</span><br><span class="line">            <span class="comment">// 如果目标值在左侧有序部分范围内，移动右指针</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[m]) &#123;</span><br><span class="line">                right = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右侧有序</span></span><br><span class="line">            <span class="comment">// 如果目标值在右侧有序部分范围内，移动左指针</span></span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; target &amp;&amp; nums[right] &gt;= target) &#123;</span><br><span class="line">                left = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果未找到目标值，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><ul>
<li><strong>初始化</strong>：设定 <code>left</code> 为数组的起始位置，<code>right</code> 为数组的末尾位置。</li>
<li><strong>二分查找循环</strong>：<ul>
<li>计算中间索引 <code>mid</code>。</li>
<li>如果 <code>nums[mid]</code> 等于目标值，直接返回 <code>mid</code>。</li>
<li>判断 <code>nums[left]</code> 是否小于等于 <code>nums[mid]</code> 来确定左半部分是否有序。</li>
<li>如果左半部分有序，判断目标值是否在左半部分范围内，如果在，则移动 <code>right</code> 指针；否则，移动 <code>left</code> 指针。</li>
<li>如果左半部分无序，则右半部分一定有序，判断目标值是否在右半部分范围内，如果在，则移动 <code>left</code> 指针；否则，移动 <code>right</code> 指针。</li>
</ul>
</li>
<li><strong>返回结果</strong>：如果找不到目标值，返回 <code>-1</code>。</li>
</ul>
<p>这种方法能够在 (O(log n)) 时间复杂度内完成搜索，满足题目的要求。</p>
<h2 id="寻找旋转数组的最小值"><a href="#寻找旋转数组的最小值" class="headerlink" title="寻找旋转数组的最小值"></a>寻找旋转数组的最小值</h2><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>要求：时间复杂度为 <code>O(log n)</code></p>
<h3 id="方法1：sort排序"><a href="#方法1：sort排序" class="headerlink" title="方法1：sort排序"></a>方法1：sort排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法2：二分查找"><a href="#方法2：二分查找" class="headerlink" title="方法2：二分查找"></a>方法2：二分查找</h3><p>当 <code>nums[mid] == nums[right]</code> 时，不能确定最小值在哪一半，所以我们可以通过<strong>将右边界缩小一位</strong>来跳过重复的元素。</p>
<ol>
<li><p><strong>初始化指针</strong>：</p>
<ul>
<li>使用两个指针 <code>left</code> 和 <code>right</code> 分别指向数组的起始和末尾。</li>
</ul>
</li>
<li><p><strong>二分查找</strong>：</p>
<ul>
<li>计算中间索引 <code>mid</code>。</li>
<li>如果中间元素 <code>nums[mid]</code> 大于右端元素 <code>nums[right]</code>，说明最小值在右半部分，因此移动 <code>left</code> 指针到 <code>mid + 1</code>。</li>
<li>否则，说明最小值在左半部分或者就是 <code>mid</code>，因此移动 <code>right</code> 指针到 <code>mid</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>循环结束时，<code>left</code> 和 <code>right</code> 会指向最小值所在的位置，返回 <code>nums[left]</code> 或 <code>nums[right]</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">minNumberInRotateArray</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 最小值在右半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">            right = mid;  <span class="comment">// 最小值在左半部分或 mid 本身</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当 nums[mid] == nums[right] 时，无法确定方向，缩小右边界</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[left];  <span class="comment">// 最小值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理重复元素</strong>：当 <code>nums[mid] == nums[right]</code> 时，无法判断最小值的位置，因此我们将 <code>right</code> 减 1 来继续查找。</p>
<ul>
<li><p>例如数组 <code>[1, 0, 1, 1, 1]</code>，中间的 <code>1</code> 与右端 <code>1</code> 相等时，右边可能包含最小值，也可能不包含，但为了保证正确性，我们只需将 <code>right</code> 减小一位。</p>
</li>
<li><p><strong>时间复杂度</strong>：(O(log n))</p>
<ul>
<li>每次循环将搜索区间缩小一半，因此时间复杂度为 (O(log n))。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：(O(1))</p>
<ul>
<li>只使用了常量空间来存储指针和中间变量，没有使用额外的数组或数据结构。</li>
</ul>
</li>
</ul>
<p>这种方法通过不断缩小搜索范围，确保在 (O(\log n)) 时间复杂度内找到最小元素。</p>
<h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    nums1 = [...nums1, ...nums2];</span><br><span class="line">    nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> mid = nums1.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = mid / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (nums1[<span class="title class_">Math</span>.<span class="title function_">floor</span>(tmp)] + nums1[<span class="title class_">Math</span>.<span class="title function_">floor</span>(tmp) - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1[<span class="title class_">Math</span>.<span class="title function_">floor</span>(mid / <span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好的，让我们修改您的代码，以实现 ( O(\log(m+n)) ) 的时间复杂度，使用二分查找的方法直接在数组 <code>nums1</code> 和 <code>nums2</code> 中寻找中位数的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保 nums1 的长度不大于 nums2，简化处理</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.<span class="property">length</span> &gt; nums2.<span class="property">length</span>) &#123;</span><br><span class="line">        [nums1, nums2] = [nums2, nums1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> m = nums1.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> n = nums2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> totalLength = m + n;</span><br><span class="line">    <span class="keyword">const</span> halfLength = <span class="title class_">Math</span>.<span class="title function_">floor</span>((totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high = m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">const</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>((low + high) / );</span><br><span class="line">        <span class="keyword">const</span> j = halfLength - i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> maxLeftNums1 = (i === <span class="number">0</span>) ? -<span class="title class_">Infinity</span> : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> minRightNums1 = (i === m) ? <span class="title class_">Infinity</span> : nums1[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> maxLeftNums2 = (j === <span class="number">0</span>) ? -<span class="title class_">Infinity</span> : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> minRightNums2 = (j === n) ? <span class="title class_">Infinity</span> : nums2[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxLeftNums1 &lt;= minRightNums2 &amp;&amp; maxLeftNums2 &lt;= minRightNums1) &#123;</span><br><span class="line">            <span class="comment">// 找到正确的划分点</span></span><br><span class="line">            <span class="keyword">if</span> (totalLength % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="title class_">Math</span>.<span class="title function_">max</span>(maxLeftNums1, maxLeftNums2) + <span class="title class_">Math</span>.<span class="title function_">min</span>(minRightNums1, minRightNums2)) / <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLeftNums1, maxLeftNums2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxLeftNums1 &gt; minRightNums2) &#123;</span><br><span class="line">            <span class="comment">// i 太大，需要减小 i</span></span><br><span class="line">            high = i - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// i 太小，需要增大 i</span></span><br><span class="line">            low = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Arrays are not sorted!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><p><strong>初始化和二分查找设置</strong>：</p>
<ul>
<li>首先确保 <code>nums1</code> 是较小的数组（或大小相等）。这样可以简化二分查找的处理。</li>
<li>计算合并后数组的总长度 <code>totalLength</code> 和中位数位置的 <code>halfLength</code>。</li>
</ul>
</li>
<li><p><strong>二分查找</strong>：</p>
<ul>
<li>在较小数组 <code>nums1</code> 上使用二分查找，找到一个索引 <code>i</code>，满足以下条件：<ul>
<li>在 <code>nums1</code> 的 <code>i</code> 左侧和 <code>nums2</code> 的 <code>j</code> 左侧的元素均小于或等于右侧的元素。</li>
</ul>
</li>
<li>根据当前的划分情况调整 <code>i</code> 的值，使得划分更接近理想情况。</li>
</ul>
</li>
<li><p><strong>划分条件</strong>：</p>
<ul>
<li>根据当前的 <code>i</code> 和 <code>j</code> 计算 <code>nums1</code> 和 <code>nums2</code> 的左右两侧元素，并检查是否满足划分条件。</li>
<li>如果条件满足，则根据总长度是偶数还是奇数来计算中位数。</li>
</ul>
</li>
<li><p><strong>边界处理</strong>：</p>
<ul>
<li>确保在处理 <code>nums1</code> 和 <code>nums2</code> 边界情况时的正确性，例如 <code>i</code> 或 <code>j</code> 达到数组边界时的处理。</li>
</ul>
</li>
</ol>
<p>这种方法保证了在 ( O(\log(\min(m, n))) ) 的时间复杂度内找到中位数，符合题目要求。</p>
<h1 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h1><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<p>你的实现使用了两个栈：<code>x_stack</code> 用于存储所有元素，<code>min_stack</code> 用于存储当前的最小元素，这样可以在常数时间内获取最小值。你的实现是正确的并且高效，以下是对代码的详细解释和分析：</p>
<h3 id="代码实现和解释"><a href="#代码实现和解释" class="headerlink" title="代码实现和解释"></a>代码实现和解释</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MinStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化两个栈，x_stack 用于存储所有元素，min_stack 用于存储最小值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">min_stack</span> = [<span class="title class_">Infinity</span>]; <span class="comment">// 初始化 min_stack，保证在第一次 push 时能正确比较</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素 x 推入栈中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="comment">// 将元素推入 x_stack</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(x);</span><br><span class="line">    <span class="comment">// 将当前最小值推入 min_stack</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="variable language_">this</span>.<span class="property">min_stack</span>[<span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="property">length</span> - <span class="number">1</span>], x));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除栈顶元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 删除 x_stack 和 min_stack 的栈顶元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取栈顶元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 返回 x_stack 的栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索栈中的最小元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMin</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 返回 min_stack 的栈顶元素，即当前的最小值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">min_stack</span>[<span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>**构造函数 (<code>MinStack</code>)**：</p>
<ul>
<li>初始化两个栈：<code>x_stack</code> 存储所有元素，<code>min_stack</code> 存储当前的最小值。</li>
<li><code>min_stack</code> 初始化为 <code>[Infinity]</code>，这样确保在第一次 <code>push</code> 操作时可以正确比较并更新最小值。</li>
</ul>
</li>
<li><p><strong><code>push</code> 方法</strong>：</p>
<ul>
<li>将元素 <code>x</code> 推入 <code>x_stack</code>。</li>
<li>将 <code>x</code> 与 <code>min_stack</code> 当前的栈顶元素进行比较，取较小值推入 <code>min_stack</code>，这样 <code>min_stack</code> 的栈顶始终保持最小值。</li>
</ul>
</li>
<li><p><strong><code>pop</code> 方法</strong>：</p>
<ul>
<li>同时弹出 <code>x_stack</code> 和 <code>min_stack</code> 的栈顶元素，确保 <code>min_stack</code> 的栈顶始终与 <code>x_stack</code> 保持同步。</li>
</ul>
</li>
<li><p><strong><code>top</code> 方法</strong>：</p>
<ul>
<li>返回 <code>x_stack</code> 的栈顶元素。</li>
</ul>
</li>
<li><p><strong><code>getMin</code> 方法</strong>：</p>
<ul>
<li>返回 <code>min_stack</code> 的栈顶元素，即当前的最小值。</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li><code>push</code>：O(1)</li>
<li><code>pop</code>：O(1)</li>
<li><code>top</code>：O(1)</li>
<li><code>getMin</code>：O(1)</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>每次 <code>push</code> 操作都会向 <code>min_stack</code> 添加一个元素，因此空间复杂度为 O(n)，其中 n 是堆栈中的元素数量。</li>
</ul>
</li>
</ul>
<p>这个实现确保了所有操作的时间复杂度为常数时间，同时通过辅助栈 <code>min_stack</code> 维持当前的最小值，使得 <code>getMin</code> 操作能够快速返回最小值。</p>
<h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<ol>
<li><p><strong>使用栈来辅助解码</strong>：遍历输入字符串，使用两个栈来分别存储数字（重复次数）和字符串。</p>
</li>
<li><p><strong>遍历解码过程</strong>：</p>
<ul>
<li>当遇到数字时，解析完整的数字并入栈。</li>
<li>当遇到 <code>[</code> 时，将当前解码的字符串入栈，并重置当前字符串。</li>
<li>当遇到 <code>]</code> 时，开始出栈，直到遇到 <code>[</code>，这时将重复次数和当前字符串出栈，根据重复次数构造新的字符串并入栈。</li>
</ul>
</li>
<li><p><strong>构造最终解码后的字符串</strong>：最终栈中只会有一个字符串，即解码后的结果。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decodeString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> numStack = []; <span class="comment">// 用来存储数字的栈</span></span><br><span class="line">    <span class="keyword">let</span> strStack = []; <span class="comment">// 用来存储字符串的栈</span></span><br><span class="line">    <span class="keyword">let</span> currStr = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 当前解析的字符串</span></span><br><span class="line">    <span class="keyword">let</span> currNum = <span class="number">0</span>; <span class="comment">// 当前解析的数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (char &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; char &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到数字字符，计算完整的数字并入栈</span></span><br><span class="line">            currNum = currNum * <span class="number">10</span> + <span class="built_in">parseInt</span>(char);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到左括号，将当前数字和字符串入栈，并重置当前数字和字符串</span></span><br><span class="line">            numStack.<span class="title function_">push</span>(currNum);</span><br><span class="line">            strStack.<span class="title function_">push</span>(currStr);</span><br><span class="line">            currNum = <span class="number">0</span>;</span><br><span class="line">            currStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 遇到右括号，开始出栈直到遇到左括号</span></span><br><span class="line">            <span class="keyword">let</span> repeatTimes = numStack.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="keyword">let</span> prevStr = strStack.<span class="title function_">pop</span>();</span><br><span class="line">            currStr = prevStr + currStr.<span class="title function_">repeat</span>(repeatTimes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遇到普通字符，直接添加到当前字符串</span></span><br><span class="line">            currStr += char;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> currStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解释和示例"><a href="#解释和示例" class="headerlink" title="解释和示例"></a>解释和示例</h3><ul>
<li><p>对于字符串 <code>3[a]2[bc]</code>：</p>
<ul>
<li>遇到数字 <code>3</code>，入栈；</li>
<li>遇到 <code>[</code>，当前数字和当前字符串入栈，重置当前数字和字符串；</li>
<li>遇到 <code>]</code>，出栈，根据出栈的数字重复当前字符串，结果为 <code>&quot;aaabcbc&quot;</code>。</li>
</ul>
</li>
<li><p>对于字符串 <code>3[a2[c]]</code>：</p>
<ul>
<li>遇到数字 <code>3</code>，入栈；</li>
<li>遇到 <code>[</code>，当前数字和当前字符串入栈，重置当前数字和字符串；</li>
<li>遇到 <code>]</code>，出栈，根据出栈的数字重复当前字符串，结果为 <code>&quot;accaccacc&quot;</code>。</li>
</ul>
</li>
</ul>
<p>这种方法通过栈的结构，有效地处理了嵌套的解码规则，保证了字符串的正确解码。</p>
<h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p> 这个问题可以使用单调栈（Monotonic Stack）来解决，以便有效地找到每一天后面第一个更高温度出现的天数。下面是具体的实现方法：</p>
<ol>
<li><strong>使用单调栈</strong>：维护一个单调递减的栈，栈中存储的是温度数组的索引。</li>
<li><strong>遍历温度数组</strong>：从左到右遍历每一天的温度。<ul>
<li>如果当前温度大于栈顶索引处的温度，说明找到了栈顶索引对应的下一个更高温度的位置，计算天数差值并更新结果数组。</li>
<li>如果当前温度小于等于栈顶索引处的温度，将当前索引入栈，继续下一天的遍历。</li>
</ul>
</li>
</ol>
<p>这种方法的时间复杂度是 O(n)，因为每个元素最多进栈和出栈各一次。</p>
<p>下面是具体的 JavaScript 实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="keyword">function</span>(<span class="params">temperatures</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = temperatures.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; temperatures[i] &gt; temperatures[stack[stack.<span class="property">length</span> - <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">const</span> index = stack.<span class="title function_">pop</span>();</span><br><span class="line">            result[index] = i - index;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><ul>
<li><strong>初始化</strong>：创建一个与温度数组相同长度的结果数组 <code>result</code>，并创建一个空的栈 <code>stack</code>。</li>
<li><strong>遍历温度数组</strong>：对于每一天的温度，如果当前温度大于栈顶索引处的温度，说明找到了下一个更高温度的位置，计算天数差值并更新 <code>result</code> 数组；否则将当前索引入栈。</li>
<li><strong>返回结果</strong>：最终得到的 <code>result</code> 数组即为每一天后面第一个更高温度出现的天数，如果没有更高温度则为 0。</li>
</ul>
<p>这种方法利用了单调栈的特性，能够在 O(n) 的时间复杂度内解决问题，是一种高效的解决方案。</p>
<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<h3 id="解题思想"><a href="#解题思想" class="headerlink" title="解题思想"></a>解题思想</h3><p>要判断一个字符串中的括号是否有效，我们可以使用栈（stack）数据结构来帮助我们进行匹配。具体思路如下：</p>
<ol>
<li>遍历字符串中的每个字符。</li>
<li>如果遇到左括号（’(‘，’{‘，’[‘），将其压入栈中。</li>
<li>如果遇到右括号（’)’，’}’，’]’），检查栈顶元素是否是对应的左括号。如果是，将栈顶元素弹出；否则，字符串无效。</li>
<li>遍历结束后，如果栈为空，则字符串有效；否则，无效。</li>
</ol>
<p>以下是完整的代码和逐行解释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> qqq = &#123;</span><br><span class="line">        <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (char === <span class="string">&#x27;(&#x27;</span> || char === <span class="string">&#x27;[&#x27;</span> || char === <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(char);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.<span class="property">length</span> === <span class="number">0</span> || qqq[stack.<span class="title function_">pop</span>()] !== char) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="逐行解释"><a href="#逐行解释" class="headerlink" title="逐行解释"></a>逐行解释</h3><ol>
<li><strong>函数声明和初始化</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">const</span> matchingBracket = &#123;</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>const stack = [];</code>：创建一个空栈用于存储左括号。</li>
<li><code>const matchingBracket = &#123; ... &#125;;</code>：定义括号的对应关系。</li>
</ul>
<ol start="2">
<li><strong>遍历字符串</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">&#x27;(&#x27;</span> || char === <span class="string">&#x27;&#123;&#x27;</span> || char === <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(char);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;)&#x27;</span> || char === <span class="string">&#x27;&#125;&#x27;</span> || char === <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="property">length</span> === <span class="number">0</span> || stack[stack.<span class="property">length</span> - <span class="number">1</span>] !== matchingBracket[char]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for (const char of s) &#123; ... &#125;</code>：遍历字符串中的每个字符。<ul>
<li><code>if (char === &#39;(&#39; || char === &#39;&#123;&#39; || char === &#39;[&#39;) &#123; stack.push(char); &#125;</code>：如果是左括号，将其压入栈中。</li>
<li><code>else if (char === &#39;)&#39; || char === &#39;&#125;&#39; || char === &#39;]&#39;) &#123; ... &#125;</code>：如果是右括号，检查栈顶元素是否是对应的左括号。<ul>
<li><code>if (stack.length === 0 || stack[stack.length - 1] !== matchingBracket[char]) &#123; return false; &#125;</code>：如果不匹配，返回<code>false</code>。</li>
<li><code>stack.pop();</code>：弹出栈顶元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>检查栈是否为空</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>return stack.length === 0;</code>：如果栈为空，返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
<h3 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是字符串的长度。我们只遍历字符串一次，每个字符的操作（压栈和弹栈）都是 O(1) 的时间复杂度。</li>
<li><strong>空间复杂度</strong>：O(n)，在最坏情况下（所有字符都是左括号时），栈的大小可以达到字符串长度。</li>
</ul>
<h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>这个问题可以用单调栈来解决。通过一次遍历就可以找到每一个柱子作为矩形高度时的最大矩形面积，最终求出最大值。以下是具体实现的 Python 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">largestRectangleArea</span>(<span class="params">heights</span>) &#123;</span><br><span class="line">    <span class="comment">// 在原高度列表的头尾分别加上高度为0的元素</span></span><br><span class="line">    heights = [<span class="number">0</span>, ...heights, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; heights.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 当当前柱子的高度小于栈顶柱子的高度时</span></span><br><span class="line">        <span class="keyword">while</span> (stack.<span class="property">length</span> &amp;&amp; heights[i] &lt; heights[stack[stack.<span class="property">length</span> - <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">const</span> h = heights[stack.<span class="title function_">pop</span>()];  <span class="comment">// 栈顶元素的高度</span></span><br><span class="line">            <span class="keyword">const</span> w = i - stack[stack.<span class="property">length</span> - <span class="number">1</span>] - <span class="number">1</span>;  <span class="comment">// 当前栈顶与新栈顶之间的宽度</span></span><br><span class="line">            maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, h * w);  <span class="comment">// 计算矩形面积并更新最大面积</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_">push</span>(i);  <span class="comment">// 将当前柱子的索引入栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h3><ol>
<li><p><strong>初始化和扩展高度数组</strong>：</p>
<ul>
<li>为了方便处理边界情况，我们在高度数组的两端各添加一个高度为0的柱子。这保证了我们在处理到数组的边界时，能够正确地计算所有可能的矩形面积。</li>
</ul>
</li>
<li><p><strong>使用栈来存储柱子的索引</strong>：</p>
<ul>
<li>栈中存储的是柱子的索引，而不是高度。</li>
<li>当遍历到的当前柱子的高度小于栈顶柱子的高度时，表示可以计算以栈顶柱子高度为基础的最大矩形面积。</li>
</ul>
</li>
<li><p><strong>计算矩形面积</strong>：</p>
<ul>
<li>当当前柱子的高度小于栈顶柱子的高度时，不断从栈中弹出柱子的索引，并计算以弹出柱子高度为矩形高度的最大面积。</li>
<li>宽度的计算方法是当前柱子的索引减去新栈顶柱子索引再减1。</li>
</ul>
</li>
<li><p><strong>更新最大面积</strong>：</p>
<ul>
<li>每次计算出的矩形面积都会与当前最大面积比较，并更新最大面积。</li>
</ul>
</li>
</ol>
<p>这样通过一次遍历，就能找到每一个柱子作为矩形高度时的最大矩形面积，最终求出整个柱状图中的最大矩形面积。</p>
<p>通过输入 <code>heights = [2, 1, 5, 6, 2, 3]</code> 来详细解释代码的执行过程。</p>
<h3 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>heights = [0, 2, 1, 5, 6, 2, 3, 0]</code></li>
<li><code>stack = []</code></li>
<li><code>maxArea = 0</code></li>
</ul>
</li>
<li><p><strong>遍历高度数组</strong>：</p>
<p><strong>第1步（i &#x3D; 0）</strong>：</p>
<ul>
<li>当前高度 <code>heights[0] = 0</code></li>
<li>栈为空，直接入栈：<code>stack = [0]</code></li>
</ul>
<p><strong>第2步（i &#x3D; 1）</strong>：</p>
<ul>
<li>当前高度 <code>heights[1] = 2</code></li>
<li>栈顶高度 <code>heights[stack[stack.length - 1]] = heights[0] = 0</code></li>
<li>当前高度大于栈顶高度，直接入栈：<code>stack = [0, 1]</code></li>
</ul>
<p><strong>第3步（i &#x3D; 2）</strong>：</p>
<ul>
<li>当前高度 <code>heights[2] = 1</code></li>
<li>栈顶高度 <code>heights[stack[stack.length - 1]] = heights[1] = 2</code></li>
<li>当前高度小于栈顶高度，开始弹栈：<ul>
<li>弹出栈顶索引1，高度h &#x3D; 2，宽度w &#x3D; 2 - 0 - 1 &#x3D; 1，面积 &#x3D; 2 * 1 &#x3D; 2，更新maxArea &#x3D; 2</li>
</ul>
</li>
<li>栈：<code>stack = [0]</code></li>
<li>当前高度 <code>heights[2] = 1</code> 大于栈顶高度，直接入栈：<code>stack = [0, 2]</code></li>
</ul>
<p><strong>第4步（i &#x3D; 3）</strong>：</p>
<ul>
<li>当前高度 <code>heights[3] = 5</code></li>
<li>栈顶高度 <code>heights[stack[stack.length - 1]] = heights[2] = 1</code></li>
<li>当前高度大于栈顶高度，直接入栈：<code>stack = [0, 2, 3]</code></li>
</ul>
<p><strong>第5步（i &#x3D; 4）</strong>：</p>
<ul>
<li>当前高度 <code>heights[4] = 6</code></li>
<li>栈顶高度 <code>heights[stack[stack.length - 1]] = heights[3] = 5</code></li>
<li>当前高度大于栈顶高度，直接入栈：<code>stack = [0, 2, 3, 4]</code></li>
</ul>
<p><strong>第6步（i &#x3D; 5）</strong>：</p>
<ul>
<li>当前高度 <code>heights[5] = 2</code></li>
<li>栈顶高度 <code>heights[stack[stack.length - 1]] = heights[4] = 6</code></li>
<li>当前高度小于栈顶高度，开始弹栈：<ul>
<li>弹出栈顶索引4，高度h &#x3D; 6，宽度w &#x3D; 5 - 3 - 1 &#x3D; 1，面积 &#x3D; 6 * 1 &#x3D; 6，更新maxArea &#x3D; 6</li>
<li>弹出栈顶索引3，高度h &#x3D; 5，宽度w &#x3D; 5 - 2 - 1 &#x3D; 2，面积 &#x3D; 5 * 2 &#x3D; 10，更新maxArea &#x3D; 10</li>
</ul>
</li>
<li>栈：<code>stack = [0, 2]</code></li>
<li>当前高度 <code>heights[5] = 2</code> 大于栈顶高度，直接入栈：<code>stack = [0, 2, 5]</code></li>
</ul>
<p><strong>第7步（i &#x3D; 6）</strong>：</p>
<ul>
<li>当前高度 <code>heights[6] = 3</code></li>
<li>栈顶高度 <code>heights[stack[stack.length - 1]] = heights[5] = 2</code></li>
<li>当前高度大于栈顶高度，直接入栈：<code>stack = [0, 2, 5, 6]</code></li>
</ul>
<p><strong>第8步（i &#x3D; 7）</strong>：</p>
<ul>
<li>当前高度 <code>heights[7] = 0</code></li>
<li>栈顶高度 <code>heights[stack[stack.length - 1]] = heights[6] = 3</code></li>
<li>当前高度小于栈顶高度，开始弹栈：<ul>
<li>弹出栈顶索引6，高度h &#x3D; 3，宽度w &#x3D; 7 - 5 - 1 &#x3D; 1，面积 &#x3D; 3 * 1 &#x3D; 3，maxArea &#x3D; 10</li>
<li>弹出栈顶索引5，高度h &#x3D; 2，宽度w &#x3D; 7 - 2 - 1 &#x3D; 4，面积 &#x3D; 2 * 4 &#x3D; 8，maxArea &#x3D; 10</li>
<li>弹出栈顶索引2，高度h &#x3D; 1，宽度w &#x3D; 7 - 0 - 1 &#x3D; 6，面积 &#x3D; 1 * 6 &#x3D; 6，maxArea &#x3D; 10</li>
</ul>
</li>
<li>栈：<code>stack = [0]</code></li>
<li>当前高度 <code>heights[7] = 0</code> 大于栈顶高度，直接入栈：<code>stack = [0, 7]</code></li>
</ul>
</li>
</ol>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>遍历结束后，最大矩形面积 <code>maxArea</code> 为 10。</p>
<h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><p>你提供的代码用于查找数组 <code>nums</code> 中唯一一个不重复的数字，但有一些问题需要修正。排序和遍历方法时间复杂度较高，<code>break</code> 也不需要使用。此外，代码中没有处理边界条件和正确返回值。</p>
<p>下面是修正和优化后的代码，其中我使用了异或运算来解决问题。异或运算时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code>，这是查找单个不重复元素的一种高效方法：</p>
<h3 id="修正后的代码："><a href="#修正后的代码：" class="headerlink" title="修正后的代码："></a>修正后的代码：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        result ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a>解释</h3><ol>
<li><p><strong>异或运算</strong>：</p>
<ul>
<li>异或运算 (<code>^</code>) 的性质：<ul>
<li><code>a ^ a = 0</code>：任何数和自身异或结果为 0。</li>
<li><code>a ^ 0 = a</code>：任何数和 0 异或结果为自身。</li>
<li>异或运算具有交换律和结合律：<code>a ^ b ^ a = b</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>算法步骤</strong>：</p>
<ul>
<li>初始化 <code>result</code> 为 0。</li>
<li>遍历数组 <code>nums</code>，对每个数字进行异或操作。</li>
<li>最终，<code>result</code> 即为唯一一个不重复的数字。</li>
</ul>
</li>
</ol>
<h3 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h3><ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是数组 <code>nums</code> 的长度。我们只需遍历数组一次。</li>
<li><strong>空间复杂度</strong>：<code>O(1)</code>，只使用了一个额外的变量 <code>result</code>。</li>
</ul>
<p>这种方法相比于排序和遍历的方法更为高效，特别适用于查找数组中唯一不重复的数字。</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== nums[i + <span class="number">1</span>] &amp;&amp; nums[i] !== nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>当然，除了使用异或运算外，还有其他方法可以解决这个问题，例如使用哈希表或者计数的方法。这些方法的时间复杂度也是 <code>O(n)</code>，但它们的空间复杂度为 <code>O(n)</code>。下面是两个不同的解法：</p>
<h3 id="方法一：使用哈希表"><a href="#方法一：使用哈希表" class="headerlink" title="方法一：使用哈希表"></a>方法一：使用哈希表</h3><p>我们可以使用一个哈希表来记录每个数字出现的次数。最后遍历哈希表，找到只出现一次的数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hashMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.<span class="title function_">has</span>(num)) &#123;</span><br><span class="line">            hashMap.<span class="title function_">set</span>(num, hashMap.<span class="title function_">get</span>(num) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.<span class="title function_">set</span>(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到只出现一次的数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> hashMap.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">singleNumber</span>(nums)); <span class="comment">// 输出: 4</span></span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用集合"><a href="#方法二：使用集合" class="headerlink" title="方法二：使用集合"></a>方法二：使用集合</h3><p>我们可以利用集合来存储每个数字。如果一个数字已经存在于集合中，我们将其删除。如果不存在，我们将其添加到集合中。最后，集合中剩下的唯一元素就是只出现一次的数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.<span class="title function_">has</span>(num)) &#123;</span><br><span class="line">            set.<span class="title function_">delete</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.<span class="title function_">add</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回集合中的唯一元素</span></span><br><span class="line">    <span class="keyword">return</span> [...set][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">singleNumber</span>(nums)); <span class="comment">// 输出: 4</span></span><br></pre></td></tr></table></figure>

<h3 id="方法三：数学方法（2∗sum-集合-−sum-数组-）"><a href="#方法三：数学方法（2∗sum-集合-−sum-数组-）" class="headerlink" title="方法三：数学方法（2∗sum(集合)−sum(数组)）"></a>方法三：数学方法（2∗sum(集合)−sum(数组)）</h3><p>这是一个基于数学的方法。集合中所有元素的和乘以2减去数组中所有元素的和，结果就是只出现一次的数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(nums);</span><br><span class="line">    <span class="keyword">let</span> setSum = <span class="number">0</span>, arraySum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> set) &#123;</span><br><span class="line">        setSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        arraySum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * setSum - arraySum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">singleNumber</span>(nums)); <span class="comment">// 输出: 4</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><strong>哈希表方法</strong>：</p>
<ul>
<li>时间复杂度：<code>O(n)</code></li>
<li>空间复杂度：<code>O(n)</code></li>
</ul>
</li>
<li><p><strong>集合方法</strong>：</p>
<ul>
<li>时间复杂度：<code>O(n)</code></li>
<li>空间复杂度：<code>O(n)</code></li>
</ul>
</li>
<li><p><strong>数学方法</strong>：</p>
<ul>
<li>时间复杂度：<code>O(n)</code></li>
<li>空间复杂度：<code>O(n)</code></li>
</ul>
</li>
</ol>
<p>上述三种方法中，哈希表和集合方法都需要额外的 <code>O(n)</code> 空间，而异或方法则只需要 <code>O(1)</code> 的空间。根据具体需求选择适合的方法。</p>
<h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>你提供的代码用于寻找数组 <code>nums</code> 中的多数元素，即出现次数超过 <code>n/2</code> 的元素。代码思路是通过哈希表记录每个元素的出现次数，然后再找出出现次数超过一半的元素。这个方法是可行的，但可以进行一些优化和修正。</p>
<h3 id="修正后的代码"><a href="#修正后的代码" class="headerlink" title="修正后的代码"></a>修正后的代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(num, (map.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">majorityElement</span>(nums)); <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure>

<h3 id="逐行分析"><a href="#逐行分析" class="headerlink" title="逐行分析"></a>逐行分析</h3><ol>
<li><p><strong>初始化哈希表</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br></pre></td></tr></table></figure>
<p>初始化一个空的 <code>Map</code> 来存储每个元素的出现次数。</p>
</li>
<li><p><strong>遍历数组并记录出现次数</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    map.<span class="title function_">set</span>(num, (map.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历 <code>nums</code> 数组，对于每个元素 <code>num</code>，在 <code>map</code> 中记录其出现次数。如果 <code>num</code> 已经存在于 <code>map</code> 中，则获取其当前的次数并加 1；如果不存在，则初始化为 1。</p>
</li>
<li><p><strong>遍历哈希表找出多数元素</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历 <code>map</code> 中的所有键值对，检查每个值是否大于 <code>nums.length / 2</code>，如果是，则返回对应的键。</p>
</li>
</ol>
<h3 id="优化方法：Boyer-Moore-投票算法"><a href="#优化方法：Boyer-Moore-投票算法" class="headerlink" title="优化方法：Boyer-Moore 投票算法"></a>优化方法：Boyer-Moore 投票算法</h3><p>除了使用哈希表的方法，我们还可以使用 Boyer-Moore 投票算法，这种算法时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code>。这个算法的核心思想是通过计数来找到多数元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> candidate = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">            candidate = num;</span><br><span class="line">        &#125;</span><br><span class="line">        count += (num === candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Boyer-Moore-投票算法逐行分析"><a href="#Boyer-Moore-投票算法逐行分析" class="headerlink" title="Boyer-Moore 投票算法逐行分析"></a>Boyer-Moore 投票算法逐行分析</h3><ol>
<li><p><strong>初始化候选者和计数器</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> candidate = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>初始化候选者为 <code>null</code>，计数器为 <code>0</code>。</p>
</li>
<li><p><strong>遍历数组</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">        candidate = num;</span><br><span class="line">    &#125;</span><br><span class="line">    count += (num === candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历 <code>nums</code> 数组，如果计数器为 <code>0</code>，则将当前元素 <code>num</code> 设置为候选者。然后，如果当前元素等于候选者，计数器加 1，否则计数器减 1。</p>
</li>
<li><p><strong>返回候选者</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> candidate;</span><br></pre></td></tr></table></figure>
<p>最后返回候选者，即为多数元素。</p>
</li>
</ol>
<h3 id="Boyer-Moore-投票算法的优势"><a href="#Boyer-Moore-投票算法的优势" class="headerlink" title="Boyer-Moore 投票算法的优势"></a>Boyer-Moore 投票算法的优势</h3><ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，只需遍历数组一次。</li>
<li><strong>空间复杂度</strong>：<code>O(1)</code>，只使用了常数级别的额外空间。</li>
</ul>
<h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<h3 id="方法1：排序"><a href="#方法1：排序" class="headerlink" title="方法1：排序"></a>方法1：排序</h3><p>最直接的方法是先对数组进行排序，然后取第 <code>k</code> 个最大的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line">    <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="方法-2：使用最小堆"><a href="#方法-2：使用最小堆" class="headerlink" title="方法 2：使用最小堆"></a>方法 2：使用最小堆</h3><p>使用最小堆可以在时间复杂度上进行优化。维持一个大小为 <code>k</code> 的最小堆，堆顶元素就是第 <code>k</code> 大的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> minHeap = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        minHeap.<span class="title function_">enqueue</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (minHeap.<span class="title function_">size</span>() &gt; k) &#123;</span><br><span class="line">            minHeap.<span class="title function_">dequeue</span>(); <span class="comment">// 保持堆的大小为k</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 堆顶元素即为第k大的元素</span></span><br><span class="line">    <span class="keyword">return</span> minHeap.<span class="title function_">front</span>().<span class="property">element</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N log k)，其中 N 是数组的长度。对每个元素插入和删除操作的时间复杂度是 O(log k)。</li>
<li>空间复杂度：O(k)，堆的大小为 k。</li>
</ul>
<h3 id="方法-3：快速选择（Quickselect）"><a href="#方法-3：快速选择（Quickselect）" class="headerlink" title="方法 3：快速选择（Quickselect）"></a>方法 3：快速选择（Quickselect）</h3><p>快速选择算法是快速排序的一部分，可以在平均情况下在线性时间内找到第 <code>k</code> 个最大的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">quickSelect</span>(<span class="params">left, right, kSmallest</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left === right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> pivotIndex = <span class="title function_">partition</span>(left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (kSmallest === pivotIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[kSmallest];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kSmallest &lt; pivotIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">quickSelect</span>(left, pivotIndex - <span class="number">1</span>, kSmallest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">quickSelect</span>(pivotIndex + <span class="number">1</span>, right, kSmallest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pivot = nums[right];</span><br><span class="line">        <span class="keyword">let</span> i = left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; pivot) &#123;</span><br><span class="line">                [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [nums[i], nums[right]] = [nums[right], nums[i]];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSelect</span>(<span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N) 在平均情况下，快速选择的时间复杂度是 O(N)。</li>
<li>空间复杂度：O(1) 快速选择是原地排序，没有使用额外的空间。</li>
</ul>
<h3 id="方法-4：基于快速排序的分治法"><a href="#方法-4：基于快速排序的分治法" class="headerlink" title="方法 4：基于快速排序的分治法"></a>方法 4：基于快速排序的分治法</h3><p>与快速选择类似，可以使用快速排序的分治思想，找到第 <code>k</code> 大的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pivot = nums[right];</span><br><span class="line">        <span class="keyword">let</span> i = left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; pivot) &#123;</span><br><span class="line">                [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [nums[i], nums[right]] = [nums[right], nums[i]];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">left, right, k</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">let</span> pi = <span class="title function_">partition</span>(left, right);</span><br><span class="line">            <span class="keyword">if</span> (pi === k) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[pi];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pi &lt; k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">quickSort</span>(pi + <span class="number">1</span>, right, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">quickSort</span>(left, pi - <span class="number">1</span>, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSort</span>(<span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N log N) 在最坏情况下，分治法的时间复杂度是 O(N log N)。</li>
<li>空间复杂度：O(log N) 由于递归调用栈的空间开销。</li>
</ul>
<h3 id="方法-5：使用内置方法"><a href="#方法-5：使用内置方法" class="headerlink" title="方法 5：使用内置方法"></a>方法 5：使用内置方法</h3><p>如果可以使用JavaScript的内置方法，也可以用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)[k - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N log N) 排序的时间复杂度是 O(N log N)。</li>
<li>空间复杂度：O(1) 使用原地排序，不需要额外空间。</li>
</ul>
<p>每种方法都有其适用的场景。使用排序方法简单直接，但在处理大数据时，快速选择和最小堆的方法更为高效。</p>
<h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请返回其中出现频率前 <code>k</code> 高的元素。可以按 <strong>任意顺序</strong> 返回答案。</p>
<p>要解决这个问题，可以分为以下步骤：</p>
<ol>
<li><strong>统计每个元素的频率</strong>：使用哈希表（Map）来记录每个元素出现的次数。</li>
<li><strong>使用最小堆（小顶堆）来找出前 k 高频率的元素</strong>：在堆中保持当前频率最高的 k 个元素。</li>
</ol>
<h4 id="步骤-1：统计每个元素的频率"><a href="#步骤-1：统计每个元素的频率" class="headerlink" title="步骤 1：统计每个元素的频率"></a>步骤 1：统计每个元素的频率</h4><p>使用哈希表 <code>freqMap</code> 来记录每个元素出现的频率。</p>
<h4 id="步骤-2：使用最小堆来维护前-k-高频率的元素"><a href="#步骤-2：使用最小堆来维护前-k-高频率的元素" class="headerlink" title="步骤 2：使用最小堆来维护前 k 高频率的元素"></a>步骤 2：使用最小堆来维护前 k 高频率的元素</h4><ol>
<li><strong>遍历哈希表</strong>：将元素和其频率加入最小堆中。</li>
<li><strong>维护堆的大小</strong>：当堆的大小超过 k 时，删除堆顶元素（频率最小的元素）。</li>
<li><strong>输出结果</strong>：堆中剩下的元素即为频率前 k 高的元素。</li>
</ol>
<h4 id="code：-1"><a href="#code：-1" class="headerlink" title="code："></a>code：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="comment">// Step 1: 统计每个元素的频率</span></span><br><span class="line">    <span class="keyword">const</span> freqMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        freqMap.<span class="title function_">set</span>(num, freqMap.<span class="title function_">get</span>(num) + <span class="number">1</span> || <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 2: 使用最小堆找出前 k 高频率的元素</span></span><br><span class="line">    <span class="keyword">const</span> minHeap = <span class="keyword">new</span> <span class="title class_">MinHeap</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历哈希表，将元素和频率加入最小堆</span></span><br><span class="line">    freqMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">freq, num</span>) =&gt;</span> &#123;</span><br><span class="line">        minHeap.<span class="title function_">add</span>(&#123; num, freq &#125;);</span><br><span class="line">        <span class="keyword">if</span> (minHeap.<span class="title function_">size</span>() &gt; k) &#123;</span><br><span class="line">            minHeap.<span class="title function_">poll</span>(); <span class="comment">// 维持堆的大小为 k</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 堆中剩下的元素即为频率前 k 高的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">        result.<span class="title function_">unshift</span>(minHeap.<span class="title function_">poll</span>().<span class="property">num</span>); <span class="comment">// 堆顶是最小值，需要逆序输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义最小堆的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">add</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">push</span>(value);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">heapifyUp</span>(<span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">poll</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> min = <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">heapifyUp</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentIndex = index;</span><br><span class="line">        <span class="keyword">let</span> parentIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((currentIndex - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (parentIndex &gt;= <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">heap</span>[currentIndex].<span class="property">freq</span> &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[parentIndex].<span class="property">freq</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">swap</span>(currentIndex, parentIndex);</span><br><span class="line">            currentIndex = parentIndex;</span><br><span class="line">            parentIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((currentIndex - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">heapifyDown</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentIndex = index;</span><br><span class="line">        <span class="keyword">let</span> leftChildIndex = <span class="number">2</span> * currentIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> rightChildIndex = <span class="number">2</span> * currentIndex + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">let</span> smallestIndex = currentIndex;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (leftChildIndex &lt; <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">heap</span>[leftChildIndex].<span class="property">freq</span> &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[smallestIndex].<span class="property">freq</span>) &#123;</span><br><span class="line">            smallestIndex = leftChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightChildIndex &lt; <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">heap</span>[rightChildIndex].<span class="property">freq</span> &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[smallestIndex].<span class="property">freq</span>) &#123;</span><br><span class="line">            smallestIndex = rightChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (smallestIndex !== currentIndex) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">swap</span>(currentIndex, smallestIndex);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(smallestIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">swap</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">        [<span class="variable language_">this</span>.<span class="property">heap</span>[i], <span class="variable language_">this</span>.<span class="property">heap</span>[j]] = [<span class="variable language_">this</span>.<span class="property">heap</span>[j], <span class="variable language_">this</span>.<span class="property">heap</span>[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul>
<li>时间复杂度：O(N log k)，其中 N 是数组 <code>nums</code> 的长度。建立哈希表的时间复杂度是 O(N)，向最小堆中插入元素和删除堆顶元素的平均时间复杂度是 O(log k)，总体复杂度是 O(N log k)。</li>
<li>空间复杂度：O(N)，用于存储哈希表和最小堆的元素。</li>
</ul>
<p>这种方法利用了哈希表和最小堆的特性，通过维护堆来找出前 k 高频率的元素，非常高效。</p>
<h3 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    map.<span class="title function_">set</span>(num, (map.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建小顶堆</span></span><br><span class="line">  <span class="keyword">const</span> priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// entry 是一个长度为2的数组，0位置存储key，1位置存储value</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    priorityQueue.<span class="title function_">push</span>(entry);</span><br><span class="line">    <span class="keyword">if</span> (priorityQueue.<span class="title function_">size</span>() &gt; k) &#123;</span><br><span class="line">      priorityQueue.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ret = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = priorityQueue.<span class="title function_">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    ret[i] = priorityQueue.<span class="title function_">pop</span>()[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PriorityQueue</span>(<span class="params">compareFn</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">compareFn</span> = compareFn;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 上浮</span></span><br><span class="line">  <span class="keyword">while</span>(parent &gt;= <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(parent, index) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[parent]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[parent], <span class="variable language_">this</span>.<span class="property">queue</span>[index]];</span><br><span class="line">    index = parent;</span><br><span class="line">    parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取堆顶元素并移除</span></span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ret = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把最后一个节点移到堆顶</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 左子节点下标，left + 1 就是右子节点下标</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> selectedChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下沉</span></span><br><span class="line">  <span class="keyword">while</span>(selectedChild !== <span class="literal">undefined</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(index, selectedChild) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[selectedChild]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[selectedChild], <span class="variable language_">this</span>.<span class="property">queue</span>[index]];</span><br><span class="line">    index = selectedChild;</span><br><span class="line">    left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    selectedChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用传入的 compareFn 比较两个位置的元素</span></span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">compare</span> = <span class="keyword">function</span>(<span class="params">index1, index2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index1] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index2] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">compareFn</span>(<span class="variable language_">this</span>.<span class="property">queue</span>[index1], <span class="variable language_">this</span>.<span class="property">queue</span>[index2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码利用小顶堆的特性，通过优先队列的方式高效地解决了「前 k 高频元素」的问题。它将复杂度控制在 O(N log k)，适用于处理大量数据的情况，并且通过自定义的 <code>PriorityQueue</code> 类来实现堆操作，使代码结构清晰且具有可重用性。</p>
<h3 id="解法3："><a href="#解法3：" class="headerlink" title="解法3："></a>解法3：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> topKFrequent = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Map 对象来统计每个数字出现的频率</span></span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="comment">// 使用 Set 对象对 nums 数组进行去重，得到不重复的数字数组 arr</span></span><br><span class="line">    <span class="keyword">let</span> arr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(nums)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 nums 数组，统计每个数字的频率并存储到 map 中</span></span><br><span class="line">    nums.<span class="title function_">map</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(num)) &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(num, map.<span class="title function_">get</span>(num) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 arr 数组按照数字在 map 中的频率进行降序排序，并返回前 k 个元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> map.<span class="title function_">get</span>(b) - map.<span class="title function_">get</span>(a)).<span class="title function_">slice</span>(<span class="number">0</span>, k);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>对 <code>arr</code> 数组进行排序，排序依据是 <code>map.get(b) - map.get(a)</code>，即按照数字在 <code>map</code> 中的频率降序排列。</li>
<li>使用 <code>slice(0, k)</code> 方法取排序后的前 <code>k</code> 个元素作为结果返回。</li>
</ul>
<blockquote>
<p> 这段代码通过 <code>Map</code> 对象统计频率，利用 <code>Set</code> 对象进行去重，然后对数组进行排序来实现找出前 <code>k</code> 个高频元素的功能。它的复杂度主要由排序操作决定，在最坏情况下为 <code>O(n log n)</code>，其中 <code>n</code> 是 <code>nums</code> 数组的长度。</p>
</blockquote>
<h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h2><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>
<ul>
<li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li>
<li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li>
</ul>
<p>实现 MedianFinder 类:</p>
<ul>
<li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li>
<li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li>
<li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10-5</code> 以内的答案将被接受。</li>
</ul>
<h3 id="解法1：排序（会超时）"><a href="#解法1：排序（会超时）" class="headerlink" title="解法1：排序（会超时）"></a>解法1：排序（会超时）</h3><ul>
<li><p>每次添加一个数字后，对所有数字进行排序，然后根据排序结果找到中位数。</p>
</li>
<li><p>时间复杂度：<code>O(n log n)</code>，每次插入数字后进行排序。</p>
</li>
<li><p>空间复杂度：<code>O(n)</code>，需要存储所有数字。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nums</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">addNum</span>(<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nums</span>.<span class="title function_">push</span>(num);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nums</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">findMedian</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = <span class="variable language_">this</span>.<span class="property">nums</span>.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">nums</span>[n / <span class="number">2</span> - <span class="number">1</span>] + <span class="variable language_">this</span>.<span class="property">nums</span>[n / <span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nums</span>[<span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：双堆法"><a href="#解法2：双堆法" class="headerlink" title="解法2：双堆法"></a>解法2：双堆法</h3><ul>
<li>使用一个<strong>大顶堆</strong>来存储数据流中较小的一半数据，堆顶存储较小那部分数据中的最大值。</li>
<li>使用一个<strong>小顶堆</strong>来存储数据流中较大的一半数据，堆顶存储较大那部分数据中的最小值。</li>
</ul>
<blockquote>
<p> 如果数据流中的数据个数是偶数，则大顶堆和小顶堆中的元素数相同，取两个堆顶的平均值作为中位数。如果数据流中的数据个数是奇数，则将大顶堆中的堆顶元素作为中位数（大顶堆比小顶堆多存一个元素）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大顶堆存储较小的一半元素，小顶堆存储较大的一半元素</span></span><br><span class="line"><span class="keyword">let</span> maxHeap = []; <span class="comment">// 大顶堆</span></span><br><span class="line"><span class="keyword">let</span> minHeap = []; <span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据流中的新数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Insert</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="comment">// 先插入到大顶堆，如果比大顶堆的堆顶大，则放入小顶堆</span></span><br><span class="line">    <span class="keyword">if</span> (maxHeap.<span class="property">length</span> === <span class="number">0</span> || num &lt;= maxHeap[<span class="number">0</span>]) &#123;</span><br><span class="line">        maxHeap.<span class="title function_">push</span>(num);</span><br><span class="line">        maxHeap.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a); <span class="comment">// 保证是大顶堆</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minHeap.<span class="title function_">push</span>(num);</span><br><span class="line">        minHeap.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 保证是小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整两个堆的平衡</span></span><br><span class="line">    <span class="keyword">if</span> (maxHeap.<span class="property">length</span> &gt; minHeap.<span class="property">length</span> + <span class="number">1</span>) &#123;</span><br><span class="line">        minHeap.<span class="title function_">push</span>(maxHeap.<span class="title function_">shift</span>());</span><br><span class="line">        minHeap.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minHeap.<span class="property">length</span> &gt; maxHeap.<span class="property">length</span>) &#123;</span><br><span class="line">        maxHeap.<span class="title function_">push</span>(minHeap.<span class="title function_">shift</span>());</span><br><span class="line">        maxHeap.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前数据流的中位数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GetMedian</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxHeap.<span class="property">length</span> &gt; minHeap.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap[<span class="number">0</span>];  <span class="comment">// 如果总数为奇数，大顶堆堆顶就是中位数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (maxHeap[<span class="number">0</span>] + minHeap[<span class="number">0</span>]) / <span class="number">2</span>;  <span class="comment">// 如果总数为偶数，返回两个堆顶的平均值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度<ul>
<li>插入数据时需要将新元素插入堆，并调整堆，堆排序的复杂度为 O(log n)。</li>
<li>获取中位数的操作是常数时间 O(1)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：O(n)，使用了两个堆来存储数据流中的元素。</li>
</ul>
<h3 id="解法3：双指针"><a href="#解法3：双指针" class="headerlink" title="解法3：双指针"></a>解法3：双指针</h3><p><strong>解题思路</strong>：</p>
<ul>
<li>使用两个指针分别指向排序后数组的中间位置。</li>
<li>添加数字时，通过双指针维护数组的中间位置。</li>
</ul>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<code>O(n)</code>（维护指针的位置）。</li>
<li>空间复杂度：<code>O(n)</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MedianFinder</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MedianFinder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addNum</span> = <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">arr</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">arr</span>[mid] === num) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">arr</span>[mid] &gt; num) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">splice</span>(left, <span class="number">0</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MedianFinder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">findMedian</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">arr</span>[n / <span class="number">2</span> - <span class="number">1</span>] + <span class="variable language_">this</span>.<span class="property">arr</span>[n / <span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>[<span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">preorderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];  <span class="comment">// 在外部定义 res 数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">preOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        res.<span class="title function_">push</span>(node.<span class="property">val</span>);  <span class="comment">// 添加当前节点的值</span></span><br><span class="line">        <span class="title function_">preOrder</span>(node.<span class="property">left</span>);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="title function_">preOrder</span>(node.<span class="property">right</span>); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">preOrder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];  <span class="comment">// 定义用于存储结果的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;      <span class="comment">// 如果节点为空，直接返回</span></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">left</span>);      <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        res.<span class="title function_">push</span>(node.<span class="property">val</span>);      <span class="comment">// 访问根节点并将值加入结果数组</span></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">right</span>);     <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">inOrder</span>(root);  <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">    <span class="keyword">return</span> res;     <span class="comment">// 返回遍历结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postorderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];  <span class="comment">// 用于存储结果的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">postOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;       <span class="comment">// 如果节点为空，直接返回</span></span><br><span class="line">        <span class="title function_">postOrder</span>(node.<span class="property">left</span>);     <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="title function_">postOrder</span>(node.<span class="property">right</span>);    <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        res.<span class="title function_">push</span>(node.<span class="property">val</span>);       <span class="comment">// 访问根节点并将值加入结果数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">postOrder</span>(root);  <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">    <span class="keyword">return</span> res;       <span class="comment">// 返回遍历结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxDepth</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;               <span class="comment">// 如果节点为空，则深度为 0</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">maxDepth</span>(root.<span class="property">left</span>);     <span class="comment">// 递归计算左子树的深度</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">maxDepth</span>(root.<span class="property">right</span>);   <span class="comment">// 递归计算右子树的深度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(left, right) + <span class="number">1</span>;   <span class="comment">// 取左、右子树的最大深度并加 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p>层次遍历（广度优先遍历）的核心思想是逐层处理节点，即先处理根节点，再处理第一层的所有节点，接着处理第二层的所有节点，以此类推。为了实现这种遍历方式，通常使用队列来帮助记录当前层和下一层的节点。</p>
<ol>
<li><strong>初始化</strong>：<ul>
<li>如果根节点为空，直接返回空数组。</li>
<li>使用队列（FIFO，先进先出）数据结构来辅助层次遍历。将根节点加入队列。</li>
<li>初始化一个结果数组 <code>res</code>，用于存储每一层的节点值。</li>
</ul>
</li>
<li><strong>循环处理每一层</strong>：<ul>
<li>当队列不为空时，继续循环。</li>
<li>记录当前队列的长度 <code>size</code>，即当前层的节点数量。</li>
<li>初始化一个数组 <code>cur</code>，用于存储当前层的节点值。</li>
</ul>
</li>
<li><strong>处理当前层的每个节点</strong>：<ul>
<li>使用 <code>for</code> 循环遍历当前层的每个节点（循环次数为 <code>size</code>）。</li>
<li>从队列中取出一个节点，将其值加入 <code>cur</code> 数组。</li>
<li>如果该节点有左子节点，则将左子节点加入队列。</li>
<li>如果该节点有右子节点，则将右子节点加入队列。</li>
</ul>
</li>
<li><strong>保存当前层的结果</strong>：<ul>
<li>将当前层的节点值数组 <code>cur</code> 加入结果数组 <code>res</code>。</li>
</ul>
</li>
<li><strong>返回结果</strong>：<ul>
<li>当所有节点都处理完毕后，<code>while</code> 循环结束，返回结果数组 <code>res</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];   <span class="comment">// 如果 root 为空（即树为空），则返回一个空数组。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> queue = [root];     <span class="comment">// 初始化一个队列（数组）并将根节点 root 放入其中。这个队列用于广度优先遍历（层次遍历）。</span></span><br><span class="line">    <span class="keyword">let</span> res = [];           <span class="comment">// 初始化一个空数组 res，用于存储最终的层次遍历结果。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;  <span class="comment">// 开始一个 while 循环，只要队列 queue 中还有节点，就继续执行循环。</span></span><br><span class="line">        <span class="keyword">let</span> size = queue.<span class="property">length</span>;    <span class="comment">// 记录当前队列的长度 size，表示当前层的节点数量。</span></span><br><span class="line">        <span class="keyword">let</span> cur = [];               <span class="comment">// 初始化一个空数组 cur，用于存储当前层的节点值。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;   <span class="comment">// 开始一个 for 循环，遍历当前层的所有节点。</span></span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>();      <span class="comment">// 从队列 queue 中取出第一个节点 node。</span></span><br><span class="line">            cur.<span class="title function_">push</span>(node.<span class="property">val</span>);            <span class="comment">// 将当前节点的值 node.val 添加到当前层的结果数组 cur 中。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);    <span class="comment">// 如果当前节点 node 有左子节点，则将左子节点添加到队列 queue 中。</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);  <span class="comment">// 如果当前节点 node 有右子节点，则将右子节点添加到队列 queue 中.</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(cur);  <span class="comment">// 当前层所有节点遍历完毕后，将当前层的结果数组 cur 添加到最终结果数组 res 中。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;         <span class="comment">// while 循环结束后，所有层次的节点都已处理完毕，返回最终的结果数组 res。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于层次遍历（广度优先遍历）二叉树，时间复杂度的分析如下：</p>
<ul>
<li>每个节点在 <code>queue</code> 中最多进队列和出队列各一次，因此每个节点被处理的次数是常数级的。</li>
<li>假设二叉树有 <code>n</code> 个节点，则总的处理时间为 <code>O(n)</code>。</li>
</ul>
<p>算法的时间复杂度是 <code>O(n)</code>，其中 <code>n</code> 是二叉树中的节点总数。</p>
<h2 id="将有序的数组转换成二叉搜索树"><a href="#将有序的数组转换成二叉搜索树" class="headerlink" title="将有序的数组转换成二叉搜索树"></a>将有序的数组转换成二叉搜索树</h2><p>给定一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵平衡二叉搜索树。</p>
<p>将一个已排序的整数数组转换为平衡二叉搜索树（BST）的问题可以通过递归的方式解决。核心思想是找到数组的中间元素作为根节点，然后将数组的左半部分作为左子树，右半部分作为右子树，递归地进行下去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 辅助函数，递归构建二叉搜索树</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">buildBST</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">        <span class="comment">// 基本条件：如果左边界超过右边界，返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到当前子数组的中间元素作为根节点</span></span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">buildBST</span>(left, mid - <span class="number">1</span>);</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">buildBST</span>(mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组的左边界到右边界构建 BST</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">buildBST</span>(<span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是数组的长度。每个元素在递归过程中只访问一次。</li>
<li><strong>空间复杂度</strong>：<code>O(log n)</code>，递归调用的最大深度是树的高度，对于平衡二叉树高度为 <code>log n</code>。</li>
</ul>
<p>这种方法通过递归和分治的思想，将一个排序数组转换为一棵平衡的二叉搜索树，从而实现了高效的构建过程。</p>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转成一个排序的双向链表。</p>
<p>要求：空间复杂度O(1)（即在原树上操作），时间复杂度 O(n)</p>
<p>您正在实现将二叉搜索树转换为双向链表的函数 <code>Convert</code>。以下是完整的代码实现，使用中序遍历的方法来将二叉搜索树转换成一个有序的双向链表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Convert</span>(<span class="params">pRootOfTree</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRootOfTree) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;   <span class="comment">// 用于存储双向链表的头节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;   <span class="comment">// 用于记录上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">left</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            head = node;  <span class="comment">// 第一个访问的节点作为头节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.<span class="property">right</span> = node;  <span class="comment">// 将前一个节点的 right 指向当前节点</span></span><br><span class="line">            node.<span class="property">left</span> = prev;   <span class="comment">// 当前节点的 left 指向前一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;  <span class="comment">// 更新 prev 为当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序遍历右子树</span></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">inOrder</span>(pRootOfTree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;  <span class="comment">// 返回双向链表的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>定义变量</strong>：<code>head</code> 作为双向链表的头节点，<code>prev</code> 记录遍历时的前一个节点。</li>
<li><strong>中序遍历构建链表</strong>：通过中序遍历函数 <code>inOrder</code>，按照左 -&gt; 根 -&gt; 右的顺序访问节点。</li>
<li><strong>连接节点</strong>：<ul>
<li>如果 <code>head</code> 为 <code>null</code>，说明是访问的第一个节点，将其设为链表头节点。</li>
<li>否则，连接 <code>prev</code> 和当前节点：<code>prev.right</code> 指向当前节点，<code>current.left</code> 指向 <code>prev</code>。</li>
</ul>
</li>
<li><strong>返回结果</strong>：返回链表的头节点 <code>head</code>。</li>
</ol>
<p>这段代码会将二叉搜索树转换为一个有序的双向链表。</p>
<h2 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h2><p>给定一个二叉树，确定他是否是一个完全二叉树。</p>
<ol>
<li>使用层序遍历（广度优先搜索，BFS）从根节点开始，逐层访问节点。</li>
<li>遇到空节点后，<strong>所有后续节点都必须是空节点</strong>。如果遇到非空节点，说明这不是一棵完全二叉树。</li>
<li>如果在遍历过程中，发现一个节点缺少子节点但后续节点还存在子节点，说明不是完全二叉树。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isCompleteTree</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 空树是完全二叉树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> queue = [root];  <span class="comment">// 使用队列进行层序遍历</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;    <span class="comment">// 标志是否遇到了空节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遇到了空节点</span></span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果遇到非空节点，但之前已经遇到过空节点，说明这不是完全二叉树</span></span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将左右子节点加入队列</span></span><br><span class="line">            queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">            queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 遍历结束，没有违反完全二叉树的性质</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>初始化</strong>：<ul>
<li>使用队列 <code>queue</code> 进行层序遍历，从根节点开始。</li>
<li><code>flag</code> 用来标记是否遇到空节点。</li>
</ul>
</li>
<li><strong>层序遍历</strong>：<ul>
<li>从队列中取出一个节点，如果该节点为空，设置 <code>flag</code> 为 <code>true</code>。</li>
<li>如果 <code>flag</code> 已经被设置为 <code>true</code>，但后续还遇到非空节点，则说明这不是完全二叉树，直接返回 <code>false</code>。</li>
</ul>
</li>
<li><strong>结束条件</strong>：<ul>
<li>遍历完所有节点后，如果没有违反完全二叉树的性质，返回 <code>true</code>。</li>
</ul>
</li>
</ol>
<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h2><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。只需要考虑其平衡性，不需要考虑其是不是排序二叉树。</p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<blockquote>
<p>判断一个二叉树是否是<strong>平衡二叉树</strong>（Balanced Binary Tree），通常是指该二叉树中的每一个节点的左右子树的高度差不超过 1。也就是说，对于每一个节点，其左右子树的高度之差的绝对值不能超过 1，且它的左右子树也都是平衡二叉树。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树的节点结构</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TreeNode</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为平衡二叉树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isBalanced</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个辅助函数来计算树的高度，并判断是否平衡</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">height</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="comment">// 空节点的高度为 0</span></span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左子树的高度</span></span><br><span class="line">        <span class="keyword">let</span> leftHeight = <span class="title function_">height</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight === -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 如果左子树不平衡，直接返回 -1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算右子树的高度</span></span><br><span class="line">        <span class="keyword">let</span> rightHeight = <span class="title function_">height</span>(node.<span class="property">right</span>);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight === -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 如果右子树不平衡，直接返回 -1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断当前节点是否平衡，左右子树高度差不能超过 1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前节点平衡，返回当前子树的高度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果树是平衡的，height 函数返回的值不为 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">height</span>(root) !== -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前序和中序遍历构造二叉树"><a href="#前序和中序遍历构造二叉树" class="headerlink" title="前序和中序遍历构造二叉树"></a>前序和中序遍历构造二叉树</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p>从前序遍历和中序遍历的序列构造一棵二叉树，可以通过递归的方式实现。前序遍历的第一个元素总是根节点，而中序遍历中根节点的位置可以将树分为左子树和右子树。我们可以利用这一点，递归地构造二叉树。下面是实现代码，并带有详细的逐行解释。</p>
<blockquote>
<p> 要从前序遍历和中序遍历的序列构造一棵二叉树，我们可以利用前序遍历的特点，即前序遍历的第一个元素总是当前子树的根节点。而中序遍历可以将树分为左子树和右子树。通过递归地构建子树，我们可以重建整个二叉树。具体步骤如下：</p>
</blockquote>
<ol>
<li><strong>找到根节点</strong>：前序遍历的第一个元素是当前子树的根节点。</li>
<li><strong>划分左右子树</strong>：在中序遍历中找到根节点的位置，根节点左边的部分是左子树，右边的部分是右子树。</li>
<li><strong>递归构建子树</strong>：根据划分结果，递归地构建左子树和右子树。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span> (<span class="params">preorder, inorder</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preorder.<span class="property">length</span> === <span class="number">0</span> || inorder.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历的第一个元素是根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">    <span class="keyword">let</span> rootIndex = inorder.<span class="title function_">indexOf</span>(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据根节点位置划分左右子树的中序遍历</span></span><br><span class="line">    <span class="keyword">let</span> leftInorder = inorder.<span class="title function_">slice</span>(<span class="number">0</span>, rootIndex);  <span class="comment">// 左子树的中序遍历</span></span><br><span class="line">    <span class="keyword">let</span> rightInorder = inorder.<span class="title function_">slice</span>(rootIndex + <span class="number">1</span>);  <span class="comment">// 右子树的中序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树的前序遍历大小等于左子树的中序遍历大小</span></span><br><span class="line">    <span class="keyword">let</span> leftPreorder = preorder.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">1</span> + leftInorder.<span class="property">length</span>);  <span class="comment">// 左子树的前序遍历</span></span><br><span class="line">    <span class="keyword">let</span> rightPreorder = preorder.<span class="title function_">slice</span>(<span class="number">1</span> + leftInorder.<span class="property">length</span>);  <span class="comment">// 右子树的前序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构造左子树和右子树</span></span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">buildTree</span>(leftPreorder, leftInorder);</span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">buildTree</span>(rightPreorder, rightInorder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：<code>O(n^2)</code>，其中 <code>n</code> 是树中节点的数量。在最坏情况下，每次查找中序遍历的根节点位置都需要 <code>O(n)</code> 的时间。</li>
<li><strong>空间复杂度</strong>：<code>O(n)</code>，用于存储构建的二叉树以及递归调用栈的空间。递归的深度最大为树的高度，对于平衡树是 <code>O(log n)</code>，最坏情况下（如链状树）是 <code>O(n)</code>。</li>
</ul>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。</p>
<p>将两棵二叉树合并为一棵二叉树的过程需要遍历两棵树并将它们对应位置的节点值相加。如果某个位置只有一棵树有节点，直接使用该节点。</p>
<p>可以通过递归实现这一过程。递归函数将两个树节点作为参数，如果两个节点都存在，创建一个新的节点，其值为两个节点值之和，然后递归合并它们的左右子树。如果只有一个节点存在，返回该节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeTrees</span>(<span class="params">t1, t2</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果其中一个节点为空，返回另一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (!t1) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (!t2) <span class="keyword">return</span> t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的节点，其值为两个节点值之和</span></span><br><span class="line">    <span class="keyword">let</span> mergedNode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.<span class="property">val</span> + t2.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归合并左右子树</span></span><br><span class="line">    mergedNode.<span class="property">left</span> = <span class="title function_">mergeTrees</span>(t1.<span class="property">left</span>, t2.<span class="property">left</span>);</span><br><span class="line">    mergedNode.<span class="property">right</span> = <span class="title function_">mergeTrees</span>(t1.<span class="property">right</span>, t2.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mergedNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>基本情况</strong>：</p>
<ul>
<li>如果 <code>t1</code> 为空，返回 <code>t2</code>。</li>
<li>如果 <code>t2</code> 为空，返回 <code>t1</code>。</li>
</ul>
</li>
<li><p><strong>合并当前节点</strong>：</p>
<ul>
<li>创建一个新的 <code>TreeNode</code>，其值为 <code>t1.val + t2.val</code>。</li>
</ul>
</li>
<li><p><strong>递归合并子树</strong>：</p>
<ul>
<li>合并左子树：<code>mergedNode.left = mergeTrees(t1.left, t2.left)</code>。</li>
<li>合并右子树：<code>mergedNode.right = mergeTrees(t1.right, t2.right)</code>。</li>
</ul>
</li>
<li><p><strong>返回合并后的树</strong>：</p>
<ul>
<li>返回新的 <code>mergedNode</code>。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>：O(n)，其中 <code>n</code> 是两棵树中节点数较多的那棵树的节点数。每个节点都会被访问一次。</li>
<li><strong>空间复杂度</strong>：O(h)，其中 <code>h</code> 是两棵树中较高的那棵树的高度。递归调用栈的深度等于树的高度。</li>
</ul>
<h2 id="前序和中序的序列构造一棵二叉树并给出右侧视图"><a href="#前序和中序的序列构造一棵二叉树并给出右侧视图" class="headerlink" title="前序和中序的序列构造一棵二叉树并给出右侧视图"></a>前序和中序的序列构造一棵二叉树并给出右侧视图</h2><p>请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图</p>
<p>如输入[1,2,4,5,3],[4,2,5,1,3]时，通过前序遍历的结果[1,2,4,5,3]和中序遍历的结果[4,2,5,1,3]可重建出以下二叉树：[1,3,5]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solve</span>(<span class="params">preOrder, inOrder</span>) &#123;</span><br><span class="line">    <span class="comment">// 构建二叉树的函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">buildTree</span>(<span class="params">preOrder, inOrder</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前序遍历或中序遍历数组为空，返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (!preOrder.<span class="property">length</span> || !inOrder.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前序遍历的第一个元素是根节点的值</span></span><br><span class="line">        <span class="keyword">let</span> rootval = preOrder[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建根节点</span></span><br><span class="line">        <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootval);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">        <span class="keyword">let</span> mid = inOrder.<span class="title function_">indexOf</span>(rootval);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">buildTree</span>(preOrder.<span class="title function_">slice</span>(<span class="number">1</span>, mid + <span class="number">1</span>), inOrder.<span class="title function_">slice</span>(<span class="number">0</span>, mid));</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">buildTree</span>(preOrder.<span class="title function_">slice</span>(mid + <span class="number">1</span>), inOrder.<span class="title function_">slice</span>(mid + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取二叉树右视图的函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">right</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空，返回空数组</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="keyword">let</span> queue = [root];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用队列进行广度优先搜索（BFS）</span></span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> level = queue.<span class="property">length</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">                <span class="comment">// 记录每一层的最后一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (i == level - <span class="number">1</span>) res.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">                <span class="comment">// 将左子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">                <span class="comment">// 将右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建二叉树</span></span><br><span class="line">    <span class="keyword">let</span> root = <span class="title function_">buildTree</span>(preOrder, inOrder);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取二叉树的右视图并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">right</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>构建二叉树</strong>：<ul>
<li>利用前序遍历数组 <code>preOrder</code> 确定根节点。</li>
<li>利用中序遍历数组 <code>inOrder</code> 确定根节点的位置，从而划分左子树和右子树的节点。</li>
<li>递归地构建左子树和右子树。</li>
</ul>
</li>
<li><strong>获取二叉树右视图</strong>：<ul>
<li>使用广度优先搜索（BFS）遍历二叉树。</li>
<li>在每一层中，记录最后一个访问的节点，即为该层的右视图节点。</li>
<li>将这些节点值依次加入结果数组中。</li>
</ul>
</li>
</ol>
<h3 id="时间复杂度分析-3"><a href="#时间复杂度分析-3" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ol>
<li><strong>构建二叉树</strong>：<ul>
<li><code>buildTree</code> 函数中，<code>preOrder</code> 和 <code>inOrder</code> 数组的切片操作每次都需要 <code>O(n)</code> 时间，其中 <code>n</code> 是当前数组的长度。</li>
<li>在最坏情况下，构建树的每个节点都需要 <code>O(n)</code> 次切片操作，因此构建树的总时间复杂度为 <code>O(n^2)</code>。</li>
</ul>
</li>
<li><strong>获取右视图</strong>：<ul>
<li><code>right</code> 函数中，使用 BFS 遍历树，每个节点访问一次，因此时间复杂度为 <code>O(n)</code>。</li>
</ul>
</li>
</ol>
<p>综合起来，构建树的时间复杂度为 <code>O(n^2)</code>，获取右视图的时间复杂度为 <code>O(n)</code>。因此，总的时间复杂度为 <code>O(n^2)</code>。</p>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li><p>节点的左子树只包含小于当前节点的数。</p>
</li>
<li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p>
</li>
<li><p>所有左子树和右子树自身必须也是二叉搜索树。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义递归函数来检查每个节点的合法性</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">valid</span>(<span class="params">node, min, max</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，则是合法的</span></span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点的值不满足 min &lt; node.val &lt; max，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">val</span> &lt;= min || node.<span class="property">val</span> &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左子树和右子树</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">valid</span>(node.<span class="property">left</span>, min, node.<span class="property">val</span>);  <span class="comment">// 对左子树，更新最大值为当前节点值</span></span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">valid</span>(node.<span class="property">right</span>, node.<span class="property">val</span>, max); <span class="comment">// 对右子树，更新最小值为当前节点值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;  <span class="comment">// 左右子树都必须合法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始递归，从根节点开始检查，初始的 min 和 max 为无穷大范围</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">valid</span>(root, -<span class="title class_">Infinity</span>, <span class="title class_">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。数据范围：树上节点数满足 1≤𝑛≤105 1≤<em>n</em>≤105 , 节点值val满足区间 [0,n)</p>
<p>要求：时间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>)</p>
<blockquote>
<p>[!CAUTION]</p>
<p>本题保证二叉树中每个节点的val值均不相同。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">root, o1, o2</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点为空，直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前节点是 o1 或 o2，返回当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> === o1 || root.<span class="property">val</span> === o2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归查找左子树和右子树</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">left</span>, o1, o2);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">right</span>, o1, o2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左右子树分别找到了 o1 和 o2，说明当前节点是最近公共祖先</span></span><br><span class="line">    <span class="keyword">if</span> (left !== <span class="literal">null</span> &amp;&amp; right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只有左子树或右子树找到节点，则返回找到的那个节点</span></span><br><span class="line">    <span class="keyword">return</span> left !== <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>递归终止条件</strong>：<ul>
<li>如果当前节点是 <code>null</code>，说明没有找到 <code>o1</code> 或 <code>o2</code>，返回 <code>null</code>。</li>
<li>如果当前节点的值等于 <code>o1</code> 或 <code>o2</code>，返回当前节点，因为这个节点可能是最近公共祖先或是 <code>o1</code> 或 <code>o2</code> 本身。</li>
</ul>
</li>
<li><strong>递归查找左右子树</strong>：<ul>
<li>对当前节点的左右子树进行递归查找，分别保存左子树和右子树的结果。</li>
</ul>
</li>
<li><strong>公共祖先判断</strong>：<ul>
<li>如果左右子树都不为 <code>null</code>，说明 <code>o1</code> 和 <code>o2</code> 分别位于当前节点的左右子树中，因此当前节点是最近公共祖先。</li>
<li>如果只有左子树或右子树不为 <code>null</code>，则说明 <code>o1</code> 和 <code>o2</code> 都在该子树中，返回该子树的结果。</li>
</ul>
</li>
</ol>
<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<ol>
<li>对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先。</li>
<li>二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</li>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保 p 和 q 的顺序为 min &lt;= max</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(p, q);</span><br><span class="line">    <span class="keyword">let</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(p, q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代方式查找最近公共祖先</span></span><br><span class="line">    <span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点的值大于 max，说明最近公共祖先在左子树</span></span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">val</span> &gt; max) &#123;</span><br><span class="line">            root = root.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点的值小于 min，说明最近公共祖先在右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.<span class="property">val</span> &lt; min) &#123;</span><br><span class="line">            root = root.<span class="property">right</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点的值在 min 和 max 之间或等于其中之一，则当前节点就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果树为空，则返回 null，但通常不需要这一行，因为我们假设树不为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>root.val</code> 大于 <code>max</code>，则说明 <code>p</code> 和 <code>q</code> 都在当前节点的左子树中，继续向左子树查找。</li>
<li>如果 <code>root.val</code> 小于 <code>min</code>，则说明 <code>p</code> 和 <code>q</code> 都在当前节点的右子树中，继续向右子树查找。</li>
<li>否则，<code>root</code> 正好是 <code>p</code> 和 <code>q</code> 的最近公共祖先，直接返回 <code>root.val</code>。</li>
</ul>
<h2 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h2><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p>解题思想是利用二叉搜索树（BST）的性质和中序遍历来找到第 <code>k</code> 小的元素。BST 的一个重要性质是中序遍历其节点会得到一个有序的递增序列。通过中序遍历，我们可以一次性访问 BST 中的所有节点，并且能够按照递增的顺序进行计数，因此第 <code>k</code> 小的元素就是中序遍历过程中第 <code>k</code> 个访问的节点。</p>
<h3 id="方法一：中序遍历"><a href="#方法一：中序遍历" class="headerlink" title="方法一：中序遍历"></a>方法一：中序遍历</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kthSmallest = <span class="keyword">function</span>(<span class="params">root, k</span>) &#123;</span><br><span class="line">    <span class="comment">// 中序遍历结果数组</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义中序遍历函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">left</span>);       <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        res.<span class="title function_">push</span>(node.<span class="property">val</span>);       <span class="comment">// 记录当前节点值</span></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">right</span>);      <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行中序遍历</span></span><br><span class="line">    <span class="title function_">inOrder</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回第 k 小的元素，数组是从 0 开始计数的，所以需要返回 res[k - 1]</span></span><br><span class="line">    <span class="keyword">return</span> res[k - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二–优化方案"><a href="#方法二–优化方案" class="headerlink" title="方法二–优化方案"></a>方法二–优化方案</h3><p>如果只需要找到第 <code>k</code> 小的元素，不需要完整的中序遍历结果数组，可以在遍历过程中直接计数并在找到第 <code>k</code> 小元素时立即返回，避免额外的空间开销。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kthSmallest = <span class="keyword">function</span>(<span class="params">root, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历函数，直接在遍历过程中查找第 k 小的元素</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span> || result !== <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">left</span>);  <span class="comment">// 先遍历左子树</span></span><br><span class="line">        </span><br><span class="line">        count++;  <span class="comment">// 记录当前是第几个节点</span></span><br><span class="line">        <span class="keyword">if</span> (count === k) &#123;</span><br><span class="line">            result = node.<span class="property">val</span>;  <span class="comment">// 找到第 k 个节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">right</span>);  <span class="comment">// 再遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">inOrder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>**<code>count</code>**：用于记录当前遍历到的节点是第几个节点。</li>
<li>**<code>result</code>**：用于保存第 <code>k</code> 小的节点值，一旦找到 <code>k</code> 小的节点值，就可以停止递归。</li>
<li><strong>中序遍历的过程</strong>：在中序遍历过程中，逐个计数，当计数等于 <code>k</code> 时，直接保存当前节点值并停止遍历。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>：仍然是 O(n)，最坏情况下需要遍历所有节点才能找到第 <code>k</code> 小的节点。</p>
</li>
<li><p><strong>空间复杂度</strong>：O(h)，其中 <code>h</code> 是树的高度，递归栈的空间复杂度等于树的高度，最坏情况下是 O(n)。</p>
</li>
</ul>
<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。差值是一个正数，其数值等于两值之差的绝对值。</p>
<ol>
<li><strong>中序遍历二叉搜索树</strong>：通过递归或迭代的方式对树进行中序遍历，得到一个按顺序排列的数组 <code>res</code>。</li>
<li><strong>计算最小差值</strong>：遍历数组 <code>res</code>，计算相邻两个值的差值，找到最小的差值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 中序遍历得到的结果数组</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">left</span>);      <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        res.<span class="title function_">push</span>(node.<span class="property">val</span>);      <span class="comment">// 记录当前节点的值</span></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">right</span>);     <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行中序遍历</span></span><br><span class="line">    <span class="title function_">inOrder</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算最小的差值</span></span><br><span class="line">    <span class="keyword">let</span> minDiff = <span class="title class_">Infinity</span>;      <span class="comment">// 初始化最小差值为无穷大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; res.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = res[i] - res[i - <span class="number">1</span>];  <span class="comment">// 计算相邻节点的差值</span></span><br><span class="line">        minDiff = <span class="title class_">Math</span>.<span class="title function_">min</span>(tmp, minDiff);  <span class="comment">// 更新最小差值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minDiff;  <span class="comment">// 返回最小差值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是二叉树的节点个数。我们需要遍历整个树来获得所有节点值。</li>
<li><strong>空间复杂度</strong>：O(n)，因为我们需要一个数组来保存所有节点值。</li>
</ul>
<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p>
<blockquote>
<p> 二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）。</p>
<p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
</blockquote>
<ol>
<li><strong>序列化（Serialize）</strong>：<ul>
<li>使用广度优先搜索（BFS）来遍历二叉树，将每个节点的值按层序加入到字符串中。</li>
<li>对于空节点，用特殊符号（如 <code>&quot;#&quot;</code>）来表示。</li>
<li>结果是一个字符串表示的二叉树。</li>
</ul>
</li>
<li><strong>反序列化（Deserialize）</strong>：<ul>
<li>根据序列化的字符串重新构建二叉树，使用层序遍历的方式，从根节点开始构造树。</li>
<li>使用队列来保持当前正在处理的节点，依次为每个节点构建左右子树。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化二叉树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Serialize</span>(<span class="params">pRoot</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;  <span class="comment">// 空树用 &quot;#&quot; 表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> queue = [pRoot];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(node.<span class="property">val</span>);  <span class="comment">// 保存当前节点的值</span></span><br><span class="line">            queue.<span class="title function_">push</span>(node.<span class="property">left</span>);  <span class="comment">// 添加左子节点</span></span><br><span class="line">            queue.<span class="title function_">push</span>(node.<span class="property">right</span>); <span class="comment">// 添加右子节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(<span class="string">&quot;#&quot;</span>);  <span class="comment">// 空节点用 &quot;#&quot; 表示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>);  <span class="comment">// 以逗号分隔节点值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化字符串为二叉树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Deserialize</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s === <span class="string">&quot;#&quot;</span>) <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 空树情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> values = s.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);  <span class="comment">// 将字符串分割为数组</span></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="built_in">parseInt</span>(values[<span class="number">0</span>]));  <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;  <span class="comment">// 指向当前要处理的节点值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; i &lt; values.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>();  <span class="comment">// 当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (values[i] !== <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">            node.<span class="property">left</span> = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="built_in">parseInt</span>(values[i]));</span><br><span class="line">            queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; values.<span class="property">length</span> &amp;&amp; values[i] !== <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">            node.<span class="property">right</span> = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="built_in">parseInt</span>(values[i]));</span><br><span class="line">            queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;  <span class="comment">// 返回根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>**<code>Serialize(pRoot)</code>**：<ul>
<li>使用一个队列（<code>queue</code>）来进行层序遍历。</li>
<li>每当处理一个节点时，将它的值保存到 <code>result</code> 数组中，并将它的左、右子节点加入队列。</li>
<li>如果遇到空节点，则保存特殊符号 <code>&quot;#&quot;</code>。</li>
<li>最终将 <code>result</code> 数组转换为字符串并返回。</li>
</ul>
</li>
<li>**<code>Deserialize(s)</code>**：<ul>
<li>将序列化后的字符串分割为一个数组 <code>values</code>，然后用队列帮助重建树。</li>
<li>首先创建根节点，将其加入队列。</li>
<li>依次从数组中读取值，为当前节点的左、右子节点赋值。</li>
<li>如果遇到 <code>&quot;#&quot;</code>，表示该节点为空。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>：O(n)，其中 <code>n</code> 是二叉树中的节点数。无论是序列化还是反序列化，我们都需要遍历每个节点一次。</li>
<li><strong>空间复杂度</strong>：O(n)，需要使用队列和存储结果的数组，空间复杂度与节点数成正比。</li>
</ul>
<h2 id="二叉树的右侧视图"><a href="#二叉树的右侧视图" class="headerlink" title="二叉树的右侧视图"></a>二叉树的右侧视图</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>该算法的目的是获取二叉树的右视图，即从右侧看二叉树时能看到的所有节点。解题的核心思想是使用广度优先搜索（BFS），逐层遍历二叉树，并记录每一层的最后一个节点。</p>
<ol>
<li><strong>广度优先搜索（BFS）</strong>：<ul>
<li>BFS 是一种逐层遍历树或图的算法。对于树的层次遍历，BFS 非常适用，因为它能够按层次逐层访问节点。</li>
<li>使用队列来实现 BFS，因为队列是先进先出（FIFO）的数据结构，适合按顺序处理节点。</li>
</ul>
</li>
<li><strong>逐层遍历并记录最后一个节点</strong>：<ul>
<li>在每一层的遍历中，记录该层的最后一个节点。这个节点就是从右侧视角能看到的节点。</li>
<li>使用一个变量 <code>lastNode</code> 来保存每层最后一个节点。</li>
<li>遍历完每一层后，将 <code>lastNode</code> 的值添加到结果数组 <code>res</code> 中。</li>
</ul>
</li>
<li><strong>节点入队和出队</strong>：<ul>
<li>从队列中取出当前层的所有节点，并将它们的左子节点和右子节点依次加入队列，确保下一层的节点能够被处理。</li>
</ul>
</li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><strong>输入检查</strong>：<ul>
<li>如果根节点为空，直接返回空数组，因为没有节点可以被看到。</li>
</ul>
</li>
<li><strong>初始化队列和结果数组</strong>：<ul>
<li>队列初始包含根节点，用于开始层次遍历。</li>
<li>结果数组用于保存每层的最右侧节点值。</li>
</ul>
</li>
<li><strong>广度优先搜索</strong>：<ul>
<li>使用 <code>while</code> 循环进行 BFS，只要队列不为空，就继续处理节点。</li>
</ul>
</li>
<li><strong>逐层处理</strong>：<ul>
<li><code>for</code> 循环遍历当前层的所有节点，使用 <code>levelSize</code> 记录当前层的节点数。</li>
<li>每次从队列中取出一个节点，并将其左子节点和右子节点加入队列。</li>
<li><code>lastNode</code> 保存当前层的最后一个节点。</li>
</ul>
</li>
<li><strong>保存结果</strong>：<ul>
<li>每层处理完后，将 <code>lastNode</code> 的值添加到结果数组中。</li>
</ul>
</li>
<li><strong>返回结果</strong>：<ul>
<li>最终返回结果数组，其中包含从右侧视角能看到的所有节点值。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rightSideView = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果树为空，返回空数组</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化队列和结果数组</span></span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当队列不为空时，进行层次遍历</span></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录当前层的节点数</span></span><br><span class="line">        <span class="keyword">let</span> levelSize = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="comment">// 用于保存当前层的最后一个节点</span></span><br><span class="line">        <span class="keyword">let</span> lastNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前层的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 从队列中取出当前节点</span></span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="comment">// 更新当前层的最后一个节点</span></span><br><span class="line">            lastNode = node;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前节点的左子节点加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">            <span class="comment">// 将当前节点的右子节点加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前层的最后一个节点值加入结果数组</span></span><br><span class="line">        res.<span class="title function_">push</span>(lastNode.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>时间复杂度</strong>：<code>O(N)</code>，其中 <code>N</code> 是树中的节点总数。每个节点被访问一次，因此时间复杂度为 <code>O(N)</code>。</p>
</li>
<li><p><strong>空间复杂度</strong>：<code>O(D)</code>，其中 <code>D</code> 是树的最大深度。在最坏情况下，队列中可能包含一层的所有节点，因此空间复杂度为 <code>O(D)</code>。</p>
</li>
</ul>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<blockquote>
<p> 要求： 空间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>) 。本题也有原地操作，即空间复杂度 𝑂(1)<em>O</em>(1) 的解法，时间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>)</p>
</blockquote>
<h3 id="方法1–递归"><a href="#方法1–递归" class="headerlink" title="方法1–递归"></a>方法1–递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Mirror</span>(<span class="params">pRoot</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点为空，返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (!pRoot) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地处理左子树和右子树</span></span><br><span class="line">    <span class="title class_">Mirror</span>(pRoot.<span class="property">left</span>);</span><br><span class="line">    <span class="title class_">Mirror</span>(pRoot.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换左右子树</span></span><br><span class="line">    <span class="keyword">let</span> temp = pRoot.<span class="property">left</span>;</span><br><span class="line">    pRoot.<span class="property">left</span> = pRoot.<span class="property">right</span>;</span><br><span class="line">    pRoot.<span class="property">right</span> = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)，其中 <code>n</code> 是二叉树中的节点数。每个节点都需要被访问一次，因此时间复杂度为 O(n)。</li>
<li><strong>空间复杂度</strong>：O(h)，其中 <code>h</code> 是树的高度。递归调用栈的深度等于树的高度，最坏情况下为 O(n)（完全不平衡的树），最佳情况下为 O(log n)（完全平衡的树）。</li>
</ul>
<h3 id="方法2–迭代实现（使用栈）"><a href="#方法2–迭代实现（使用栈）" class="headerlink" title="方法2–迭代实现（使用栈）"></a>方法2–迭代实现（使用栈）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mirror</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        <span class="keyword">let</span> temp = node.<span class="property">left</span>;</span><br><span class="line">        node.<span class="property">left</span> = node.<span class="property">right</span>;</span><br><span class="line">        node.<span class="property">right</span> = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点添加到栈中</span></span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">left</span>) stack.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">right</span>) stack.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>递归实现</strong>：</p>
<ul>
<li><strong>基本情况</strong>：如果节点为空，返回 <code>null</code>。</li>
<li><strong>交换左右子树</strong>：将当前节点的左子树和右子树进行交换。</li>
<li><strong>递归处理左右子树</strong>：对左右子树分别进行递归处理。</li>
</ul>
</li>
<li><p><strong>迭代实现</strong>：</p>
<ul>
<li>使用栈来保存需要处理的节点。</li>
<li>每次从栈中弹出一个节点，交换其左右子树，然后将左右子节点推入栈中，继续处理。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>：O(n)，其中 <code>n</code> 是二叉树中的节点数。每个节点都需要访问一次，因此时间复杂度为 O(n)。</li>
<li><strong>空间复杂度</strong>：O(n)，因为使用了栈来存储节点。最坏情况下，栈中可能需要保存所有节点，因此空间复杂度为 O(n)。</li>
</ul>
<h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>
<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>
<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>
<p>这道题的解题思想是通过<strong>深度优先搜索 (DFS)</strong> 来计算二叉树的直径。二叉树的直径定义为任意两个节点路径中最远距离的节点数目。我们通过递归的方式计算每个节点的左右子树的深度，并更新当前的最大直径。</p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化结果为 1，因为最终会减去 1</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义递归函数 depth，用于计算节点的深度</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">depth</span>(<span class="params">rootNode</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果节点为空，返回深度为 0</span></span><br><span class="line">        <span class="keyword">if</span> (!rootNode) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左子树的深度</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">depth</span>(rootNode.<span class="property">left</span>);</span><br><span class="line">        <span class="comment">// 递归计算右子树的深度</span></span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">depth</span>(rootNode.<span class="property">right</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新最大直径，计算左右子树深度之和再加上当前节点</span></span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, left + right + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回当前节点的深度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从根节点开始递归</span></span><br><span class="line">    <span class="title function_">depth</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回最大直径减去 1（因为直径是路径上的节点数减去 1）</span></span><br><span class="line">    <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>**深度优先搜索 (DFS)**：使用 DFS 递归计算每个节点的深度。</li>
<li><strong>最大直径更新</strong>：在递归过程中，计算左右子树的深度之和，并不断更新最大直径。</li>
<li><strong>递归返回深度</strong>：每个节点的深度为其左右子树深度的最大值加一。</li>
</ol>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><strong>时间复杂度</strong>：每个节点都遍历一次，所以时间复杂度是 (O(N))，其中 (N) 是二叉树的节点数。</li>
<li><strong>空间复杂度</strong>：由于递归调用栈的深度为树的高度，最坏情况下，空间复杂度为 (O(N))（当树退化为链表时）。</li>
</ul>
<p>通过这种方法，我们能够有效地计算出二叉树的直径，并且代码具有较高的效率和可读性。</p>
<h2 id="二叉树转为链表"><a href="#二叉树转为链表" class="headerlink" title="二叉树转为链表"></a>二叉树转为链表</h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><strong>后序遍历二叉树</strong>：<ul>
<li>采用后序遍历（右 -&gt; 左 -&gt; 根）的方式遍历二叉树，这样可以确保在修改当前节点之前，右子树和左子树已经被处理。</li>
<li>后序遍历的原因是我们要从下到上，从右到左地处理节点，这样可以确保每个节点的右指针正确指向下一个节点。</li>
</ul>
</li>
<li><strong>修改节点指针</strong>：<ul>
<li>将当前节点的右指针指向上一个处理过的节点。</li>
<li>将当前节点的左指针设为 <code>null</code>，因为在链表中不需要左指针。</li>
<li>更新 <code>pre</code> 为当前节点，以便下一个节点能够正确地指向它。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">list</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先处理右子树</span></span><br><span class="line">        <span class="title function_">list</span>(node.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再处理左子树</span></span><br><span class="line">        <span class="title function_">list</span>(node.<span class="property">left</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点的右指针指向 pre</span></span><br><span class="line">        node.<span class="property">right</span> = pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点的左指针设为 null</span></span><br><span class="line">        node.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 pre 为当前节点</span></span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">list</span>(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是二叉树的节点数。每个节点被访问一次，且每个节点的指针修改操作都是常数时间操作。</li>
<li><strong>空间复杂度</strong>：<code>O(h)</code>，其中 <code>h</code> 是二叉树的高度。空间复杂度主要取决于递归调用栈的深度。对于平衡二叉树，空间复杂度为 <code>O(log n)</code>；对于退化为链表的二叉树，空间复杂度为 <code>O(n)</code>。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这段代码通过后序遍历（先右子树，再左子树，最后根节点）处理二叉树中的每个节点，并将二叉树原地转换为链表形式。每次遍历到一个节点时，将其右指针指向上一个访问过的节点，左指针设为 <code>null</code>，然后更新 <code>pre</code> 为当前节点。最终，二叉树被转换为一个按先序遍历顺序的链表。</p>
<h2 id="二叉树的路径总和"><a href="#二叉树的路径总和" class="headerlink" title="二叉树的路径总和"></a>二叉树的路径总和</h2><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<h3 id="解题思想-1"><a href="#解题思想-1" class="headerlink" title="解题思想"></a>解题思想</h3><p>我们需要找到二叉树中所有路径的和为给定的 <code>targetSum</code> 的路径条数。为了实现这一目标，我们需要在树中每个节点进行深度优先搜索（DFS），并从每个节点开始，检查所有可能的路径是否满足条件。这样做可以确保我们不会遗漏任何可能的路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="keyword">function</span> (<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果根节点为空，则没有路径，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个变量 count 来记录符合条件的路径条数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个内部函数 depth 来计算从当前节点开始的所有路径的和</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">depth</span>(<span class="params">node, cur</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点的值加到当前路径和 cur 中</span></span><br><span class="line">        cur += node.<span class="property">val</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前路径和等于 targetSum，则路径条数 count 加 1</span></span><br><span class="line">        <span class="keyword">if</span> (cur === targetSum) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用 depth 函数，继续检查左子节点和右子节点</span></span><br><span class="line">        <span class="title function_">depth</span>(node.<span class="property">left</span>, cur);</span><br><span class="line">        <span class="title function_">depth</span>(node.<span class="property">right</span>, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个内部函数 dfs 用于遍历整棵树，从每个节点开始调用 depth 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前节点开始，调用 depth 函数，初始路径和为 0</span></span><br><span class="line">        <span class="title function_">depth</span>(node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用 dfs 函数，继续遍历左子树和右子树</span></span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从根节点开始调用 dfs 函数，遍历整棵树</span></span><br><span class="line">    <span class="title function_">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回符合条件的路径条数 count</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol>
<li>对于每个节点，需要调用 <code>depth</code> 函数来计算从该节点开始的所有路径和。<code>depth</code> 函数在最坏情况下会访问树中的每个节点，因此其时间复杂度为 <code>O(N)</code>，其中 <code>N</code> 是节点总数。</li>
<li><code>dfs</code> 函数需要遍历整棵树中的每个节点，因此其时间复杂度也为 <code>O(N)</code>。</li>
</ol>
<p>总的时间复杂度为 <code>O(N^2)</code>，因为对于树中的每个节点，我们都执行了一次 <code>depth</code> 函数的完整遍历。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度主要由递归调用栈的深度决定。在最坏情况下（即树为单链表时），递归深度为 <code>N</code>，因此空间复杂度为 <code>O(N)</code>。</p>
<p>总结：该算法通过遍历每个节点并从每个节点开始检查所有可能路径，最终找到所有和为 <code>targetSum</code> 的路径条数，其时间复杂度为 <code>O(N^2)</code>，空间复杂度为 <code>O(N)</code>。</p>
<h3 id="解法二–前缀和"><a href="#解法二–前缀和" class="headerlink" title="解法二–前缀和"></a>解法二–前缀和</h3><h3 id="解题思想-2"><a href="#解题思想-2" class="headerlink" title="解题思想"></a>解题思想</h3><p>该算法使用深度优先搜索（DFS）遍历整棵树，并使用一个哈希表 <code>prefixSum</code> 来记录从根节点到当前节点的路径和的出现次数。通过计算当前路径和与目标路径和的差值，可以快速判断是否存在从某个节点到当前节点的路径和等于 <code>targetSum</code>。这使得算法在一次遍历过程中即可计算出所有符合条件的路径条数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="keyword">function</span> (<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;  <span class="comment">// 记录路径条数</span></span><br><span class="line">    <span class="keyword">let</span> prefixSum = <span class="keyword">new</span> <span class="title class_">Map</span>();  <span class="comment">// 用于存储路径和的哈希表</span></span><br><span class="line">    prefixSum.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 初始化哈希表，路径和为0的出现次数为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node, currentSum</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前路径和</span></span><br><span class="line">        currentSum += node.<span class="property">val</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算从根节点到当前节点的路径和与 targetSum 的差值</span></span><br><span class="line">        <span class="keyword">let</span> neededSum = currentSum - targetSum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希表中存在这个差值，则表示存在从某个节点到当前节点的路径和为 targetSum</span></span><br><span class="line">        <span class="keyword">if</span> (prefixSum.<span class="title function_">has</span>(neededSum)) &#123;</span><br><span class="line">            count += prefixSum.<span class="title function_">get</span>(neededSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新哈希表中当前路径和的出现次数</span></span><br><span class="line">        prefixSum.<span class="title function_">set</span>(currentSum, (prefixSum.<span class="title function_">get</span>(currentSum) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历左子树和右子树</span></span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">left</span>, currentSum);</span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">right</span>, currentSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯到父节点之前，减去当前路径和的出现次数</span></span><br><span class="line">        prefixSum.<span class="title function_">set</span>(currentSum, prefixSum.<span class="title function_">get</span>(currentSum) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dfs</span>(root, <span class="number">0</span>);  <span class="comment">// 从根节点开始遍历，初始路径和为0</span></span><br><span class="line">    <span class="keyword">return</span> count;  <span class="comment">// 返回符合条件的路径条数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>单次遍历整棵树，时间复杂度为 <code>O(N)</code>，其中 <code>N</code> 是节点总数。</li>
</ul>
<h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li>主要由哈希表的大小和递归调用栈的深度决定。最坏情况下，空间复杂度为 <code>O(N)</code>。</li>
</ul>
<h2 id="二叉树的最近路径"><a href="#二叉树的最近路径" class="headerlink" title="二叉树的最近路径"></a>二叉树的最近路径</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root === p || root === q) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">left</span>, p, q);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">right</span>, p, q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left || right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度分析-4"><a href="#时间复杂度分析-4" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>时间复杂度主要取决于对二叉树的遍历，因为需要在树中搜索节点 <code>p</code> 和 <code>q</code>，并找到它们的最近公共祖先。</p>
<ul>
<li><strong>最坏情况下</strong>，我们需要遍历整棵二叉树，因为 <code>p</code> 和 <code>q</code> 可能分别位于树的最深层，此时时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是二叉树中节点的个数。</li>
</ul>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p>空间复杂度包括递归调用的栈空间以及递归函数本身使用的空间。</p>
<ul>
<li><strong>递归深度</strong>：在最坏情况下，递归调用的深度可以达到树的高度。对于平衡二叉树，递归深度为 <code>O(log n)</code>；对于最坏情况下的不平衡二叉树，递归深度为 <code>O(n)</code>。</li>
<li><strong>额外空间</strong>：除了递归调用的栈空间外，递归函数本身使用的额外空间很小，是常数级别的空间，因此空间复杂度主要取决于递归调用的栈空间。</li>
</ul>
<p>综合考虑，改进后的代码在时间复杂度上是 <code>O(n)</code>，在空间复杂度上是 <code>O(log n)</code> 到 <code>O(n)</code>，具体取决于树的形状（平衡还是不平衡）。</p>
<h2 id="二叉树最大的路径和"><a href="#二叉树最大的路径和" class="headerlink" title="二叉树最大的路径和"></a>二叉树最大的路径和</h2><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxPathSum = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxSum = -<span class="title class_">Infinity</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">maxPathSumRecursive</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左右子树的最大路径和（负值的话取0）</span></span><br><span class="line">        <span class="keyword">let</span> leftSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">maxPathSumRecursive</span>(node.<span class="property">left</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> rightSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">maxPathSumRecursive</span>(node.<span class="property">right</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算以当前节点为根节点的最大路径和</span></span><br><span class="line">        <span class="keyword">let</span> currentSum = node.<span class="property">val</span> + leftSum + rightSum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新全局最大路径和</span></span><br><span class="line">        maxSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxSum, currentSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回以当前节点为根节点的最大路径和（可以返回左子树、右子树或左右子树的最大路径和）</span></span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">val</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(leftSum, rightSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归函数计算最大路径和</span></span><br><span class="line">    <span class="title function_">maxPathSumRecursive</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最大路径和</span></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在分析这段代码的时间复杂度时，我们可以考虑以下几个方面：</p>
<h3 id="时间复杂度分析-5"><a href="#时间复杂度分析-5" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ol>
<li><p><strong>递归函数的调用次数</strong>：</p>
<ul>
<li>对于每个节点，递归函数 <code>maxPathSumRecursive</code> 都会被调用一次。因此，时间复杂度与节点的数量成正比，即为 <code>O(n)</code>，其中 <code>n</code> 是二叉树中节点的个数。</li>
</ul>
</li>
<li><p><strong>每次递归的时间复杂度</strong>：</p>
<ul>
<li>在每次调用 <code>maxPathSumRecursive</code> 时，我们执行了常数时间的计算操作（比如比较、加法、取最大值等）。因此，每个递归调用的时间复杂度可以视为 <code>O(1)</code>。</li>
</ul>
</li>
<li><p><strong>总体时间复杂度</strong>：</p>
<ul>
<li>综合以上两点，整个算法的时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是二叉树中节点的个数。这是因为我们对每个节点都进行了一定数量的常数时间操作，总共进行了 <code>n</code> 次这样的操作。</li>
</ul>
</li>
</ol>
<h3 id="空间复杂度分析-1"><a href="#空间复杂度分析-1" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><ol>
<li><p><strong>递归调用的空间复杂度</strong>：</p>
<ul>
<li>在递归调用的过程中，会使用系统栈来存储递归调用的信息，因此空间复杂度取决于递归调用的深度。</li>
<li>在最坏情况下，二叉树是一个链式结构（类似链表），递归深度可以达到 <code>O(n)</code>，此时空间复杂度为 <code>O(n)</code>。</li>
<li>在平衡二叉树的情况下，递归深度为 <code>O(log n)</code>，因此空间复杂度为 <code>O(log n)</code>。</li>
</ul>
</li>
<li><p><strong>额外的空间</strong>：</p>
<ul>
<li>除了递归调用的栈空间外，算法本身并没有使用额外的辅助空间，因此额外空间复杂度为 <code>O(1)</code>。</li>
</ul>
</li>
</ol>
<p>综合考虑，该算法的时间复杂度为 <code>O(n)</code>，空间复杂度取决于递归调用的深度，最坏情况下为 <code>O(n)</code>，平均情况下为 <code>O(log n)</code>（对于平衡二叉树）。</p>
<h2 id="二叉搜索树与双向链表-1"><a href="#二叉搜索树与双向链表-1" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</p>
<p>将二叉搜索树转换成排序的双向链表的过程可以通过中序遍历来实现。在遍历过程中，将每个节点的左右子指针重新调整为双向链表的前后指针。</p>
<ol>
<li><strong>定义辅助函数</strong>：用来进行中序遍历，并在遍历过程中调整节点指针。</li>
<li><strong>维护双向链表指针</strong>：在遍历过程中，维护一个前驱节点指针 <code>prev</code>，用于调整当前节点的前驱指针。</li>
<li><strong>连接双向链表</strong>：遍历结束后，返回双向链表的头节点。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Convert</span>(<span class="params">pRootOfTree</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRootOfTree) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;  <span class="comment">// 双向链表的头节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;  <span class="comment">// 前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inOrder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">left</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整当前节点的指针</span></span><br><span class="line">        <span class="keyword">if</span> (prev === <span class="literal">null</span>) &#123;</span><br><span class="line">            head = node;  <span class="comment">// 当前节点是头节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.<span class="property">right</span> = node;</span><br><span class="line">            node.<span class="property">left</span> = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;  <span class="comment">// 更新前驱节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">inOrder</span>(pRootOfTree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>**定义辅助函数 <code>inOrder</code>**：进行中序遍历并调整节点指针。</li>
<li><strong>维护双向链表指针</strong>：<ul>
<li><code>prev</code>：用于记录当前节点的前驱节点。</li>
<li><code>head</code>：用于记录双向链表的头节点。</li>
</ul>
</li>
<li><strong>调整节点指针</strong>：<ul>
<li>如果 <code>prev</code> 为 <code>null</code>，说明当前节点是双向链表的头节点。</li>
<li>否则，调整当前节点与前驱节点的指针，使其形成双向链表。</li>
</ul>
</li>
<li><strong>返回结果</strong>：遍历结束后，返回双向链表的头节点 <code>head</code>。</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>二叉树为空时返回 <code>null</code>。</li>
<li>确保在中序遍历过程中正确调整节点指针，使其形成双向链表。</li>
</ul>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><blockquote>
<p>回溯算法是一种基于递归的算法设计技术，用于解决一些组合问题。其核心思想是逐步构建一个解，然后在发现该解不满足条件时，返回到上一步，尝试另一种可能性。这个过程不断重复，直到找到所有可能的解或确定没有解。</p>
</blockquote>
<h3 id="回溯算法的基本步骤"><a href="#回溯算法的基本步骤" class="headerlink" title="回溯算法的基本步骤"></a>回溯算法的基本步骤</h3><ol>
<li><strong>选择</strong>：选择一个可能的选择进行尝试。</li>
<li><strong>约束</strong>：检查当前选择是否满足问题的约束条件。</li>
<li><strong>终止条件</strong>：判断当前选择是否为一个完整的解。</li>
<li><strong>回溯</strong>：如果当前选择不满足条件或不是一个完整的解，回溯到上一步，尝试其他选择。</li>
</ol>
<h3 id="回溯算法的伪代码"><a href="#回溯算法的伪代码" class="headerlink" title="回溯算法的伪代码"></a>回溯算法的伪代码</h3><p>以下是回溯算法的一般伪代码结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function backtrack(solution):</span><br><span class="line">    if solution is a complete and valid solution:</span><br><span class="line">        add solution to the list of solutions</span><br><span class="line">    else:</span><br><span class="line">        for each choice in available choices:</span><br><span class="line">            make a choice</span><br><span class="line">            if choice is valid:</span><br><span class="line">                add choice to the current partial solution</span><br><span class="line">                backtrack(partial solution)</span><br><span class="line">                remove choice from the current partial solution</span><br></pre></td></tr></table></figure>

<h3 id="回溯算法的应用"><a href="#回溯算法的应用" class="headerlink" title="回溯算法的应用"></a>回溯算法的应用</h3><p>回溯算法在许多经典的计算问题中都有应用，包括但不限于以下几个方面：</p>
<ol>
<li><strong>N皇后问题</strong>：在N×N的棋盘上放置N个皇后，使得它们不能互相攻击。</li>
<li><strong>图的着色问题</strong>：为图中的每个节点分配一种颜色，确保相邻节点颜色不同。</li>
<li><strong>数独</strong>：填充数独的解。</li>
<li><strong>旅行商问题</strong>：找到一条经过所有城市并且总距离最短的路径。</li>
</ol>
<h3 id="回溯算法的优缺点"><a href="#回溯算法的优缺点" class="headerlink" title="回溯算法的优缺点"></a>回溯算法的优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>简单易理解，适用于小规模问题。</li>
<li>可以用于生成所有可能的解，保证找到所有可能的解。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>对于大规模问题，回溯算法的时间复杂度可能非常高，因为其本质上是穷举所有可能的解。</li>
<li>需要大量的递归调用，可能导致较高的空间复杂度。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以经典的N皇后问题为例，来说明回溯算法的应用。N皇后问题要求在N×N的棋盘上放置N个皇后，使得它们互相不能攻击。回溯算法的步骤如下：</p>
<ol>
<li>从第一个皇后开始，尝试将其放置在第一行的一个位置。</li>
<li>递归地尝试将下一个皇后放置在下一行的某个位置，同时检查是否与之前放置的皇后冲突。</li>
<li>如果发现冲突，回溯到上一步，尝试其他位置。</li>
<li>重复上述步骤，直到所有皇后都成功放置或者确定无解。</li>
</ol>
<p>通过回溯算法，可以系统地探索所有可能的解决方案，并找到满足条件的所有解。</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。可以 <strong>按任意顺序</strong> 返回答案。</p>
<h3 id="解题思想-3"><a href="#解题思想-3" class="headerlink" title="解题思想"></a>解题思想</h3><ol>
<li><p><strong>回溯算法基本思路</strong>：</p>
<ul>
<li>回溯算法是一种通过尝试所有可能的候选解来解决问题的方法。它适用于求解组合优化问题，其中每一个解都是通过递归构建的。</li>
<li>在本问题中，我们要求生成数组 <code>nums</code> 的所有排列，即不同元素的所有可能顺序组合。</li>
</ul>
</li>
<li><p><strong>具体实现步骤</strong>：</p>
<ul>
<li>使用一个递归函数 <code>backtrack</code> 来构建排列。</li>
<li>使用一个 <code>path</code> 数组来存储当前的排列路径。</li>
<li>使用一个 <code>used</code> 数组来标记每个元素是否已经被使用过。</li>
<li>当 <code>path</code> 的长度等于 <code>nums</code> 的长度时，将 <code>path</code> 加入结果集合 <code>res</code>。</li>
<li>对于每个位置 <code>i</code>，如果 <code>nums[i]</code> 没有被使用过，则将其加入 <code>path</code>，标记为已使用，然后递归调用 <code>backtrack</code>。</li>
<li>递归完成后，回溯：将 <code>path</code> 的最后一个元素移除，将其对应的 <code>used</code> 标记为未使用，以便尝试下一个可能的排列。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>最终，函数返回 <code>res</code>，即包含所有排列的数组。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果数组为空，返回空数组</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果数组，用于存储所有的排列</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">// 用于标记每个元素是否被使用的布尔数组</span></span><br><span class="line">    <span class="keyword">let</span> used = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 当前排列路径</span></span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前路径长度等于nums长度，说明找到一个完整排列</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">length</span> == nums.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前路径的拷贝加入结果集</span></span><br><span class="line">            res.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历nums中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过已使用的元素</span></span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将元素加入当前路径</span></span><br><span class="line">            path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 标记元素为已使用</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 递归调用回溯函数</span></span><br><span class="line">            <span class="title function_">backtrack</span>();</span><br><span class="line">            <span class="comment">// 回溯：移除最后一个元素，并将其标记为未使用</span></span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始回溯</span></span><br><span class="line">    <span class="title function_">backtrack</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度分析-6"><a href="#时间复杂度分析-6" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>：假设数组 <code>nums</code> 的长度为 <code>n</code>，生成所有排列的数量为 <code>n!</code>（即阶乘）。因此，生成所有排列的时间复杂度为 <code>O(n!)</code>。</p>
<ul>
<li>每个排列的构建涉及 <code>n</code> 次选择，每次选择中有 <code>n</code> 个选项，因此总共有 <code>n!</code> 种排列。</li>
<li>在每个排列的构建过程中，需要对 <code>path</code> 的操作（push 和 pop），这些操作的时间复杂度可以视为常数时间，因为 <code>path</code> 最多包含 <code>n</code> 个元素。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：主要是递归调用和存储结果集所需的空间。</p>
<ul>
<li>递归调用的最大深度为 <code>n</code>，因此空间复杂度为 <code>O(n)</code>。</li>
<li>结果集 <code>res</code> 最多包含 <code>n!</code> 个排列，每个排列的长度为 <code>n</code>，因此结果集的空间复杂度为 <code>O(n * n!)</code>。</li>
</ul>
</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>回溯算法是一种递归枚举所有可能性的有效方法，尤其适用于组合优化问题。在本问题中，通过回溯算法可以生成数组的所有排列。虽然时间复杂度是 <code>O(n!)</code>，这在大规模问题上可能会导致性能问题，但在实践中，回溯算法在处理小规模问题时表现良好，并且能够准确地找到所有解。</p>
<h2 id="全排列-1"><a href="#全排列-1" class="headerlink" title="全排列||"></a>全排列||</h2><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
<p>这个问题的解题思想是利用回溯算法生成包含重复元素的全排列，并通过一些条件判断和技巧来确保生成的排列是唯一的。</p>
<h3 id="解题思想："><a href="#解题思想：" class="headerlink" title="解题思想："></a>解题思想：</h3><ol>
<li><p><strong>排序数组</strong>：</p>
<ul>
<li>首先对输入的数组 <code>nums</code> 进行排序，这样相同的元素会相邻排列。排序后的数组有助于在回溯过程中判断重复元素和跳过已经处理过的情况。</li>
</ul>
</li>
<li><p><strong>回溯算法</strong>：</p>
<ul>
<li>使用回溯算法来探索所有可能的排列。回溯算法是一种深度优先搜索（DFS）的应用，通过递归实现。</li>
<li>主要思路是从左到右依次选择未使用过的元素，加入当前排列 <code>cur</code> 中，然后递归处理剩余的元素。如果当前 <code>cur</code> 的长度等于 <code>nums</code> 的长度，则说明找到了一个完整的排列，将其加入结果数组 <code>res</code> 中。</li>
<li>在递归调用之后，需要撤销选择，即将当前加入的元素从 <code>cur</code> 中移除，并将其标记为未使用，以便进行下一次选择。</li>
</ul>
</li>
<li><p><strong>处理重复情况</strong>：</p>
<ul>
<li>使用 <code>used</code> 数组来标记每个位置的元素是否已经被选择过。</li>
<li>在循环中，如果当前元素已经被使用 (<code>used[i] === true</code>)，则跳过该元素。</li>
<li>对于排序后的数组，在判断重复元素时，如果当前元素与上一个元素相同，并且上一个元素未被使用过 (<code>!used[i - 1]</code>)，则跳过当前元素，以确保不会生成重复的排列。</li>
</ul>
</li>
<li><p><strong>递归终止条件</strong>：</p>
<ul>
<li>当 <code>cur</code> 的长度等于 <code>nums</code> 的长度时，将当前排列加入 <code>res</code> 中，并返回，结束当前递归路径。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permuteUnique = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> used = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">let</span> cur = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先对数组进行排序，以方便处理重复元素</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...cur]); <span class="comment">// 将当前排列的副本加入结果集</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            cur.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归进入下一层决策树</span></span><br><span class="line">            <span class="title function_">backtrack</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            cur.<span class="title function_">pop</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">backtrack</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：假设数组 <code>nums</code> 的长度为 <code>n</code>，在最坏情况下，所有排列都是唯一且符合条件的。回溯算法的时间复杂度为 <code>O(n * n!)</code>，其中 <code>n!</code> 是所有可能的排列数，每个排列的生成和处理都需要 <code>O(n)</code> 的时间复杂度。</li>
<li><strong>空间复杂度</strong>：主要消耗在递归调用栈和存储结果的空间。使用了 <code>used</code> 数组和 <code>cur</code> 数组来记录状态和当前排列，以及最终的 <code>res</code> 数组来存储所有符合条件的排列。因此，空间复杂度为 <code>O(n)</code>。</li>
</ul>
<p>总体来说，这种解法利用回溯算法和一些额外的判断条件，能够高效地生成包含重复元素的所有唯一排列，并且确保每个排列只出现一次。</p>
<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。必须**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ol>
<li><p>**从右向左找到第一个降序的位置 <code>i</code>**：</p>
<ul>
<li>从数组的倒数第二个元素开始向前查找，找到第一个位置 <code>i</code> 满足 <code>nums[i] &lt; nums[i+1]</code>。这是因为如果该位置满足这个条件，可以使得我们修改这个位置以获得字典序更大的排列。</li>
</ul>
</li>
<li><p>**找到大于 <code>nums[i]</code> 的最小元素位置 <code>j</code>**：</p>
<ul>
<li>在位置 <code>i+1</code> 到数组末尾之间，找到最小的元素 <code>nums[j]</code>，满足 <code>nums[j] &gt; nums[i]</code>。这样做是为了确保新的排列尽可能小地增加。</li>
</ul>
</li>
<li><p>**交换元素 <code>nums[i]</code> 和 <code>nums[j]</code>**：</p>
<ul>
<li>将位置 <code>i</code> 的元素和位置 <code>j</code> 的元素进行交换。</li>
</ul>
</li>
<li><p><strong>翻转从位置 <code>i+1</code> 到末尾的元素</strong>：</p>
<ul>
<li>最后，翻转从位置 <code>i+1</code> 到数组末尾的所有元素。这一步确保得到的是下一个字典序更大的排列，并且是最小的增加量。</li>
</ul>
</li>
<li><p><strong>特殊情况处理</strong>：</p>
<ul>
<li>如果整个数组已经是降序排列（即没有找到位置 <code>i</code> 满足 <code>nums[i] &lt; nums[i+1]</code>），则直接翻转整个数组，得到最小的字典序排列。</li>
</ul>
</li>
</ol>
<h3 id="code：-2"><a href="#code：-2" class="headerlink" title="code："></a>code：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nextPermutation = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> i = n - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[j] &lt;= nums[i]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        [nums[left], nums[right]] = [nums[right], nums[left]];</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码通过以上的步骤实现了寻找数组 <code>nums</code> 的下一个排列，并且在原地进行修改，符合题目要求的要求。</p>
<h3 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ul>
<li><p><strong>时间复杂度</strong>：整个算法的时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是数组 <code>nums</code> 的长度。这是因为我们需要遍历数组两次（一次找位置 <code>i</code>，一次找位置 <code>j</code>），并进行一次翻转操作。</p>
</li>
<li><p><strong>空间复杂度</strong>：算法使用了常数额外空间 <code>O(1)</code>，除了存储输入数组外，没有使用额外空间。</p>
</li>
</ul>
<h3 id="示例解释："><a href="#示例解释：" class="headerlink" title="示例解释："></a>示例解释：</h3><p>假设输入数组 <code>nums = [1, 2, 3]</code>：</p>
<ol>
<li><p>**找到位置 <code>i</code>**：从右向左遍历，找到 <code>nums[1] &lt; nums[2]</code>，因此 <code>i = 1</code>。</p>
</li>
<li><p>**找到位置 <code>j</code>**：在位置 <code>i+1</code> 到数组末尾中，找到 <code>nums[2] = 3</code> 大于 <code>nums[1] = 2</code>，因此 <code>j = 2</code>。</p>
</li>
<li><p><strong>交换元素</strong>：交换 <code>nums[i]</code> 和 <code>nums[j]</code>，得到数组 <code>[1, 3, 2]</code>。</p>
</li>
<li><p><strong>翻转操作</strong>：翻转从位置 <code>i+1</code> 到末尾的元素，得到最终结果 <code>[1, 3, 2]</code>，这是数组 <code>[1, 2, 3]</code> 的下一个排列。</p>
</li>
</ol>
<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<h3 id="解题思想-4"><a href="#解题思想-4" class="headerlink" title="解题思想"></a>解题思想</h3><p>这段代码使用了回溯算法来生成给定数组 <code>nums</code> 的所有子集。回溯算法是一种递归的深度优先搜索方法，它通过不断地做选择和撤销选择来探索所有可能的解空间。</p>
<ol>
<li><p>**回溯函数 <code>backtrack</code>**：</p>
<ul>
<li><code>backtrack</code> 函数接收两个参数：<code>start</code> 表示当前处理的起始位置，<code>subset</code> 表示当前构建的子集。</li>
<li>在每次递归调用开始时，将当前子集 <code>subset</code> 的拷贝加入结果集 <code>res</code> 中，这样做是为了避免后续对 <code>subset</code> 的修改影响到已经加入结果集的内容。</li>
<li>然后，从 <code>start</code> 开始循环遍历数组 <code>nums</code>，将 <code>nums[i]</code> 加入到 <code>subset</code> 中，然后递归调用 <code>backtrack(i + 1, subset)</code> 来处理下一个位置的元素。</li>
<li>在递归返回后，通过 <code>subset.pop()</code> 进行回溯，即移除最后加入的元素，以便尝试下一个可能的选择。</li>
</ul>
</li>
<li><p><strong>结束条件</strong>：</p>
<ul>
<li>当 <code>backtrack</code> 函数开始时，如果 <code>start</code> 等于 <code>nums.length</code>，表示当前位置已经超过数组长度，不再进行递归调用，直接返回。</li>
</ul>
</li>
<li><p><strong>初始调用</strong>：</p>
<ul>
<li>初始时调用 <code>backtrack(0, [])</code>，从数组的第一个位置开始生成子集，初始子集为空数组 <code>[]</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">start,child</span>) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(child));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            child.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            <span class="title function_">backtrack</span>(i+<span class="number">1</span>,child);</span><br><span class="line">            child.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtrack</span>(<span class="number">0</span>,[])</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><strong>时间复杂度</strong>：O(2^n)<ul>
<li>回溯算法的时间复杂度主要取决于生成所有子集的数量。对于每个元素，可以选择加入或不加入子集，因此共有 2^n 种可能的子集组合。</li>
<li>每个子集的生成过程中，都涉及将当前子集的拷贝加入结果集 <code>res</code>，这个操作的复杂度是 O(n)，其中 n 是 <code>subset</code> 的长度。</li>
<li>所以总体来说，时间复杂度是 O(2^n * n)。</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li><strong>空间复杂度</strong>：O(n * 2^n)<ul>
<li>空间复杂度主要取决于递归调用栈的深度，最坏情况下可以达到 O(n)。</li>
<li>另外，存储结果集的空间复杂度为 O(n * 2^n)，因为有 2^n 个子集，每个子集的平均长度为 O(n)。</li>
</ul>
</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>通过回溯算法，这段代码能够有效地生成一个数组的所有子集。每次递归调用都尝试将当前位置的元素加入子集，并递归处理下一个位置，直到遍历完整个数组。通过合理的回溯和递归操作，确保了每个可能的组合都被考虑到，同时避免了重复计算，从而达到了生成所有子集的目的。</p>
<h2 id="字母大小全排列"><a href="#字母大小全排列" class="headerlink" title="字母大小全排列"></a>字母大小全排列</h2><p>给定一个字符串 <code>s</code> ，通过将字符串 <code>s</code> 中的每个字母转变大小写，可以获得一个新的字符串。返回 <strong>所有可能得到的字符串集合</strong> 。以 <strong>任意顺序</strong> 返回输出。</p>
<p>要解决这个问题，我们可以使用回溯算法来生成所有可能的字符串集合，其中每个字符可以转换为其大小写形式。</p>
<h3 id="解法一——回溯"><a href="#解法一——回溯" class="headerlink" title="解法一——回溯"></a>解法一——回溯</h3><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li><p><strong>回溯算法基本思路</strong>：</p>
<ul>
<li>我们从字符串的第一个字符开始，依次考虑每个字符的大小写转换。</li>
<li>对于每个字符，可以选择保持其原始大小写，或者转换为相应的另一种大小写形式。</li>
<li>使用递归来生成所有可能的组合，直到处理完字符串的所有字符。</li>
</ul>
</li>
<li><p><strong>具体实现步骤</strong>：</p>
<ul>
<li>定义一个递归函数 <code>backtrack</code>，它接收两个参数：当前处理的字符索引 <code>index</code> 和当前形成的字符串 <code>current</code>。</li>
<li>在每个字符位置上，分两种情况递归处理：<ul>
<li>将当前字符转换为其大写形式或小写形式，并继续向下递归。</li>
<li>如果已经到达字符串的末尾（<code>index === s.length</code>），则将形成的字符串加入结果集合。</li>
</ul>
</li>
<li>使用一个数组 <code>res</code> 来存储所有可能的字符串。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>最终，将生成的所有字符串存储在数组 <code>res</code> 中返回。</li>
</ul>
</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCasePermutation = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];  <span class="comment">// 用于存储所有可能的字符串结果</span></span><br><span class="line">    <span class="keyword">let</span> cur = [];  <span class="comment">// 用于存储当前路径的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">index, current</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前索引已经达到字符串的长度，说明已经生成了一个完整的排列</span></span><br><span class="line">        <span class="keyword">if</span> (index === s.<span class="property">length</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(current.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));  <span class="comment">// 将当前路径的字符数组转换为字符串，并加入结果集</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> char = s[index];  <span class="comment">// 获取当前索引处的字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前字符是字母</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/[a-zA-Z]/</span>.<span class="title function_">test</span>(char)) &#123;</span><br><span class="line">            <span class="comment">// 将字符转换为小写并加入当前路径</span></span><br><span class="line">            cur.<span class="title function_">push</span>(char.<span class="title function_">toLowerCase</span>());</span><br><span class="line">            <span class="comment">// 递归调用，处理下一个字符</span></span><br><span class="line">            <span class="title function_">backtrack</span>(index + <span class="number">1</span>, cur);</span><br><span class="line">            <span class="comment">// 回溯，移除最后一个字符</span></span><br><span class="line">            cur.<span class="title function_">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将字符转换为大写并加入当前路径</span></span><br><span class="line">            cur.<span class="title function_">push</span>(char.<span class="title function_">toUpperCase</span>());</span><br><span class="line">            <span class="comment">// 递归调用，处理下一个字符</span></span><br><span class="line">            <span class="title function_">backtrack</span>(index + <span class="number">1</span>, cur);</span><br><span class="line">            <span class="comment">// 回溯，移除最后一个字符</span></span><br><span class="line">            cur.<span class="title function_">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符是数字，直接加入当前路径</span></span><br><span class="line">            cur.<span class="title function_">push</span>(char);</span><br><span class="line">            <span class="comment">// 递归调用，处理下一个字符</span></span><br><span class="line">            <span class="title function_">backtrack</span>(index + <span class="number">1</span>, cur);</span><br><span class="line">            <span class="comment">// 回溯，移除最后一个字符</span></span><br><span class="line">            cur.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从索引0开始回溯，初始路径为空数组</span></span><br><span class="line">    <span class="title function_">backtrack</span>(<span class="number">0</span>, cur);</span><br><span class="line">    <span class="comment">// 返回结果集</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h4><ul>
<li><p>**回溯函数 <code>backtrack</code>**：</p>
<ul>
<li><code>backtrack</code> 函数根据当前处理的字符索引 <code>index</code> 和形成的当前字符串 <code>current</code> 进行递归处理。</li>
<li>当 <code>index</code> 等于 <code>s.length</code> 时，表示已经处理完所有字符，将 <code>current</code> 加入结果集 <code>res</code> 中。</li>
<li>对于每个字符，首先将其原样加入 <code>current</code> 中，然后判断是否为字母，如果是则添加其对应的大写形式。</li>
</ul>
</li>
<li><p><strong>字符处理</strong>：</p>
<ul>
<li>使用正则表达式 <code>/[a-zA-Z]/.test(char)</code> 来检测当前字符是否为字母。</li>
<li>如果是字母，则添加其大写形式到 <code>current</code> 中（避免添加两次相同的形式）。</li>
</ul>
</li>
<li><p><strong>初始调用</strong>：</p>
<ul>
<li>初始调用 <code>backtrack(0, &#39;&#39;)</code> 从字符串的第一个字符开始递归处理，初始的 <code>current</code> 为空字符串。</li>
</ul>
</li>
</ul>
<h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><p><strong>时间复杂度</strong>：O(2^n)</p>
<ul>
<li>回溯算法的时间复杂度主要取决于生成的字符串数量，对于每个字符，可以选择两种形式（原始形式和大写形式）。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>空间复杂度主要由递归调用栈的深度决定，最坏情况下可以达到 O(n)，其中 n 是字符串 <code>s</code> 的长度。</li>
<li>另外，存储结果的空间复杂度为 O(2^n)，因为最多会生成 2^n 个字符串。</li>
</ul>
</li>
</ul>
<p>这种方法通过递归和回溯的方式，有效地生成了所有可能的字符串形式，以达到题目要求的所有可能得到的字符串集合。</p>
<h3 id="解法二——迭代"><a href="#解法二——迭代" class="headerlink" title="解法二——迭代"></a>解法二——迭代</h3><p>除了使用回溯算法外，还可以考虑使用迭代的方法来生成所有可能的字符串集合。这种方法可以通过遍历输入字符串，并根据每个字符的类型（字母或数字）动态更新结果集合。让我展示一种基于迭代的解决方案。</p>
<h4 id="迭代解决方案"><a href="#迭代解决方案" class="headerlink" title="迭代解决方案"></a>迭代解决方案</h4><p>迭代解决方案的基本思路是使用一个数组来存储每一步生成的结果，并根据输入字符串中的每个字符更新这个数组。</p>
<ol>
<li><p><strong>初始定义</strong>：</p>
<ul>
<li>创建一个初始的数组 <code>result</code>，将空字符串 <code>&quot;&quot;</code> 加入作为初始的结果。</li>
</ul>
</li>
<li><p><strong>迭代过程</strong>：</p>
<ul>
<li>遍历输入字符串 <code>s</code> 中的每个字符。</li>
<li>对于每个字符，如果是字母，则遍历当前 <code>result</code> 数组中的每个字符串，生成一个新的字符串，包括原始字符和其大写形式，并将生成的新字符串加入一个临时数组 <code>nextResult</code>。</li>
<li>如果是数字，则直接将当前 <code>result</code> 数组中的每个字符串加上这个数字字符，加入到 <code>nextResult</code> 中。</li>
</ul>
</li>
<li><p><strong>更新结果集</strong>：</p>
<ul>
<li>将 <code>nextResult</code> 数组的内容更新回 <code>result</code>，以便下一次迭代继续使用。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>最终 <code>result</code> 中存储的即为所有可能得到的字符串集合。</li>
</ul>
</li>
</ol>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCasePermutation = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [<span class="string">&quot;&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextResult = [];</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/[a-zA-Z]/</span>.<span class="title function_">test</span>(char)) &#123; <span class="comment">// If char is a letter</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> result) &#123;</span><br><span class="line">                nextResult.<span class="title function_">push</span>(str + char.<span class="title function_">toLowerCase</span>());</span><br><span class="line">                nextResult.<span class="title function_">push</span>(str + char.<span class="title function_">toUpperCase</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// If char is a digit</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> result) &#123;</span><br><span class="line">                nextResult.<span class="title function_">push</span>(str + char);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = nextResult;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;a1b2&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">letterCasePermutation</span>(s)); <span class="comment">// Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a>代码说明</h4><ul>
<li><p><strong>初始定义</strong>：</p>
<ul>
<li>创建一个初始的 <code>result</code> 数组，其中包含一个空字符串 <code>&quot;&quot;</code>，作为初始的结果。</li>
</ul>
</li>
<li><p><strong>迭代过程</strong>：</p>
<ul>
<li>遍历输入字符串 <code>s</code> 中的每个字符 <code>char</code>。</li>
<li>如果 <code>char</code> 是字母（使用正则表达式 <code>/[a-zA-Z]/.test(char)</code> 进行判断），则遍历当前 <code>result</code> 数组中的每个字符串 <code>str</code>，生成两个新的字符串：<ul>
<li><code>str + char.toLowerCase()</code>：将 <code>char</code> 转换为小写加入新的字符串。</li>
<li><code>str + char.toUpperCase()</code>：将 <code>char</code> 转换为大写加入新的字符串。</li>
</ul>
</li>
<li>如果 <code>char</code> 是数字，则直接遍历 <code>result</code> 数组中的每个字符串 <code>str</code>，将 <code>char</code> 加入到 <code>str</code> 后面形成新的字符串。</li>
</ul>
</li>
<li><p><strong>更新结果集</strong>：</p>
<ul>
<li>将生成的新字符串数组 <code>nextResult</code> 赋值给 <code>result</code>，以便下一次迭代使用。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>最终返回 <code>result</code>，其中包含了所有可能的字符串集合。</li>
</ul>
</li>
</ul>
<h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><p><strong>时间复杂度</strong>：O(2^n)</p>
<ul>
<li>对于每个字符，可能生成两个新字符串（大小写形式），因此最终的字符串数量为 2^n。</li>
<li>每次循环需要遍历 <code>result</code> 数组中的字符串，因此总体时间复杂度是 O(2^n * n)，其中 n 是输入字符串 <code>s</code> 的长度。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：O(2^n * n)</p>
<ul>
<li>空间复杂度主要取决于存储结果的数组 <code>result</code>，以及每个字符串的长度为 n。</li>
</ul>
</li>
</ul>
<p>这种迭代方法避免了递归调用带来的额外内存消耗，同时通过动态更新结果集来生成所有可能的字符串集合，是另一种有效的解决方案。</p>
<p>在处理字符串大小写转换生成所有可能字符串集合的问题中，回溯算法和迭代算法各有其优缺点，简单性可以从几个角度来评估：</p>
<h3 id="方法比较"><a href="#方法比较" class="headerlink" title="方法比较"></a>方法比较</h3><ol>
<li><p><strong>理解和实现</strong>：</p>
<ul>
<li><strong>回溯算法</strong>：<ul>
<li>回溯算法通常涉及递归和回溯的概念，需要理解递归调用和回溯过程中的状态管理。</li>
<li>实现时需要考虑如何维护当前路径、处理选择列表以及正确的回溯操作。</li>
</ul>
</li>
<li><strong>迭代算法</strong>：<ul>
<li>迭代算法更加直观，可以通过循环和条件语句来动态更新结果集。</li>
<li>每一步都是直接在当前状态下进行计算，相对来说更易于理解和实现。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>代码复杂度</strong>：</p>
<ul>
<li><strong>回溯算法</strong>：<ul>
<li>需要设计和管理递归函数，考虑递归调用带来的栈空间消耗。</li>
<li>可能需要额外的数据结构来存储中间状态，如路径的深拷贝。</li>
</ul>
</li>
<li><strong>迭代算法</strong>：<ul>
<li>使用基本的循环和数组操作，代码结构相对直观和简单。</li>
<li>不涉及递归调用，可以减少栈空间的使用，适用于大数据集的情况。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>性能和空间消耗</strong>：</p>
<ul>
<li><strong>回溯算法</strong>：<ul>
<li>可能存在大量的递归调用，如果不适当地进行状态管理和剪枝，会消耗较多的栈空间。</li>
<li>需要考虑额外的空间复杂度用于存储结果集和中间状态。</li>
</ul>
</li>
<li><strong>迭代算法</strong>：<ul>
<li>在每一步迭代中动态更新结果集，可能会更有效地利用内存。</li>
<li>不会遇到栈溢出的问题，适合处理大规模数据集。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>从简单性的角度来看，迭代算法通常更容易理解和实现。它直接在当前状态下处理，避免了递归调用可能带来的复杂性和额外的内存消耗。在大多数情况下，迭代算法对于处理字符串大小写转换生成所有可能字符串集合的问题更加直观和高效。</p>
<p>因此，如果您更注重简单性和直观性，并且不需要额外的递归调用管理，推荐使用迭代算法。如果您熟悉回溯算法或者问题需要经典的深度优先搜索（DFS）策略，那么回溯算法也是一个有效的选择，尤其适用于需要深度探索所有可能性的场景。</p>
<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>要解决这个问题，我们可以使用回溯算法。给定一个仅包含数字 2-9 的字符串，每个数字对应多个字母，我们需要生成所有可能的字母组合。</p>
<h3 id="数字到字母的映射"><a href="#数字到字母的映射" class="headerlink" title="数字到字母的映射"></a>数字到字母的映射</h3><p>首先，需要一个映射表，将数字映射到对应的字母：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 -&gt; &quot;abc&quot;</span><br><span class="line">3 -&gt; &quot;def&quot;</span><br><span class="line">4 -&gt; &quot;ghi&quot;</span><br><span class="line">5 -&gt; &quot;jkl&quot;</span><br><span class="line">6 -&gt; &quot;mno&quot;</span><br><span class="line">7 -&gt; &quot;pqrs&quot;</span><br><span class="line">8 -&gt; &quot;tuv&quot;</span><br><span class="line">9 -&gt; &quot;wxyz&quot;</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们使用回溯算法来生成所有可能的组合：</p>
<ol>
<li><strong>初始化映射表</strong>：使用一个数组 <code>mapping</code> 来存储数字到字母的映射关系。</li>
<li><strong>定义回溯函数</strong>：这个函数将逐步构建可能的字母组合。</li>
<li><strong>处理递归终止条件</strong>：当组合长度等于输入字符串长度时，将当前组合加入结果集。</li>
<li><strong>遍历当前数字对应的所有字母</strong>：将每个字母加入当前组合，然后递归处理下一个数字。</li>
<li><strong>回溯</strong>：在递归返回后，移除当前字母，以便尝试下一个可能的字母。</li>
</ol>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是具体的代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCombinations = <span class="keyword">function</span>(<span class="params">digits</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> [];  <span class="comment">// 如果输入为空，返回空数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> mapping = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>];  <span class="comment">// 数字到字母的映射表</span></span><br><span class="line">    <span class="keyword">let</span> res = [];  <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="keyword">let</span> cur = [];  <span class="comment">// 当前组合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前组合长度等于输入字符串长度，加入结果数组</span></span><br><span class="line">        <span class="keyword">if</span> (index === digits.<span class="property">length</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(cur.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前数字对应的字母串</span></span><br><span class="line">        <span class="keyword">let</span> letters = mapping[digits[index] - <span class="string">&#x27;2&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; letters.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            cur.<span class="title function_">push</span>(letters[i]);  <span class="comment">// 将当前字母加入当前组合</span></span><br><span class="line">            <span class="title function_">backtrack</span>(index + <span class="number">1</span>);  <span class="comment">// 递归处理下一个数字</span></span><br><span class="line">            cur.<span class="title function_">pop</span>();  <span class="comment">// 回溯，移除当前字母</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">backtrack</span>(<span class="number">0</span>);  <span class="comment">// 从索引0开始回溯</span></span><br><span class="line">    <span class="keyword">return</span> res;  <span class="comment">// 返回结果数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(3^N * 4^M)，其中 N 是输入中对应 3 个字母的数字个数，M 是对应 4 个字母的数字个数。因为每个数字对应的字母数不同，组合的总数是 3^N * 4^M。</li>
<li><strong>空间复杂度</strong>：O(N)，这里 N 是输入字符串的长度。递归调用的深度最多为 N，存储当前路径的数组 <code>cur</code> 也是 O(N)。</li>
</ul>
<p>这种方法简洁且高效，利用回溯法可以生成所有可能的组合。</p>
<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p>理解解题思路并逐行解释代码，然后进行复杂度分析是非常重要的。我们将继续使用回溯算法来解决允许重复选择元素的组合求和问题。</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>回溯算法基本思路</strong>：</p>
<ul>
<li>回溯算法是一种通过深度优先搜索（DFS）寻找所有解的算法。</li>
<li>在本题中，我们需要找出数组 <code>candidates</code> 中所有允许重复选择的组合，使得这些组合的元素之和等于给定的 <code>target</code>。</li>
</ul>
</li>
<li><p><strong>递归函数设计</strong>：</p>
<ul>
<li>设计一个递归函数 <code>backtrack</code>，该函数会根据当前的选择路径进行搜索，并更新当前的组合 <code>cur</code> 和剩余目标值 <code>remain</code>。</li>
</ul>
</li>
<li><p><strong>回溯过程</strong>：</p>
<ul>
<li>与前面的题目相比，不同之处在于每次递归调用时，可以从当前位置开始选择元素，并允许重复选择当前位置的元素。</li>
<li>当当前组合 <code>cur</code> 的和等于 <code>target</code> 时，将当前组合加入结果集 <code>res</code> 中。</li>
<li>如果当前组合的和已经超过 <code>target</code>，则进行回溯操作，尝试其他可能的组合。</li>
</ul>
</li>
</ol>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum = <span class="keyword">function</span>(<span class="params">candidates, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = []; <span class="comment">// 存储所有符合条件的组合</span></span><br><span class="line">    <span class="keyword">let</span> cur = []; <span class="comment">// 当前的组合</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义回溯函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">start, remain</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 remain 等于 0，说明当前组合的和等于 target，将当前组合加入结果集</span></span><br><span class="line">        <span class="keyword">if</span> (remain === <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(cur.<span class="title function_">slice</span>()); <span class="comment">// 将当前组合的副本加入结果集</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从 start 开始遍历 candidates 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; candidates.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素大于剩余目标值，跳过（剪枝操作）</span></span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &gt; remain) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 选择当前元素加入当前组合</span></span><br><span class="line">            cur.<span class="title function_">push</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 递归调用 backtrack，继续向下选择，传入的 start 仍为 i，允许重复使用当前元素</span></span><br><span class="line">            <span class="title function_">backtrack</span>(i, remain - candidates[i]);</span><br><span class="line">            <span class="comment">// 回溯操作，撤销选择，尝试下一个可能的元素</span></span><br><span class="line">            cur.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用回溯函数，从索引 0 开始，初始目标值为 target</span></span><br><span class="line">    <span class="title function_">backtrack</span>(<span class="number">0</span>, target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释和改进"><a href="#代码解释和改进" class="headerlink" title="代码解释和改进"></a>代码解释和改进</h3><ul>
<li><p>**回溯函数 <code>backtrack</code>**：</p>
<ul>
<li>参数 <code>start</code>：表示从 <code>candidates</code> 数组的哪个位置开始选择元素。</li>
<li>参数 <code>remain</code>：表示当前剩余的目标值。</li>
<li>如果 <code>remain === 0</code>，将当前组合 <code>cur</code> 加入结果集 <code>res</code> 中。</li>
<li>遍历 <code>candidates</code> 数组，从 <code>start</code> 开始选择元素：<ul>
<li>如果当前元素大于 <code>remain</code>，跳过当前循环（剪枝操作）。</li>
<li>将当前元素加入 <code>cur</code> 中，递归调用 <code>backtrack</code> 继续向下搜索。</li>
<li>回溯（撤销选择），尝试下一个可能的选择。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>调用回溯函数</strong>：</p>
<ul>
<li><code>backtrack(0, target)</code>：从 <code>candidates</code> 数组的第一个位置开始，初始目标值为 <code>target</code>。</li>
</ul>
</li>
</ul>
<h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：假设 <code>candidates</code> 数组的长度为 <code>n</code>，目标值为 <code>target</code>。在最坏情况下，每个元素都可能被选取多次，因此时间复杂度为 <code>O((target / min(candidates))^n)</code>，即指数级别的复杂度。</li>
<li><strong>空间复杂度</strong>：递归调用的深度最多为 <code>target / min(candidates)</code>，加上存储结果的空间，空间复杂度也为 <code>O((target / min(candidates))^n)</code>。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设 <code>candidates = [2, 3, 6, 7]</code>，<code>target = 7</code>。</p>
<p>调用 <code>combinationSum(candidates, target)</code> 后，返回结果应为 <code>[[2, 2, 3], [7]]</code>，表示所有可能的组合为 <code>[2, 2, 3]</code> 和 <code>[7]</code>。</p>
<p>这种方法能够有效地找出所有允许重复选择元素的组合，利用回溯算法遍历所有可能性，是经典的组合求和问题的解决方法之一。</p>
<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<h3 id="解题思想-5"><a href="#解题思想-5" class="headerlink" title="解题思想"></a>解题思想</h3><ol>
<li><strong>回溯法</strong>：<ul>
<li>回溯法是一种通过递归来尝试所有可能的组合的算法。在这个问题中，我们使用回溯法来生成所有可能的括号组合。</li>
</ul>
</li>
<li><strong>有效性条件</strong>：<ul>
<li>在构建组合的过程中，我们需要确保每一步构建出来的部分组合都是有效的。</li>
<li>有效的括号组合需要满足：<ol>
<li>左括号 <code>(</code> 的数量不超过右括号 <code>)</code> 的数量。</li>
<li>在任何时候，添加的右括号 <code>)</code> 数量不能超过左括号 <code>(</code> 的数量。</li>
</ol>
</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []; <span class="comment">// 用于存储所有有效的括号组合</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义回溯函数，current表示当前的括号组合，left表示剩余的左括号数量，right表示剩余的右括号数量</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">current, left, right</span>) &#123;</span><br><span class="line">        <span class="comment">// 当左右括号数量都为0时，表示找到了一个有效的括号组合</span></span><br><span class="line">        <span class="keyword">if</span> (left === <span class="number">0</span> &amp;&amp; right === <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(current); <span class="comment">// 将当前括号组合加入结果数组</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 结束当前的回溯路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果剩余的左括号数量大于0，可以继续添加左括号</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">backtrack</span>(current + <span class="string">&#x27;(&#x27;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果剩余的右括号数量大于剩余的左括号数量，可以继续添加右括号</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="title function_">backtrack</span>(current + <span class="string">&#x27;)&#x27;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始调用回溯函数，current初始为空字符串，left和right均为n，表示初始时有n个左括号和n个右括号</span></span><br><span class="line">    <span class="title function_">backtrack</span>(<span class="string">&#x27;&#x27;</span>, n, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回所有有效的括号组合</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>空间复杂度主要取决于递归调用时使用的栈空间，以及存储结果的空间。下面来详细分析空间复杂度：</p>
<h3 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h3><p>对于生成有效括号组合的问题，时间复杂度分析主要考虑两方面：</p>
<ol>
<li><p><strong>生成所有可能的括号组合</strong>：</p>
<ul>
<li>每个括号组合长度为 <code>2n</code>，每个位置上可以是左括号 <code>(</code> 或右括号 <code>)</code>，因此所有可能的括号组合总数是 <code>2^(2n)</code>。</li>
</ul>
</li>
<li><p><strong>有效括号组合的数量</strong>：</p>
<ul>
<li>有效的括号组合数量是第 <code>n</code> 个卡塔兰数 <code>C(n)</code>，其近似值为 <code>4^n / (n * sqrt(n))</code>。虽然生成所有可能的括号组合需要 <code>O(2^(2n))</code> 的时间，但实际上有效的括号组合数量少得多，大约是 <code>O(4^n / sqrt(n))</code>。</li>
</ul>
</li>
<li><p><strong>生成和验证有效括号组合的时间</strong>：</p>
<ul>
<li>在最坏情况下，生成每个有效组合的时间复杂度是 <code>O(n)</code>，因为需要在递归过程中构建和检查每个组合的有效性。</li>
</ul>
</li>
</ol>
<p>综合来看，总时间复杂度主要受到有效括号组合数量的影响，因此总时间复杂度约为 <code>O(4^n / sqrt(n))</code>。</p>
<h3 id="空间复杂度分析："><a href="#空间复杂度分析：" class="headerlink" title="空间复杂度分析："></a>空间复杂度分析：</h3><p>空间复杂度主要考虑两方面：</p>
<ol>
<li><p><strong>递归调用栈的空间</strong>：</p>
<ul>
<li>在递归过程中，调用栈的最大深度为 <code>2n</code>，即左括号和右括号各 <code>n</code> 个。因此，递归调用栈的空间复杂度为 <code>O(n)</code>。</li>
</ul>
</li>
<li><p><strong>存储结果的空间</strong>：</p>
<ul>
<li><code>result</code> 数组用于存储所有有效的括号组合。有效括号组合的数量是 <code>O(4^n / sqrt(n))</code>，每个组合的长度为 <code>2n</code>。</li>
<li>因此，结果数组的空间复杂度为 <code>O(n * 4^n / sqrt(n))</code>，简化为 <code>O(4^n / sqrt(n))</code>。</li>
</ul>
</li>
</ol>
<p>综合来看，总空间复杂度约为 <code>O(4^n / sqrt(n))</code>。</p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><ul>
<li><strong>时间复杂度</strong>：<code>O(4^n / sqrt(n))</code></li>
<li><strong>空间复杂度</strong>：<code>O(4^n / sqrt(n))</code></li>
</ul>
<p>这种复杂度表示该算法在生成有效括号组合时是相对高效的，但随着 <code>n</code> 的增大，组合数量呈指数级增长，计算和存储的资源需求也会显著增加。</p>
<h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<blockquote>
<p>这个问题可以用深度优先搜索（DFS）结合回溯法来解决。需要在一个二维网格中搜索是否存在一个单词，其中单词的字母必须按照字母顺序通过相邻的单元格（水平或垂直相邻）构成，并且同一个单元格内的字母不能重复使用。</p>
</blockquote>
<h3 id="解题思想：-1"><a href="#解题思想：-1" class="headerlink" title="解题思想："></a>解题思想：</h3><ol>
<li><p><strong>遍历网格</strong>：</p>
<ul>
<li>对网格中的每个单元格进行遍历，尝试从该单元格开始匹配单词。</li>
</ul>
</li>
<li><p>**深度优先搜索 (DFS)**：</p>
<ul>
<li>定义一个DFS函数，用于从当前单元格出发，尝试匹配单词的每个字母。</li>
<li>如果当前单元格的字母与单词中对应位置的字母匹配，则继续搜索相邻的四个方向（上、下、左、右）。</li>
<li>使用回溯法，即在搜索完一个方向后，需要撤销当前单元格的选择，以便尝试其他方向。</li>
</ul>
</li>
<li><p><strong>边界条件和剪枝</strong>：</p>
<ul>
<li>边界条件包括检查索引是否越界，当前单元格是否已经被访问，以及当前单元格的字母是否与单词对应位置的字母匹配。</li>
<li>剪枝操作可以减少不必要的搜索，例如一旦发现某个方向无法匹配，则立即返回。</li>
</ul>
</li>
</ol>
<h3 id="code：-3"><a href="#code：-3" class="headerlink" title="code："></a>code：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="keyword">function</span> (<span class="params">board, word</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> rows = board.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> cols = board[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义DFS函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">row, col, index</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果index等于word长度，说明所有字符都匹配，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (index === word.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查边界条件和当前单元格的字母是否与单词中对应位置的字母匹配</span></span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= rows || col &gt;= cols || board[row][col] !== word[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前单元格的值并标记为访问过</span></span><br><span class="line">        <span class="keyword">const</span> temp = board[row][col];</span><br><span class="line">        board[row][col] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 临时标记为已访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用DFS，搜索四个方向</span></span><br><span class="line">        <span class="keyword">const</span> found = <span class="title function_">dfs</span>(row + <span class="number">1</span>, col, index + <span class="number">1</span>) ||  <span class="comment">// 向下搜索</span></span><br><span class="line">                      <span class="title function_">dfs</span>(row - <span class="number">1</span>, col, index + <span class="number">1</span>) ||  <span class="comment">// 向上搜索</span></span><br><span class="line">                      <span class="title function_">dfs</span>(row, col + <span class="number">1</span>, index + <span class="number">1</span>) ||  <span class="comment">// 向右搜索</span></span><br><span class="line">                      <span class="title function_">dfs</span>(row, col - <span class="number">1</span>, index + <span class="number">1</span>);    <span class="comment">// 向左搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复当前单元格的值</span></span><br><span class="line">        board[row][col] = temp;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历网格，寻找起始点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">dfs</span>(i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析：-2"><a href="#复杂度分析：-2" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ol>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li>最坏情况下，需要遍历整个网格的每个单元格，进行一次DFS。DFS的深度最大为单词的长度 <code>L</code>。每次DFS有四个方向，因此时间复杂度为 <code>O(N * M * 4^L)</code>，其中 <code>N</code> 和 <code>M</code> 分别为网格的行数和列数，<code>L</code> 为单词的长度。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>主要空间消耗在于递归调用栈。最坏情况下递归栈的深度为单词的长度 <code>L</code>，因此空间复杂度为 <code>O(L)</code>。</li>
</ul>
</li>
</ol>
<p>这个解法通过遍历每个单元格，并使用DFS进行深度优先搜索和回溯，确保可以找到所有可能的路径并验证其有效性。通过剪枝操作，避免了不必要的计算，从而提高了算法的效率。</p>
<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文串。返回 <code>s</code> 所有可能的分割方案。</p>
<h3 id="解题思想-6"><a href="#解题思想-6" class="headerlink" title="解题思想"></a>解题思想</h3><p>该问题的目标是找到所有可能的回文子串分割。我们可以使用回溯法来解决这个问题。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>遍历字符串的每一个可能的起点和终点，检查该子串是否为回文。</li>
<li>如果是回文，则将该子串加入当前路径，并继续检查剩下的部分。</li>
<li>如果遍历到字符串的末尾，则将当前路径加入结果数组。</li>
<li>回溯到上一步，继续检查其他可能的子串。</li>
</ol>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> partition = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isPalindrome</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = str.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[left] !== str[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtrack</span> = (<span class="params">start, path</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (start === s.<span class="property">length</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> end = start; end &lt; s.<span class="property">length</span>; end++) &#123;</span><br><span class="line">            <span class="keyword">const</span> substr = s.<span class="title function_">substring</span>(start, end + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isPalindrome</span>(substr)) &#123;</span><br><span class="line">                path.<span class="title function_">push</span>(substr);</span><br><span class="line">                <span class="title function_">backtrack</span>(end + <span class="number">1</span>, path);</span><br><span class="line">                path.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">backtrack</span>(<span class="number">0</span>, []);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ol>
<li><strong>生成所有子串</strong>：<ul>
<li>生成所有子串的复杂度是 O(2n)O(2^n)O(2n)，因为每个字符在回文分割中有两种选择：作为单独的字符或者与其他字符组成回文。</li>
</ul>
</li>
<li><strong>检查回文性</strong>：<ul>
<li>对于每一个子串，需要 O(n)O(n)O(n) 的时间来检查它是否是回文。因此，在最坏情况下，回文检查的复杂度是 O(n⋅2n)O(n \cdot 2^n)O(n⋅2n)。</li>
</ul>
</li>
<li><strong>组合的生成</strong>：<ul>
<li>每个可能的分割都会产生一个路径，路径的生成和记录也是 O(n⋅2n)O(n \cdot 2^n)O(n⋅2n)。</li>
</ul>
</li>
</ol>
<p>综合考虑，时间复杂度为 O(n⋅2n)O(n \cdot 2^n)O(n⋅2n)。</p>
<h4 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ol>
<li><strong>递归调用栈</strong>：<ul>
<li>最深的递归深度为 O(n)O(n)O(n)，因为每次递归调用都会消耗栈空间。</li>
</ul>
</li>
<li><strong>存储路径</strong>：<ul>
<li>存储所有可能的路径和中间结果需要 O(n⋅2n)O(n \cdot 2^n)O(n⋅2n) 的空间。</li>
</ul>
</li>
</ol>
<p>综合考虑，空间复杂度为 O(n⋅2n)O(n \cdot 2^n)O(n⋅2n)。</p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>通过回溯法可以有效地找到所有可能的回文子串分割。尽管时间和空间复杂度较高，但该方法对于大多数实际输入是可行的。</p>
<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<p>解决N皇后问题可以使用回溯法来找到所有可能的解决方案。我们需要确保每个皇后放置的位置不受其他皇后的攻击，即任何两个皇后不在同一行、同一列或同一对角线上。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> solveNQueens = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// 用于存放所有解的数组</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">// 初始化一个 n x n 的棋盘，初始值为 &#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> board = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断在 (row, col) 位置放置皇后是否合法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isValid</span> = (<span class="params">row, col</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 检查同一列是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] === <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左上对角线是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] === <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查右上对角线是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] === <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前位置 (row, col) 没有冲突，则返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数，尝试在当前行放置皇后</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtrack</span> = (<span class="params">row</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 如果已经成功放置了 n 个皇后，将当前棋盘状态加入结果数组</span></span><br><span class="line">        <span class="keyword">if</span> (row === n) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(board.<span class="title function_">map</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前行的每一列，尝试放置皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="comment">// 判断当前位置是否可以放置皇后</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isValid</span>(row, col)) &#123;</span><br><span class="line">                <span class="comment">// 放置皇后</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="comment">// 递归尝试下一行</span></span><br><span class="line">                <span class="title function_">backtrack</span>(row + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯，撤销当前位置的皇后</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从第 0 行开始回溯放置皇后</span></span><br><span class="line">    <span class="title function_">backtrack</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回所有解</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>res</code> 是存储所有解决方案的数组。</li>
<li><code>board</code> 是当前棋盘状态，用二维数组表示，其中 <code>.</code> 表示空位，<code>Q</code> 表示皇后。</li>
</ul>
</li>
<li><p><strong><code>isValid</code> 函数</strong>：</p>
<ul>
<li>检查在 <code>(row, col)</code> 位置放置皇后是否有效。</li>
<li>通过检查当前列、左上对角线和右上对角线是否有皇后来判断。</li>
</ul>
</li>
<li><p><strong><code>backtrack</code> 函数</strong>：</p>
<ul>
<li>递归地尝试在每一行放置皇后。</li>
<li>如果当前行 <code>row</code> 等于 <code>n</code>，说明所有皇后都已经成功放置，将当前棋盘状态加入结果数组。</li>
<li>否则，遍历当前行的每一列，尝试放置皇后，并递归处理下一行。</li>
</ul>
</li>
<li><p>**主函数 <code>solveNQueens</code>**：</p>
<ul>
<li>初始化棋盘和结果数组。</li>
<li>调用 <code>backtrack</code> 函数从第0行开始递归地尝试放置皇后。</li>
<li>返回结果数组 <code>res</code>。</li>
</ul>
</li>
</ol>
<h3 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最坏情况下，我们需要检查所有可能的皇后放置组合。对于每一个位置，我们最多有 (n) 个选择，因此时间复杂度为 (O(n!))。</p>
<h4 id="空间复杂度-4"><a href="#空间复杂度-4" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>主要由递归调用栈和存储结果的空间决定。在最坏情况下，递归的深度为 (n)，每层递归最多存储一个棋盘状态，因此空间复杂度为 (O(n^2))。</p>
<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，不能使用两次相同的元素，可以按任意顺序返回答案。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(tmp)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map.<span class="title function_">get</span>(tmp), i];</span><br><span class="line">        &#125;</span><br><span class="line">        map.<span class="title function_">set</span>(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []; <span class="comment">// 如果没有找到合适的组合，返回空数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回空数组</strong>：如果遍历完数组后没有找到符合条件的两个数字，函数会返回一个空数组 <code>[]</code>。这样可以避免没有返回值的情况发生。</li>
<li><strong>时间复杂度</strong>：遍历整个数组一次，查找和存储在 <code>Map</code> 中的操作是常数时间，因此整体时间复杂度为 **O(n)**，其中 <code>n</code> 是数组的长度。</li>
</ul>
<h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。<strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 创建一个 Map 来存储字符相同的单词组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> strs) &#123;</span><br><span class="line">        <span class="keyword">const</span> sortedStr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 对每个字符串进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(sortedStr)) &#123;</span><br><span class="line">            map.<span class="title function_">get</span>(sortedStr).<span class="title function_">push</span>(str); <span class="comment">// 如果排序后的字符串已存在于 Map 中，加入该组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(sortedStr, [str]); <span class="comment">// 如果不存在，则新建一个数组，并存入 Map</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(map.<span class="title function_">values</span>()); <span class="comment">// 返回 Map 中所有的值（即分组的异位词数组）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Map（映射）</strong>：使用 <code>Map</code> 来存储每一组异位词，键是经过排序的字符串，值是该组异位词组成的数组。</li>
<li><strong>字符串排序</strong>：对于每个字符串 <code>str</code>，将其拆分为字符数组，按字母顺序排序，再重新合并为字符串。排序后的字符串作为键，因为异位词的排序结果是相同的。</li>
<li><strong>将异位词放入对应组</strong>：检查 <code>Map</code> 中是否已有这个排序后的字符串作为键。如果有，就把当前字符串加入到这个键对应的数组中；如果没有，就为这个键创建一个新的数组。</li>
<li><strong>返回结果</strong>：最终返回 <code>Map</code> 中所有值的集合，也就是所有分组好的异位词。</li>
</ol>
<h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h2><p>给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数</p>
<p>进阶： 空间复杂度 𝑂(1)<em>O</em>(1)，时间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">minNumberDisappeared</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(nums);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (set.<span class="title function_">has</span>(i)) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度，设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestConsecutive = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> curNum = <span class="keyword">new</span> <span class="title class_">Set</span>(nums); <span class="comment">// 使用 Set 去重并便于查找</span></span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>; <span class="comment">// 用于记录最长序列的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> curNum) &#123;</span><br><span class="line">        <span class="comment">// 只在当前数字是连续序列的起点时，才开始计算</span></span><br><span class="line">        <span class="keyword">if</span> (!curNum.<span class="title function_">has</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">let</span> cur = num;</span><br><span class="line">            <span class="keyword">let</span> length = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继续检查下一个数字是否在 Set 中</span></span><br><span class="line">            <span class="keyword">while</span> (curNum.<span class="title function_">has</span>(cur + <span class="number">1</span>)) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最长序列长度</span></span><br><span class="line">            maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLength, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>起点判断</strong>：<code>if (!curNum.has(num - 1))</code> 用来判断 <code>num</code> 是否是某个连续序列的起点。如果 <code>num-1</code> 不存在于 <code>Set</code> 中，那么 <code>num</code> 就是连续序列的第一个数字。</li>
<li><strong>扩展序列</strong>：一旦找到了序列的起点，就通过 <code>while (curNum.has(cur + 1))</code> 循环向后检查，看看下一个数字是否存在。如果存在，继续延长这个序列的长度。</li>
<li><strong>更新最大长度</strong>：对于每一个连续序列，我们用 <code>Math.max</code> 更新最大长度 <code>maxLength</code>。</li>
</ol>
<h2 id="盛最多水的容器-1"><a href="#盛最多水的容器-1" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p>
<blockquote>
<p>说明：你不能倾斜容器。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span> (<span class="params">height</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>; <span class="comment">// 初始化左边界指针</span></span><br><span class="line">  <span class="keyword">let</span> right = height.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 初始化右边界指针</span></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>; <span class="comment">// 初始化最大容器容量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// 当左边界指针小于右边界指针时循环执行</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="title class_">Math</span>.<span class="title function_">min</span>(height[left], height[right]) * (right - left);</span><br><span class="line">    <span class="comment">// 计算当前容器的容量</span></span><br><span class="line"></span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(current, max); <span class="comment">// 更新最大容量为当前容量和最大容量的较大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">      <span class="comment">// 如果左边界指针所指高度小于右边界指针所指高度</span></span><br><span class="line">      left++; <span class="comment">// 移动左边界指针向右</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--; <span class="comment">// 否则移动右边界指针向左</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max; <span class="comment">// 返回最大容器容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">height</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trap = <span class="keyword">function</span> (<span class="params">height</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> water = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left_max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (height.<span class="property">length</span> == <span class="number">0</span> || !height) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// 更新左右最大高度</span></span><br><span class="line">    left_max = <span class="title class_">Math</span>.<span class="title function_">max</span>(left_max, height[left]);</span><br><span class="line">    right_max = <span class="title class_">Math</span>.<span class="title function_">max</span>(right_max, height[right]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">      <span class="comment">// 计算当前位置的积水量并累加</span></span><br><span class="line">      water += left_max - height[left];</span><br><span class="line">      left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 计算当前位置的积水量并累加</span></span><br><span class="line">      water += right_max - height[right];</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> water;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长<br>子串<br>的长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="keyword">let</span> maxlength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> right = <span class="number">0</span>; right &lt; s.<span class="property">length</span>; right++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = s[right];</span><br><span class="line">    <span class="keyword">while</span> (set.<span class="title function_">has</span>(tmp)) &#123;</span><br><span class="line">      set.<span class="title function_">delete</span>(s[left]);</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    set.<span class="title function_">add</span>(tmp);</span><br><span class="line">    maxlength = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxlength, right - left + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长无重复子数组"><a href="#最长无重复子数组" class="headerlink" title="最长无重复子数组"></a>最长无重复子数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxLength</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果数组为空，返回0</span></span><br><span class="line">  <span class="keyword">if</span> (!arr || arr.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>; <span class="comment">// 左指针初始化</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">0</span>; <span class="comment">// 右指针初始化</span></span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">// 用于存储子数组中不同元素的集合</span></span><br><span class="line">  <span class="keyword">let</span> maxLength = <span class="number">0</span>; <span class="comment">// 记录最长子数组的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 右指针遍历整个数组</span></span><br><span class="line">  <span class="keyword">while</span> (right &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[right]; <span class="comment">// 当前右指针指向的元素</span></span><br><span class="line">    <span class="keyword">if</span> (!array.<span class="title function_">has</span>(tmp)) &#123;</span><br><span class="line">      <span class="comment">// 如果集合中没有当前元素</span></span><br><span class="line">      array.<span class="title function_">add</span>(tmp); <span class="comment">// 添加到集合中</span></span><br><span class="line">      maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLength, array.<span class="property">size</span>); <span class="comment">// 更新最大长度</span></span><br><span class="line">      right++; <span class="comment">// 右指针右移</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果集合中已有当前元素</span></span><br><span class="line">      array.<span class="title function_">delete</span>(arr[left]); <span class="comment">// 从集合中删除左指针指向的元素</span></span><br><span class="line">      left++; <span class="comment">// 左指针右移</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxLength; <span class="comment">// 返回最长子数组的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>：是数组中的一个连续部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable language_">global</span> = nums[<span class="number">0</span>];<span class="comment">//初始化 global 和 cur 为数组的第一个元素 nums[0]。</span></span><br><span class="line">    <span class="keyword">let</span> cur = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//从数组的第二个元素开始遍历 (i = 1 到 i = nums.length - 1)。</span></span><br><span class="line"><span class="comment">//对于每个元素 nums[i]，更新 cur 为 nums[i] 和 cur + nums[i] 中的较大值：</span></span><br><span class="line">        cur = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i], cur + nums[i]); <span class="comment">// 更新当前最大子数组和</span></span><br><span class="line">        <span class="keyword">if</span> (cur &gt; <span class="variable language_">global</span>) &#123;</span><br><span class="line">            <span class="variable language_">global</span> = cur; <span class="comment">// 更新全局最大子数组和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">global</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h2><p>一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。子数组是数组中元素的连续非空序列。</p>
<h3 id="解题方法：前缀和-哈希表"><a href="#解题方法：前缀和-哈希表" class="headerlink" title="解题方法：前缀和+哈希表"></a>解题方法：前缀和+哈希表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subarraySum = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mp = <span class="keyword">new</span> <span class="title class_">Map</span>();  <span class="comment">// 哈希表用于存储前缀和及其出现次数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;      <span class="comment">// 记录满足条件的子数组数量</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>;        <span class="comment">// 当前前缀和</span></span><br><span class="line">    mp.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">1</span>);       <span class="comment">// 初始化前缀和为0的出现次数为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        pre += i;       <span class="comment">// 更新当前前缀和</span></span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="title function_">has</span>(pre - k)) &#123;</span><br><span class="line">            <span class="comment">// 如果 (当前前缀和 - k) 存在于哈希表中，说明存在一个子数组的和为 k</span></span><br><span class="line">            count += mp.<span class="title function_">get</span>(pre - k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新当前前缀和在哈希表中的出现次数</span></span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="title function_">has</span>(pre)) &#123;</span><br><span class="line">            mp.<span class="title function_">set</span>(pre, mp.<span class="title function_">get</span>(pre) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mp.<span class="title function_">set</span>(pre, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol>
<li><p><strong>初始化</strong>:</p>
<ul>
<li>创建一个哈希表 <code>mp</code> 来存储每个前缀和的出现次数。</li>
<li>初始化前缀和 <code>pre</code> 为0，并将其在哈希表中的出现次数设置为1（处理从数组开始到当前位置的子数组和为 <code>k</code> 的情况）。</li>
</ul>
</li>
<li><p><strong>遍历数组</strong>:</p>
<ul>
<li>对于每个元素 <code>i</code>，更新前缀和 <code>pre</code>。</li>
<li>检查 <code>pre - k</code> 是否存在于哈希表中。如果存在，说明有子数组和为 <code>k</code>，将出现次数加到 <code>count</code> 上。</li>
<li>更新哈希表中 <code>pre</code> 的出现次数。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>返回符合条件的子数组数量 <code>count</code>。</li>
</ul>
</li>
</ol>
<h3 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><strong>时间复杂度</strong>: O(n)，其中 <code>n</code> 是数组的长度。由于遍历一次数组和哈希表的操作（插入和查找）都是 O(1) 的。</li>
<li><strong>空间复杂度</strong>: O(n)，因为哈希表的大小与数组的长度有关，最坏情况下需要存储所有前缀和。</li>
</ul>
<h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><p>一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p>
<blockquote>
<p> 题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。请 <strong>不要使用除法，</strong>且在 <code>O(*n*)</code> 时间复杂度内完成此题。</p>
</blockquote>
<h3 id="遍历两次，逻辑清晰"><a href="#遍历两次，逻辑清晰" class="headerlink" title="遍历两次，逻辑清晰"></a>遍历两次，逻辑清晰</h3><p>通过两次遍历数组，算法将左侧乘积和右侧乘积分别累积到结果数组中，逻辑简单且直观。以下是两次遍历的具体步骤：</p>
<ol>
<li>第一次遍历：计算左侧乘积<ul>
<li>初始化 <code>left</code> 为 1，遍历数组时，将 <code>left</code> 的值存入 <code>res[i]</code> 中，并更新 <code>left</code> 为当前元素与其乘积。</li>
</ul>
</li>
<li>第二次遍历：计算右侧乘积并计算最终结果<ul>
<li>初始化 <code>right</code> 为 1，从右向左遍历数组时，将 <code>right</code> 与 <code>res[i]</code> 相乘并存回 <code>res[i]</code>，然后更新 <code>right</code> 为当前元素与其乘积。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> productExceptSelf = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充左侧乘积到结果数组</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res[i] = left;</span><br><span class="line">        left *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充右侧乘积到结果数组</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res[i] *= right;</span><br><span class="line">        right *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>



<h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p>思想：基于滑动窗口和哈希表</p>
<ol>
<li><p><strong>滑动窗口</strong>：使用两个指针 <code>left</code> 和 <code>right</code> 维护一个窗口，初始时窗口大小为目标字符串 <code>p</code> 的长度。通过移动指针来扩展或缩小窗口，以在源字符串 <code>s</code> 中寻找符合条件的子串。</p>
</li>
<li><p><strong>哈希表</strong>：创建一个哈希表 <code>pMap</code>，用于记录目标字符串 <code>p</code> 中每个字符的出现次数。然后，通过在遍历源字符串 <code>s</code> 的过程中更新这个哈希表，并根据哈希表的信息来判断窗口内的子串是否符合条件。</p>
</li>
</ol>
<p>算法的具体步骤如下：</p>
<ul>
<li>首先，构建目标字符串 <code>p</code> 的哈希表，记录其中每个字符的出现次数。</li>
<li>然后，使用两个指针 <code>left</code> 和 <code>right</code> 维护一个窗口，在源字符串 <code>s</code> 上进行遍历。</li>
<li>在遍历过程中，每次移动右指针 <code>right</code>，将右指针位置的字符加入窗口中，并更新哈希表。</li>
<li>同时，检查哈希表中记录的字符出现次数，如果在窗口内出现的字符数与目标字符串中相应字符的数目匹配，则计数器 <code>count</code> 减一。</li>
<li>当 <code>count</code> 减为 0 时，表示窗口内的字符与目标字符串中的字符匹配，此时记录窗口的起始位置。</li>
<li>继续移动左指针 <code>left</code>，缩小窗口，直到窗口大小与目标字符串长度相等。</li>
<li>在移动左指针的过程中，同样需要更新哈希表，并根据哈希表中记录的字符出现次数，更新计数器 <code>count</code>。</li>
<li>最后，返回所有符合条件的子串的起始位置。</li>
</ul>
<p>通过滑动窗口和哈希表的方法，可以高效地在源字符串 <code>s</code> 中找到所有与目标字符串 <code>p</code> 是字母异位词的子串的起始索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span> (<span class="params">s, p</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="property">length</span> &lt; p.<span class="property">length</span>) <span class="keyword">return</span> []; <span class="comment">// 如果源字符串长度小于目标字符串长度，则直接返回空数组，因为不可能存在符合条件的子串</span></span><br><span class="line">  <span class="keyword">const</span> pMap = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 创建一个哈希表 pMap，用于记录目标字符串 p 中每个字符的出现次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> p) &#123;</span><br><span class="line">    pMap.<span class="title function_">set</span>(char, (pMap.<span class="title function_">get</span>(char) || <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// 遍历目标字符串 p，更新 pMap 中字符的出现次数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = []; <span class="comment">// 用于存储符合条件的子串的起始索引</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>; <span class="comment">// 左指针初始位置</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">0</span>; <span class="comment">// 右指针初始位置</span></span><br><span class="line">  <span class="keyword">let</span> count = p.<span class="property">length</span>; <span class="comment">// 初始化一个计数器 count，用于记录匹配的字符数量，初始值为目标字符串 p 的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 外部循环，右指针小于源字符串长度时执行</span></span><br><span class="line">    <span class="keyword">const</span> char = s[right]; <span class="comment">// 获取右指针位置的字符</span></span><br><span class="line">    <span class="keyword">if</span> (pMap.<span class="title function_">has</span>(char)) &#123;</span><br><span class="line">      <span class="comment">// 如果 pMap 中存在该字符</span></span><br><span class="line">      <span class="keyword">if</span> (pMap.<span class="title function_">get</span>(char) &gt; <span class="number">0</span>) count--; <span class="comment">// 如果该字符的出现次数大于 0，则将 count 减 1，表示找到了一个匹配的字符</span></span><br><span class="line">      pMap.<span class="title function_">set</span>(char, pMap.<span class="title function_">get</span>(char) - <span class="number">1</span>); <span class="comment">// 将 pMap 中对应字符的出现次数减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    right++; <span class="comment">// 右指针向右移动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count === <span class="number">0</span>) result.<span class="title function_">push</span>(left); <span class="comment">// 如果 count 等于 0，表示找到了一个符合条件的子串，将其起始索引添加到 result 中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right - left === p.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果当前窗口大小等于目标字符串 p 的长度</span></span><br><span class="line">      <span class="keyword">const</span> leftChar = s[left]; <span class="comment">// 获取左指针位置的字符</span></span><br><span class="line">      <span class="keyword">if</span> (pMap.<span class="title function_">has</span>(leftChar)) &#123;</span><br><span class="line">        <span class="comment">// 如果 pMap 中存在该字符</span></span><br><span class="line">        <span class="keyword">if</span> (pMap.<span class="title function_">get</span>(leftChar) &gt;= <span class="number">0</span>) count++; <span class="comment">// 如果该字符的出现次数大于等于 0，则将 count 加 1，表示该字符已经不在窗口中了</span></span><br><span class="line">        pMap.<span class="title function_">set</span>(leftChar, pMap.<span class="title function_">get</span>(leftChar) + <span class="number">1</span>); <span class="comment">// 将 pMap 中对应字符的出现次数加 1，表示该字符已经不在窗口中了</span></span><br><span class="line">      &#125;</span><br><span class="line">      left++; <span class="comment">// 左指针向右移动，准备处理下一个窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回符合条件的子串的起始索引数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num int整型一维数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size int整型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxInWindows</span>(<span class="params">num, size</span>) &#123;</span><br><span class="line">    <span class="comment">// 边界情况处理</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || num.<span class="property">length</span> &lt; size) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> n = num.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> deque = []; <span class="comment">// 双端队列，用来存储当前窗口的最大值的索引</span></span><br><span class="line">    <span class="keyword">let</span> result = []; <span class="comment">// 存储最终结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化双端队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 保持队列单调递减</span></span><br><span class="line">        <span class="keyword">while</span> (deque.<span class="property">length</span> &amp;&amp; num[i] &gt;= num[deque[deque.<span class="property">length</span> - <span class="number">1</span>]]) &#123;</span><br><span class="line">            deque.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加第一个窗口的最大值</span></span><br><span class="line">    result.<span class="title function_">push</span>(num[deque[<span class="number">0</span>]]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历剩余元素，更新窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = size; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 保持双端队列单调递减</span></span><br><span class="line">        <span class="keyword">while</span> (deque.<span class="property">length</span> &amp;&amp; num[i] &gt;= num[deque[deque.<span class="property">length</span> - <span class="number">1</span>]]) &#123;</span><br><span class="line">            deque.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.<span class="title function_">push</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除不在当前窗口的元素</span></span><br><span class="line">        <span class="keyword">while</span> (deque[<span class="number">0</span>] &lt;= i - size) &#123;</span><br><span class="line">            deque.<span class="title function_">shift</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前窗口的最大值</span></span><br><span class="line">        result.<span class="title function_">push</span>(num[deque[<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">maxInWindows</span>: maxInWindows,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>排序法</strong>：</p>
<ul>
<li>先对数组进行排序，然后选择前 k 个数。</li>
</ul>
</li>
<li><p><strong>堆（优先队列）法</strong>：</p>
<ul>
<li>维护一个大小为 k 的最大堆，遍历数组，将每个元素插入堆中。如果堆的大小超过 k，则移除堆顶元素。最后堆中的元素即为最小的 k 个数。</li>
</ul>
<h3 id="解法一–排序"><a href="#解法一–排序" class="headerlink" title="解法一–排序"></a>解法一–排序</h3></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetLeastNumbers_Solution</span>(<span class="params">input, k</span>) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (input.<span class="property">length</span> == <span class="number">1</span> &amp;&amp; k == <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    input.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        arr[i] = input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="title class_">GetLeastNumbers</span><span class="attr">_Solution</span>: <span class="title class_">GetLeastNumbers</span>_Solution,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改进：直接使用 <code>slice</code> 方法来获取最小的 k 个数，而不需要显式地创建和填充新数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetLeastNumbers_Solution</span>(<span class="params">input, k</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="property">length</span> === <span class="number">0</span> || k === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    input.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">return</span> input.<span class="title function_">slice</span>(<span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="title class_">GetLeastNumbers</span><span class="attr">_Solution</span>: <span class="title class_">GetLeastNumbers</span>_Solution,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法二–堆（优先队列）法"><a href="#解法二–堆（优先队列）法" class="headerlink" title="解法二–堆（优先队列）法"></a>解法二–堆（优先队列）法</h3><p>当 k 较小且数组较大时，使用堆的性能会更好。下面是一个使用 JavaScript 中的最小堆实现的方法：</p>
<h4 id="基于堆的代码"><a href="#基于堆的代码" class="headerlink" title="基于堆的代码"></a>基于堆的代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">push</span>(val);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_siftUp</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">extractMax</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> max = <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_siftDown</span>();</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">_siftUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nodeIdx = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nodeIdx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> parentIdx = <span class="title class_">Math</span>.<span class="title function_">floor</span>((nodeIdx - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heap</span>[nodeIdx] &lt;= <span class="variable language_">this</span>.<span class="property">heap</span>[parentIdx]) <span class="keyword">break</span>;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">heap</span>[nodeIdx], <span class="variable language_">this</span>.<span class="property">heap</span>[parentIdx]] = [<span class="variable language_">this</span>.<span class="property">heap</span>[parentIdx], <span class="variable language_">this</span>.<span class="property">heap</span>[nodeIdx]];</span><br><span class="line">            nodeIdx = parentIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">_siftDown</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nodeIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> length = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> leftIdx = <span class="number">2</span> * nodeIdx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> rightIdx = <span class="number">2</span> * nodeIdx + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">let</span> largestIdx = nodeIdx;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftIdx &lt; length &amp;&amp; <span class="variable language_">this</span>.<span class="property">heap</span>[leftIdx] &gt; <span class="variable language_">this</span>.<span class="property">heap</span>[largestIdx]) &#123;</span><br><span class="line">                largestIdx = leftIdx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightIdx &lt; length &amp;&amp; <span class="variable language_">this</span>.<span class="property">heap</span>[rightIdx] &gt; <span class="variable language_">this</span>.<span class="property">heap</span>[largestIdx]) &#123;</span><br><span class="line">                largestIdx = rightIdx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (largestIdx === nodeIdx) <span class="keyword">break</span>;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">heap</span>[nodeIdx], <span class="variable language_">this</span>.<span class="property">heap</span>[largestIdx]] = [<span class="variable language_">this</span>.<span class="property">heap</span>[largestIdx], <span class="variable language_">this</span>.<span class="property">heap</span>[nodeIdx]];</span><br><span class="line">            nodeIdx = largestIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GetLeastNumbers_Solution</span>(<span class="params">input, k</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="property">length</span> === <span class="number">0</span> || k === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= input.<span class="property">length</span>) <span class="keyword">return</span> input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> maxHeap = <span class="keyword">new</span> <span class="title class_">MaxHeap</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="title function_">size</span>() &lt; k) &#123;</span><br><span class="line">            maxHeap.<span class="title function_">insert</span>(input[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input[i] &lt; maxHeap.<span class="title function_">peek</span>()) &#123;</span><br><span class="line">            maxHeap.<span class="title function_">extractMax</span>();</span><br><span class="line">            maxHeap.<span class="title function_">insert</span>(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxHeap.<span class="property">heap</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="title class_">GetLeastNumbers</span><span class="attr">_Solution</span>: <span class="title class_">GetLeastNumbers</span>_Solution,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol>
<li><strong>排序法</strong>：时间复杂度为 O(nlog⁡n)O(n \log n)O(nlogn)，其中 nnn 是数组的长度。</li>
<li><strong>堆法</strong>：时间复杂度为 O(nlog⁡k)O(n \log k)O(nlogk)，其中 nnn 是数组的长度，kkk 是要返回的最小元素的数量。对于较大的数组和较小的 k，这种方法更高效。</li>
</ol>
<h2 id="寻找第K大的数"><a href="#寻找第K大的数" class="headerlink" title="寻找第K大的数"></a>寻找第K大的数</h2><p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。</p>
<p>给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。</p>
<p>要求：时间复杂度 𝑂(𝑛𝑙𝑜𝑔𝑛)，空间复杂度 𝑂(1)</p>
<p>数据范围：0≤𝑛≤10000≤<em>n</em>≤1000， 1≤𝐾≤𝑛1≤<em>K</em>≤<em>n</em>，数组中每个元素满足 0≤𝑣𝑎𝑙≤100000000≤<em>v<strong>a</strong>l</em>≤10000000</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findKth</span>(<span class="params">a, n, K</span>) &#123;</span><br><span class="line">    <span class="comment">// 对数组进行降序排序</span></span><br><span class="line">    a.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回第 K 大的元素</span></span><br><span class="line">    <span class="keyword">return</span> a[K - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">findKth</span>: findKth,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化解法–快速选择"><a href="#优化解法–快速选择" class="headerlink" title="优化解法–快速选择"></a>优化解法–快速选择</h3><p>快速选择是一个更高效的解法，它的平均时间复杂度是 O(n)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findKth</span>(<span class="params">a, n, K</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">quickSelect</span>(<span class="params">arr, left, right, K</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left === right) <span class="keyword">return</span> arr[left];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> pivotIndex = <span class="title function_">partition</span>(arr, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (K === pivotIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[K];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K &lt; pivotIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">quickSelect</span>(arr, left, pivotIndex - <span class="number">1</span>, K);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">quickSelect</span>(arr, pivotIndex + <span class="number">1</span>, right, K);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">arr, left, right</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pivot = arr[right];</span><br><span class="line">        <span class="keyword">let</span> i = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; pivot) &#123; <span class="comment">// 对于找第 K 大的元素，用大于号</span></span><br><span class="line">                [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [arr[i], arr[right]] = [arr[right], arr[i]];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSelect</span>(a, <span class="number">0</span>, n - <span class="number">1</span>, K - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">findKth</span>: findKth,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="选择合适的方法"><a href="#选择合适的方法" class="headerlink" title="选择合适的方法"></a>选择合适的方法</h3><ul>
<li>对于小规模数据，可以直接使用排序法。</li>
<li>对于大规模数据，快速选择法更高效。</li>
</ul>
<h2 id="最小覆盖字串"><a href="#最小覆盖字串" class="headerlink" title="最小覆盖字串"></a>最小覆盖字串</h2><p>描述：给定一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minWindow = <span class="keyword">function</span> (<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果s或者t为空字符串，直接返回空字符串</span></span><br><span class="line">    <span class="keyword">if</span> (!s || !t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个对象，用于存储t中每个字符及其出现的次数</span></span><br><span class="line">    <span class="keyword">let</span> objectString = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> t) &#123;</span><br><span class="line">        objectString[i] = (objectString[i] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化左指针、右指针、字符计数器、已形成字符计数、最小窗口大小、最小窗口字符串</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> count = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> formed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历输入字符串s</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> char = s[right];</span><br><span class="line">        <span class="comment">// 更新字符计数器中当前字符的出现次数</span></span><br><span class="line">        count[char] = (count[char] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果当前字符是t中的字符，并且当前字符在窗口中的出现次数等于t中的出现次数，增加已形成字符计数</span></span><br><span class="line">        <span class="keyword">if</span> (objectString[char] &amp;&amp; count[char] === objectString[char]) &#123;</span><br><span class="line">            formed++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当已形成字符计数等于t中不同字符的数量时，说明当前窗口包含了t中所有字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; formed === <span class="title class_">Object</span>.<span class="title function_">keys</span>(objectString).<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算当前窗口大小</span></span><br><span class="line">            <span class="keyword">const</span> size = right - left + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果当前窗口大小比最小窗口大小小，更新最小窗口大小和对应的字符串</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt; min) &#123;</span><br><span class="line">                min = size;</span><br><span class="line">                res = s.<span class="title function_">substring</span>(left, right + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动左指针，并更新左指针指向的字符在窗口中的出现次数</span></span><br><span class="line">            <span class="keyword">const</span> leftChar = s[left];</span><br><span class="line">            count[leftChar]--;</span><br><span class="line">            <span class="comment">// 如果左指针指向的字符是t中的字符，并且在窗口中的出现次数小于t中的出现次数，减少已形成字符计数</span></span><br><span class="line">            <span class="keyword">if</span> (objectString[leftChar] &amp;&amp; count[leftChar] &lt; objectString[leftChar]) &#123;</span><br><span class="line">                formed--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++; <span class="comment">// 移动左指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        right++; <span class="comment">// 移动右指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小窗口字符串</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二种方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minWindow = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || !t) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> str = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> t) &#123;</span><br><span class="line">        str[i] = (str[i] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>, count = &#123;&#125;, required = <span class="title class_">Object</span>.<span class="title function_">keys</span>(str).<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> formed = <span class="number">0</span>, minLength = <span class="title class_">Infinity</span>, minLeft = <span class="number">0</span>, minRight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> rightChar = s[right];</span><br><span class="line">        count[rightChar] = (count[rightChar] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (str[rightChar] &amp;&amp; count[rightChar] === str[rightChar]) &#123;</span><br><span class="line">            formed++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; formed === required) &#123;</span><br><span class="line">            <span class="keyword">let</span> leftChar = s[left];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((right - left + <span class="number">1</span>) &lt; minLength) &#123;</span><br><span class="line">                minLength = right - left + <span class="number">1</span>;</span><br><span class="line">                minLeft = left;</span><br><span class="line">                minRight = right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            count[leftChar]--;</span><br><span class="line">            <span class="keyword">if</span> (str[leftChar] &amp;&amp; count[leftChar] &lt; str[leftChar]) &#123;</span><br><span class="line">                formed--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minLength === <span class="title class_">Infinity</span> ? <span class="string">&quot;&quot;</span> : s.<span class="title function_">substring</span>(minLeft, minRight + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LRU缓存-1"><a href="#LRU缓存-1" class="headerlink" title="LRU缓存"></a>LRU缓存</h2><p>设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 capacity ，操作次数是 n ，并有如下功能:</p>
<ol>
<li>Solution(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li>get(key)：如果关键字 key 存在于缓存中，则返回key对应的value值，否则返回 -1 。</li>
<li>set(key, value)：将记录(key, value)插入该结构，如果关键字 key 已经存在，则变更其数据值 value，如果不存在，则向缓存中插入该组 key-value ，如果key-value的数量超过capacity，弹出最久未使用的key-value</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">LRUCache</span> = <span class="keyword">function</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 用于存储 key 到节点的映射</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 虚拟尾节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_remove</span>(node);  <span class="comment">// 从当前位置移除该节点</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_add</span>(node);     <span class="comment">// 将该节点移到头部</span></span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">value</span>;   <span class="comment">// 返回对应的值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 缓存中不存在该 key</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_remove</span>(<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(key));  <span class="comment">// 如果已经存在，先移除旧节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(key, value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_add</span>(newNode);   <span class="comment">// 将新节点添加到头部</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(key, newNode);  <span class="comment">// 更新哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">map</span>.<span class="property">size</span> &gt; <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> tail = <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_remove</span>(tail);   <span class="comment">// 移除最久未使用的节点（链表尾部节点）</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(tail.<span class="property">key</span>); <span class="comment">// 删除哈希表中的映射</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部函数：将节点移到双向链表的头部</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_add</span> = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    node.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">    node.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>.<span class="property">prev</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span> = node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部函数：从双向链表中移除节点</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_remove</span> = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    node.<span class="property">prev</span>.<span class="property">next</span> = node.<span class="property">next</span>;</span><br><span class="line">    node.<span class="property">next</span>.<span class="property">prev</span> = node.<span class="property">prev</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二倍数对数组"><a href="#二倍数对数组" class="headerlink" title="二倍数对数组"></a>二倍数对数组</h2><p>给定一个长度为偶数的整数数组 <code>arr</code>，只有对 <code>arr</code> 进行重组后可以满足 “对于每个 <code>0 &lt;= i &lt; len(arr) / 2</code>，都有 <code>arr[2 * i + 1] = 2 * arr[2 * i]</code>” 时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题的核心在于如何将数组进行重组，使得重组后的数组满足特定条件：对于每个 <code>0 &lt;= i &lt; len(arr) / 2</code>，都有 <code>arr[2 * i + 1] = 2 * arr[2 * i]</code>。这个条件实际上要求数组的一半元素是另一半元素的两倍。</p>
<p>为了实现这一点，我们可以采用以下步骤：</p>
<ol>
<li><strong>排序</strong>：将数组进行排序，以便我们能轻松地找到符合条件的元素对。</li>
<li><strong>计数</strong>：使用一个计数器来记录数组中每个元素的出现次数。</li>
<li><strong>匹配</strong>：从最小的元素开始，尝试匹配每个元素和它的两倍。如果能够找到这样的配对，则继续，否则返回 <code>false</code>。</li>
</ol>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li>将数组进行排序。</li>
<li>遍历排序后的数组，使用一个哈希表来记录每个元素的出现次数。</li>
<li>对于每个元素，如果当前元素已经被匹配过（计数为零），则跳过。否则，检查它的两倍是否存在且计数大于零。如果存在，则将两个元素的计数都减一。</li>
<li>如果所有元素都能找到匹配，则返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ol>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canReorderDoubled = <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 长度必须为偶数</span></span><br><span class="line"></span><br><span class="line">    arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(a) - <span class="title class_">Math</span>.<span class="title function_">abs</span>(b)); <span class="comment">// 按绝对值排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> count = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        count.<span class="title function_">set</span>(num, (count.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.<span class="title function_">get</span>(num) === <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 已匹配过，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (count.<span class="title function_">get</span>(num * <span class="number">2</span>) === <span class="literal">undefined</span> || count.<span class="title function_">get</span>(num * <span class="number">2</span>) === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 找不到配对</span></span><br><span class="line">        count.<span class="title function_">set</span>(num, count.<span class="title function_">get</span>(num) - <span class="number">1</span>); <span class="comment">// 减少当前元素的计数</span></span><br><span class="line">        count.<span class="title function_">set</span>(num * <span class="number">2</span>, count.<span class="title function_">get</span>(num * <span class="number">2</span>) - <span class="number">1</span>); <span class="comment">// 减少配对元素的计数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：$O(n \log n)$，主要由排序步骤决定。</li>
<li><strong>空间复杂度</strong>：$O(n)$，哈希表存储每个元素的计数。</li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>通过排序和计数相结合的方法，我们能够有效地判断数组是否能重组成满足条件的形式。这种方法确保了我们能在合理的时间和空间复杂度内解决问题。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化三个变量 p, q, r</span></span><br><span class="line">    <span class="comment">// p 表示到达 n-2 阶的方法数</span></span><br><span class="line">    <span class="comment">// q 表示到达 n-1 阶的方法数</span></span><br><span class="line">    <span class="comment">// r 表示到达 n 阶的方法数</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第 1 阶开始，循环到第 n 阶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 更新 p, q, r 的值</span></span><br><span class="line">        <span class="comment">// p 变为之前 q 的值</span></span><br><span class="line">        p = q;</span><br><span class="line">        <span class="comment">// q 变为之前 r 的值</span></span><br><span class="line">        q = r;</span><br><span class="line">        <span class="comment">// r 变为之前 q 和 p 的和，即当前的 q 和 p</span></span><br><span class="line">        r = q + p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环结束后，r 表示到达第 n 阶的方法总数</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法2–动态规划"><a href="#解法2–动态规划" class="headerlink" title="解法2–动态规划"></a>解法2–动态规划</h3><p>利用动态规划的思想</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 n 为 1，直接返回 1，因为只有一种方法</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个数组 dp，用于存储到达每一阶的方法数</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化 dp[0] 和 dp[1]</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 到达第 0 阶的方法数</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 到达第 1 阶的方法数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第 2 阶开始，依次计算到达每一阶的方法数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 到达第 i 阶的方法数是到达第 i-1 阶的方法数和到达第 i-2 阶的方法数之和</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回到达第 n 阶的方法数</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generate = <span class="keyword">function</span> (<span class="params">numRows</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化一个空的二维数组，用于存储杨辉三角的每一行</span></span><br><span class="line">    <span class="keyword">let</span> dp = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历每一行，从第0行到第numRows-1行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化当前行，并将所有元素设为1</span></span><br><span class="line">        <span class="comment">// 因为杨辉三角的每行首尾元素都是1</span></span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(i + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第二个元素到倒数第二个元素进行计算</span></span><br><span class="line">        <span class="comment">// 因为每行的第一个和最后一个元素都是1，不需要重新计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 当前元素的值等于上一行的左上方元素和右上方元素之和</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回生成的杨辉三角</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="杨辉三角-1"><a href="#杨辉三角-1" class="headerlink" title="杨辉三角 ||"></a>杨辉三角 ||</h2><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<ol>
<li>我们定义了一个函数 <code>getRow</code>，它接受一个整数 <code>rowIndex</code> 作为参数，并返回杨辉三角的第 <code>rowIndex</code> 行。</li>
<li>我们初始化了一个数组 <code>dp</code>，它的长度为 <code>rowIndex + 1</code>，并且所有的元素都被初始化为 <code>1</code>。我们使用这个数组来存储当前行的值。</li>
<li>我们开始一个外部循环，从 <code>1</code> 开始一直到 <code>rowIndex</code> 结束。这个循环用来生成每一行的值。</li>
<li>在内部循环中，我们从当前行的倒数第二个位置开始向前遍历，直到第一个位置。这是因为在杨辉三角中，除了第一个和最后一个位置的元素为 <code>1</code>，其他位置的元素是由上一行的两个相邻元素相加而得到的。</li>
<li>在内部循环中，我们更新当前行的值。对于当前行的第 <code>j</code> 个元素，它的值等于上一行的第 <code>j - 1</code> 个元素和第 <code>j</code> 个元素之和。这就是杨辉三角的定义。</li>
<li>内部循环结束后，当前行的所有元素已经更新完毕。</li>
<li>最后，我们返回生成的第 <code>rowIndex</code> 行的数组 <code>dp</code>。</li>
</ol>
<p>通过这段代码，我们可以生成杨辉三角的第 <code>rowIndex</code> 行。它的时间复杂度为 O(n^2)，其中 n 是 <code>rowIndex</code> 的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getRow = <span class="keyword">function</span> (<span class="params">rowIndex</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化数组，长度为 rowIndex + 1，初始值为 1</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(rowIndex + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成每一行的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">        <span class="comment">// 更新当前行的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            dp[j] = dp[j - <span class="number">1</span>] + dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回第 rowIndex 行的结果</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果没有房屋，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]; <span class="comment">// 如果只有一个房屋，返回该房屋的金额</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化 dp 数组，长度为 nums.length，初始值为 0</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一个房屋的最高金额即为该房屋的金额</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个房屋的最高金额是前两个房屋中金额较大的那个</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第三个房屋开始，计算每个房屋的最高抢劫金额</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前房屋的最高金额是以下两者的较大值：</span></span><br><span class="line">        <span class="comment">// 1. 不抢劫当前房屋时的最高金额 (dp[i-1])</span></span><br><span class="line">        <span class="comment">// 2. 抢劫当前房屋时的最高金额 (dp[i-2] + nums[i])</span></span><br><span class="line">        dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回抢劫到最后一个房屋的最高金额</span></span><br><span class="line">    <span class="keyword">return</span> dp[nums.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h2><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法<strong>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setZeroes = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = matrix.<span class="property">length</span>, n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> row = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> col = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记含有零的行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">                row[i] = col[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将标记的行和列设置为零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> [];  <span class="comment">// 如果矩阵为空，返回空数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> top = <span class="number">0</span>, bottom = matrix.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 从左到右遍历上边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(matrix[top][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        top++;  <span class="comment">// 上边界向下收缩</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从上到下遍历右边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = top; i &lt;= bottom; i++) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(matrix[i][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        right--;  <span class="comment">// 右边界向左收缩</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (top &lt;= bottom) &#123;  <span class="comment">// 防止在单行矩阵情况下重复遍历</span></span><br><span class="line">            <span class="comment">// 从右到左遍历下边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt;= left; i--) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;  <span class="comment">// 下边界向上收缩</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;  <span class="comment">// 防止在单列矩阵情况下重复遍历</span></span><br><span class="line">            <span class="comment">// 从下到上遍历左边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = bottom; i &gt;= top; i--) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;  <span class="comment">// 左边界向右收缩</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><p>一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。将图像顺时针旋转 90 度。必须在原地旋转图像，需要直接修改输入的二维矩阵。不能使用另一个矩阵来旋转图像。</p>
<h3 id="解题思想-7"><a href="#解题思想-7" class="headerlink" title="解题思想"></a>解题思想</h3><ol>
<li><p><strong>转置矩阵</strong>：</p>
<ul>
<li><strong>定义</strong>：矩阵的转置是将矩阵的行和列互换的操作。</li>
<li><strong>步骤</strong>：<ul>
<li>遍历矩阵的每个元素（仅遍历上三角区域，以避免重复交换），将元素 <code>matrix[i][j]</code> 和 <code>matrix[j][i]</code> 互换。</li>
<li>这样可以把矩阵的行变成列，实现了对角线（从左上角到右下角）的镜像对称。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>反转每一行</strong>：</p>
<ul>
<li><strong>定义</strong>：反转每一行意味着将行中的元素顺序反转。</li>
<li><strong>步骤</strong>：<ul>
<li>对转置后的每一行执行反转操作，这样可以完成顺时针旋转 90 度的目标。</li>
<li>反转每一行将原来的列顺序变为行顺序，从而实现了旋转。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="keyword">function</span> (<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = matrix.<span class="property">length</span>;  <span class="comment">// 获取矩阵的行数（和列数），因为是 n x n 矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：转置矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 遍历矩阵的每一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; n; j++) &#123;  <span class="comment">// 遍历矩阵的每一列，从 i 开始以避免重复交换</span></span><br><span class="line">            <span class="comment">// 交换 matrix[i][j] 和 matrix[j][i]</span></span><br><span class="line">            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：反转每一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 遍历矩阵的每一行</span></span><br><span class="line">        matrix[i].<span class="title function_">reverse</span>();  <span class="comment">// 反转当前行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>转置矩阵</strong>：交换矩阵的行和列，使得矩阵沿对角线对称。</li>
<li><strong>反转每一行</strong>：将转置后的每一行反转，使得矩阵变成顺时针旋转 90 度的状态。</li>
</ol>
<p>这种方法的时间复杂度是 ( O(n^2) )，空间复杂度是 ( O(1) )（原地操作）。这是因为我们只使用了原始矩阵，并且操作只涉及到元素的交换和行的反转。</p>
<h2 id="搜索二维矩阵-1"><a href="#搜索二维矩阵-1" class="headerlink" title="搜索二维矩阵 ||"></a>搜索二维矩阵 ||</h2><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<blockquote>
<p>这道题的解题思想是利用矩阵的排序性质进行高效搜索。具体来说，每行的元素从左到右升序排列，每列的元素从上到下升序排列。这些性质允许我们从矩阵的某个角落开始，通过逐步排除不可能的区域来缩小搜索范围。我们可以选择从矩阵的右上角（或者左下角）开始搜索，因为这样我们可以根据当前元素和目标值的比较结果决定移动的方向，从而高效地进行搜索。</p>
</blockquote>
<h3 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li><p><strong>选择起始点</strong>：从矩阵的右上角开始搜索。右上角的元素是当前行中的最大值，同时也是当前列中的最小值。</p>
</li>
<li><p>比较目标值与当前元素</p>
<p>：</p>
<ul>
<li>如果当前元素等于目标值，返回 <code>true</code>。</li>
<li>如果当前元素小于目标值，说明目标值可能在当前行的下方，因此向下移动一行。</li>
<li>如果当前元素大于目标值，说明目标值可能在当前列的左侧，因此向左移动一列。</li>
</ul>
</li>
<li><p><strong>更新搜索范围</strong>：根据比较结果，更新行或列的索引，继续搜索，直到找到目标值或搜索范围超出矩阵的边界。</p>
</li>
<li><p><strong>返回结果</strong>：如果在搜索过程中找到目标值，返回 <code>true</code>；如果搜索完成后仍未找到目标值，返回 <code>false</code>。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="keyword">function</span> (<span class="params">matrix, target</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取矩阵的行数 m 和列数 n</span></span><br><span class="line">    <span class="keyword">let</span> m = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化起始位置为矩阵的右上角</span></span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> col = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环进行搜索，直到行或列超出边界</span></span><br><span class="line">    <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了目标值，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果当前元素小于目标值，向下移动一行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[row][col]) &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果当前元素大于目标值，向左移动一列</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果未找到目标值，返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：$O(m + n)$，其中 $m$ 是矩阵的行数，$n$ 是矩阵的列数。在最坏的情况下，我们可能会从右上角走到左下角，遍历矩阵中的所有行和列。</li>
<li><strong>空间复杂度</strong>：$O(1)$，只使用了常数级别的额外空间。</li>
</ul>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>这种方法充分利用了矩阵的排序性质，从右上角开始搜索，通过比较当前元素和目标值来决定移动方向，逐步排除不可能的区域，从而高效地找到目标值。</p>
<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>code：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">canPartition</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算数组总和</span></span><br><span class="line">    <span class="keyword">const</span> totalSum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果总和是奇数，则不能平分</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算目标子集的和，即总和的一半</span></span><br><span class="line">    <span class="keyword">const</span> target = <span class="title class_">Math</span>.<span class="title function_">floor</span>(totalSum / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 创建一个布尔数组 dp，长度为 target + 1，并初始化为 false</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="title class_">Array</span>(target + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// dp[0] 设为 true，表示和为 0 的子集是存在的（空集）</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 nums 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="comment">// 倒序遍历 dp 数组，从 target 到 num</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = target; j &gt;= num; j--) &#123;</span><br><span class="line">            <span class="comment">// 更新 dp[j] 的值，如果 dp[j - num] 为 true，则 dp[j] 也为 true</span></span><br><span class="line">            dp[j] = dp[j] || dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回 dp[target]，表示是否存在和为 target 的子集</span></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><strong>计算总和</strong>：首先，使用 <code>reduce</code> 方法计算数组 <code>nums</code> 的总和 <code>totalSum</code>。</li>
<li><strong>检查总和是否为奇数</strong>：如果 <code>totalSum</code> 是奇数，则不能将数组分割成两个和相等的子集，直接返回 <code>false</code>。</li>
<li><strong>初始化动态规划数组</strong>：创建一个布尔数组 <code>dp</code>，长度为 <code>target + 1</code>，并初始化为 <code>false</code>。<code>dp[0]</code> 设为 <code>true</code>，表示和为 0 的子集是存在的（空集）。</li>
<li><strong>动态规划状态转移</strong>：遍历数组 <code>nums</code> 中的每个元素 <code>num</code>，从大到小更新 <code>dp</code> 数组。对于每个 <code>num</code>，如果 <code>dp[j - num]</code> 为 <code>true</code>，则设置 <code>dp[j]</code> 为 <code>true</code>。</li>
<li><strong>返回结果</strong>：最终返回 <code>dp[target]</code>，表示是否存在和为 <code>target</code> 的子集。</li>
</ol>
<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p>要找出只包含 ‘(‘ 和 ‘)’ 的字符串中最长有效括号子串的长度，可以使用动态规划或栈的方法。这里先介绍使用栈的方法。</p>
<h3 id="方法一：使用栈"><a href="#方法一：使用栈" class="headerlink" title="方法一：使用栈"></a>方法一：使用栈</h3><p>栈可以用来追踪括号的位置，并帮助我们确定有效括号子串的长度。</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>初始化一个栈，栈底放一个初始值 <code>-1</code>（表示未匹配的右括号的索引）。</li>
<li>遍历字符串：<ul>
<li>如果遇到左括号 <code>&#39;(&#39;</code>，将它的索引压入栈中。</li>
<li>如果遇到右括号 <code>&#39;)&#39;</code>：<ul>
<li>先弹出栈顶元素，表示匹配了一个左括号。</li>
<li>如果栈为空，将当前索引压入栈中（表示新的未匹配的右括号的索引）。</li>
<li>如果栈不为空，计算当前右括号的索引与栈顶元素的索引的差值，这个差值就是当前有效括号子串的长度，并更新最大长度。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="code：-4"><a href="#code：-4" class="headerlink" title="code："></a>code：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">longestValidParentheses</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> stack = [-<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (stack.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                stack.<span class="title function_">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLength, i - stack[stack.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>动态规划方法需要用一个数组 <code>dp</code> 来记录以每个字符为结尾的最长有效括号子串的长度。</p>
<h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>初始化一个 <code>dp</code> 数组，所有元素初始化为 0。</li>
<li>遍历字符串：<ul>
<li>如果当前字符是右括号 <code>&#39;)&#39;</code> 并且前一个字符是左括号 <code>&#39;(&#39;</code>，则更新 <code>dp</code> 数组。</li>
<li>如果当前字符是右括号 <code>&#39;)&#39;</code> 并且前一个字符是右括号 <code>&#39;)&#39;</code>，则检查是否能形成一个更长的有效括号子串，并更新 <code>dp</code> 数组。</li>
</ul>
</li>
<li>最后，返回 <code>dp</code> 数组中的最大值。</li>
</ol>
<h4 id="code：-5"><a href="#code：-5" class="headerlink" title="code："></a>code：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">longestValidParentheses</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + (i - dp[i - <span class="number">1</span>] &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLength, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方法都可以有效地找到最长有效括号子串的长度，可以根据具体需求选择适合的方法。</p>
<h1 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h1><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？</p>
<p>这个问题可以用动态规划来解决。机器人从左上角走到右下角，每次只能向下或向右移动一步，问总共有多少种不同的路径。</p>
<h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><p>我们可以定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示从起始点 <code>(0, 0)</code> 到达网格 <code>(i, j)</code> 的不同路径数目。</p>
<h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><ol>
<li>起始点 <code>(0, 0)</code> 到达自身的路径数目为 <code>1</code>，因此 <code>dp[0][0] = 1</code>。</li>
</ol>
<h4 id="状态转移："><a href="#状态转移：" class="headerlink" title="状态转移："></a>状态转移：</h4><p>对于每个位置 <code>(i, j)</code>，可以从上方 <code>(i-1, j)</code> 或左侧 <code>(i, j-1)</code> 到达：</p>
<ul>
<li>如果当前位置在第一行 <code>i == 0</code>，只能从左侧到达，即 <code>dp[0][j] = dp[0][j-1]</code>。</li>
<li>如果当前位置在第一列 <code>j == 0</code>，只能从上方到达，即 <code>dp[i][0] = dp[i-1][0]</code>。</li>
<li>否则，路径数目为上方和左侧的路径数目之和，即 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>。</li>
</ul>
<h4 id="最终结果："><a href="#最终结果：" class="headerlink" title="最终结果："></a>最终结果：</h4><p>目标是求解 <code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。</p>
<h4 id="实现代码：-1"><a href="#实现代码：-1" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniquePaths</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="comment">// Initialize a 2D array for dp</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Base case: Start point</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fill the dp table</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] += dp[i-<span class="number">1</span>][j]; <span class="comment">// Add from top</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] += dp[i][j-<span class="number">1</span>]; <span class="comment">// Add from left</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return the number of unique paths to the bottom-right corner</span></span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释-5"><a href="#解释-5" class="headerlink" title="解释"></a>解释</h3><ul>
<li>我们首先初始化一个 <code>dp</code> 数组，大小为 <code>m x n</code>，所有元素初始化为 <code>0</code>。</li>
<li>起始点 <code>(0, 0)</code> 的路径数目为 <code>1</code>。</li>
<li>使用双重循环遍历整个网格，更新 <code>dp[i][j]</code> 的值，根据上方和左侧的路径数目更新当前位置的路径数目。</li>
<li>最后返回 <code>dp[m-1][n-1]</code>，即到达右下角的路径数目。</li>
</ul>
<p>这样的动态规划解法时间复杂度为 <code>O(m * n)</code>，空间复杂度为 <code>O(m * n)</code>，适用于给定的网格大小。</p>
<h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<h3 id="解题思想-8"><a href="#解题思想-8" class="headerlink" title="解题思想"></a>解题思想</h3><ol>
<li><p><strong>动态规划（Dynamic Programming）：</strong></p>
<ul>
<li>动态规划是一种将复杂问题分解成更小的子问题，并存储每个子问题的结果以避免重复计算的方法。</li>
<li>在这个问题中，我们需要找到从左上角到右下角的路径，使得路径上的数字总和最小。</li>
</ul>
</li>
<li><p><strong>定义状态：</strong></p>
<ul>
<li>用二维数组 <code>dp</code> 存储到达每个格子 <code>(i, j)</code> 的最小路径和，其中 <code>dp[i][j]</code> 表示到达 <code>(i, j)</code> 的最小路径和。</li>
</ul>
</li>
<li><p><strong>状态转移方程：</strong></p>
<ul>
<li>对于起点 <code>(0, 0)</code>，<code>dp[0][0] = grid[0][0]</code>。</li>
<li>对于第一行的任意格子 <code>(0, j)</code>，只能从左侧到达，<code>dp[0][j] = dp[0][j - 1] + grid[0][j]</code>。</li>
<li>对于第一列的任意格子 <code>(i, 0)</code>，只能从上方到达，<code>dp[i][0] = dp[i - 1][0] + grid[i][0]</code>。</li>
<li>对于其他格子 <code>(i, j)</code>，可以从上方或左侧到达，<code>dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code>。</li>
</ul>
</li>
<li><p><strong>初始条件和边界条件：</strong></p>
<ul>
<li>初始条件是起点的值：<code>dp[0][0] = grid[0][0]</code>。</li>
<li>边界条件是第一行和第一列的处理。</li>
</ul>
</li>
<li><p><strong>计算顺序：</strong></p>
<ul>
<li>从左上角开始，逐行逐列计算，依次填充 <code>dp</code> 数组。</li>
</ul>
</li>
<li><p><strong>返回结果：</strong></p>
<ul>
<li>最终结果是 <code>dp[m - 1][n - 1]</code>，即到达右下角的最小路径和。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minPathSum = <span class="keyword">function</span> (<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取网格的行数</span></span><br><span class="line">    <span class="keyword">let</span> m = grid.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 获取网格的列数</span></span><br><span class="line">    <span class="keyword">let</span> n = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，大小与网格相同，并填充为 0</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始化起点 dp[0][0] 为 grid[0][0]</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历网格的每一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历网格的每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 跳过起点，因为已初始化</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果在第一行，只能从左侧到达</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果在第一列，只能从上方到达</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 其他情况，取从上方和左侧路径中的较小值，加上当前格子的值</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回到达右下角的最小路径和</span></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时间和空间复杂度分析"><a href="#时间和空间复杂度分析" class="headerlink" title="时间和空间复杂度分析"></a>时间和空间复杂度分析</h3><ol>
<li><p><strong>时间复杂度：</strong></p>
<ul>
<li>遍历整个 <code>m x n</code> 的网格，每个格子都进行常数时间的计算。</li>
<li>总的时间复杂度为 <code>O(m * n)</code>。</li>
</ul>
</li>
<li><p><strong>空间复杂度：</strong></p>
<ul>
<li>使用了一个大小为 <code>m x n</code> 的二维数组 <code>dp</code> 来存储中间结果。</li>
<li>总的空间复杂度为 <code>O(m * n)</code>。</li>
</ul>
</li>
</ol>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文子串。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<h3 id="解题思想-9"><a href="#解题思想-9" class="headerlink" title="解题思想"></a>解题思想</h3><p>这里我们使用动态规划的方法来解决这个问题。我们定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示字符串 <code>s</code> 从第 <code>i</code> 个字符到第 <code>j</code> 个字符（即 <code>s[i:j+1]</code>）是否是回文串。</p>
<h4 id="动态规划的状态转移方程："><a href="#动态规划的状态转移方程：" class="headerlink" title="动态规划的状态转移方程："></a>动态规划的状态转移方程：</h4><ul>
<li>如果 <code>s[i] == s[j]</code> 并且 <code>j - i &lt;= 2</code>（即两个字符相同且之间的字符数小于等于1，例如”aa”或”aba”），则 <code>dp[i][j] = true</code>。</li>
<li>如果 <code>s[i] == s[j]</code> 并且 <code>dp[i + 1][j - 1] == true</code>，则 <code>dp[i][j] = true</code>。</li>
<li>其他情况下，<code>dp[i][j] = false</code>。</li>
</ul>
<p>我们需要遍历所有的子串，找出最长的回文子串。</p>
<h4 id="复杂度分析：-3"><a href="#复杂度分析：-3" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n^2)</li>
</ul>
<h3 id="code：-6"><a href="#code：-6" class="headerlink" title="code："></a>code：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 DP 表</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个单字符子串都是回文</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充 DP 表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == s[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - j &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    dp[j][i] = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j][i] = dp[j + <span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[j][i] &amp;&amp; (i - j + <span class="number">1</span>) &gt; maxLength) &#123;</span><br><span class="line">                maxLength = i - j + <span class="number">1</span>;</span><br><span class="line">                start = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最长回文子串</span></span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">substring</span>(start, start + maxLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>dp</code> 数组表示 <code>s[i:j+1]</code> 是否为回文。</li>
<li><code>maxLength</code> 保存当前最长回文子串的长度。</li>
<li><code>start</code> 保存当前最长回文子串的起始位置。</li>
</ul>
</li>
<li><p><strong>单字符回文初始化</strong>：</p>
<ul>
<li>所有单个字符都是回文，初始化 <code>dp[i][i] = true</code>。</li>
</ul>
</li>
<li><p><strong>状态转移</strong>：</p>
<ul>
<li>双重循环遍历所有子串。</li>
<li>如果 <code>s[start] == s[end]</code> 并且 <code>end - start &lt;= 2</code> 或 <code>dp[start + 1][end - 1]</code> 为真，则更新 <code>dp[start][end]</code>。</li>
<li>如果当前子串为回文且长度超过 <code>maxLength</code>，更新 <code>maxLength</code> 和 <code>start</code>。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>从 <code>start</code> 开始，长度为 <code>maxLength</code> 的子串就是最长回文子串。</li>
</ul>
</li>
</ol>
<p>这种方法时间复杂度和空间复杂度都是 O(n^2)，在可接受范围内，可以在大多数情况下有效解决问题。</p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<blockquote>
<p>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</p>
</blockquote>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p>当使用JavaScript解决最长公共子序列（LCS）的问题时，可以采用类似动态规划的方法来实现。以下是具体的解题思路、代码实现以及复杂度分析：</p>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="动态规划方法："><a href="#动态规划方法：" class="headerlink" title="动态规划方法："></a>动态规划方法：</h4><ol>
<li><p><strong>定义状态</strong>：我们定义 <code>dp[i][j]</code> 表示 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的最长公共子序列的长度。</p>
</li>
<li><p><strong>状态转移方程</strong>：</p>
<ul>
<li>如果 <code>text1[i-1] === text2[j-1]</code>，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。即当前字符相同时，最长公共子序列长度加一。</li>
<li>否则，<code>dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])</code>。当前字符不同时，取前一个状态的最大值。</li>
</ul>
</li>
<li><p><strong>边界条件</strong>：初始化 <code>dp</code> 数组，确保空字符串的情况下最长公共子序列长度为 0。</p>
</li>
<li><p><strong>求解目标</strong>：<code>dp[m][n]</code> 即为 <code>text1</code> 和 <code>text2</code> 的最长公共子序列的长度，其中 <code>m</code> 和 <code>n</code> 分别是 <code>text1</code> 和 <code>text2</code> 的长度。</p>
</li>
</ol>
<h3 id="code：-7"><a href="#code：-7" class="headerlink" title="code："></a>code：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="keyword">function</span> (<span class="params">text1, text2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = text1.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = text2.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建二维数组 dp，注意这里要初始化 m+1 行和 n+1 列</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意循环从 1 开始，因为 dp 数组多出来的一行一列是用来处理空字符串的情况的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">// 注意这里要比较的是 text1[i-1] 和 text2[j-1]</span></span><br><span class="line">            <span class="keyword">if</span> (text1[i - <span class="number">1</span>] === text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 dp 数组的右下角元素，即最长公共子序列的长度</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="逐行代码分析"><a href="#逐行代码分析" class="headerlink" title="逐行代码分析"></a>逐行代码分析</h3><ul>
<li><p><code>function longestCommonSubsequence(text1, text2) &#123;</code>：定义函数 <code>longestCommonSubsequence</code>，接收两个字符串 <code>text1</code> 和 <code>text2</code>。</p>
</li>
<li><p><code>const m = text1.length;</code> 和 <code>const n = text2.length;</code>：获取 <code>text1</code> 和 <code>text2</code> 的长度。</p>
</li>
<li><p><code>const dp = Array.from(Array(m + 1), () =&gt; Array(n + 1).fill(0));</code>：创建一个二维数组 <code>dp</code>，其大小为 <code>(m+1) x (n+1)</code>，并初始化为 0。</p>
</li>
<li><p><code>for (let i = 1; i &lt;= m; i++) &#123;</code> 和 <code>for (let j = 1; j &lt;= n; j++) &#123;</code>：双重循环遍历 <code>text1</code> 和 <code>text2</code> 的所有字符。</p>
</li>
<li><p><code>if (text1[i - 1] === text2[j - 1]) &#123;</code>：判断当前字符是否相等。</p>
</li>
<li><p><code>dp[i][j] = dp[i - 1][j - 1] + 1;</code>：如果相等，则更新 <code>dp[i][j]</code> 为左上角元素加一，即最长公共子序列长度加一。</p>
</li>
<li><p><code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</code>：如果不相等，则取左边或上边的较大值，保证 <code>dp[i][j]</code> 为当前的最长公共子序列长度。</p>
</li>
<li><p><code>return dp[m][n];</code>：返回 <code>dp</code> 数组的最后一个元素，即 <code>text1</code> 和 <code>text2</code> 的最长公共子序列的长度。</p>
</li>
</ul>
<h3 id="时间复杂度和空间复杂度分析"><a href="#时间复杂度和空间复杂度分析" class="headerlink" title="时间复杂度和空间复杂度分析"></a>时间复杂度和空间复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>：双重循环遍历了 <code>text1</code> 和 <code>text2</code>，因此时间复杂度为 <code>O(m * n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是 <code>text1</code> 和 <code>text2</code> 的长度。</p>
</li>
<li><p><strong>空间复杂度</strong>：使用了 <code>(m+1) x (n+1)</code> 大小的二维数组 <code>dp</code>，因此空间复杂度为 <code>O(m * n)</code>。</p>
</li>
</ul>
<p>这种动态规划方法在JavaScript中同样有效地解决了求解两个字符串最长公共子序列长度的问题，具有较高的时间和空间效率。</p>
<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>要解决将 <code>word1</code> 转换为 <code>word2</code> 的最少操作数问题，我们可以使用动态规划的方法。这种方法通常适用于解决字符串之间的编辑距离问题，可以进行插入、删除和替换操作。</p>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>定义状态</strong>：</p>
<ul>
<li>定义 <code>dp[i][j]</code> 表示将 <code>word1</code> 的前 <code>i</code> 个字符转换为 <code>word2</code> 的前 <code>j</code> 个字符所需的最少操作数。</li>
</ul>
</li>
<li><p><strong>状态转移方程</strong>：</p>
<ul>
<li>如果 <code>word1[i-1] === word2[j-1]</code>，即当前字符相同，则 <code>dp[i][j] = dp[i-1][j-1]</code>，不需要额外操作。</li>
<li>否则，需要考虑三种操作情况：<ul>
<li><strong>插入</strong>：<code>dp[i][j] = dp[i][j-1] + 1</code>，即在 <code>word1</code> 的前 <code>i</code> 个字符后插入一个字符，使得与 <code>word2</code> 的前 <code>j</code> 个字符相同。</li>
<li><strong>删除</strong>：<code>dp[i][j] = dp[i-1][j] + 1</code>，即删除 <code>word1</code> 的第 <code>i</code> 个字符，使得剩余的前 <code>i-1</code> 个字符与 <code>word2</code> 的前 <code>j</code> 个字符相同。</li>
<li><strong>替换</strong>：<code>dp[i][j] = dp[i-1][j-1] + 1</code>，即将 <code>word1</code> 的第 <code>i</code> 个字符替换为 <code>word2</code> 的第 <code>j</code> 个字符。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>dp[0][0] = 0</code>，表示两个空字符串之间的编辑距离为 0。</li>
<li><code>dp[i][0] = i</code>，表示将 <code>word1</code> 的前 <code>i</code> 个字符转换为空字符串所需的操作数。</li>
<li><code>dp[0][j] = j</code>，表示将空字符串转换为 <code>word2</code> 的前 <code>j</code> 个字符所需的操作数。</li>
</ul>
</li>
<li><p><strong>求解目标</strong>：</p>
<ul>
<li>最终结果存储在 <code>dp[m][n]</code> 中，其中 <code>m</code> 和 <code>n</code> 分别为 <code>word1</code> 和 <code>word2</code> 的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDistance = <span class="keyword">function</span>(<span class="params">word1, word2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = word1.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> n = word2.<span class="property">length</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建二维数组 dp，大小为 (m+1) x (n+1)，并初始化为 0</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(m + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化边界条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i; <span class="comment">// 将 word1 的前 i 个字符变为空字符所需操作数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j; <span class="comment">// 将空字符变为 word2 的前 j 个字符所需操作数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] === word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 如果字符相同，不需要额外操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, <span class="comment">// 插入操作</span></span><br><span class="line">                                    dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, <span class="comment">// 删除操作</span></span><br><span class="line">                                    dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>); <span class="comment">// 替换操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回最终结果，即将 word1 转换为 word2 的最小操作数</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>minDistance</code> 函数中，我们首先计算出 <code>word1</code> 和 <code>word2</code> 的长度 <code>m</code> 和 <code>n</code>。</li>
<li>创建二维数组 <code>dp</code>，并初始化边界条件，处理空字符串的情况。</li>
<li>使用双重循环填充 <code>dp</code> 数组，根据字符是否相同决定采取插入、删除或替换操作，更新 <code>dp[i][j]</code> 的值。</li>
<li>最后返回 <code>dp[m][n]</code>，即将 <code>word1</code> 转换为 <code>word2</code> 所需的最小操作数。</li>
</ul>
<p>这种方法保证了在 <code>O(m * n)</code> 的时间复杂度内完成计算，其中 <code>m</code> 和 <code>n</code> 分别是 <code>word1</code> 和 <code>word2</code> 的长度。</p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<ol>
<li><strong>寻找最低价格</strong>：遍历价格数组，保持一个变量记录到当前为止的最低价格。</li>
<li><strong>计算利润</strong>：在遍历时，计算如果在当前价格卖出股票，能获得的利润，并更新最大利润。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果数组为空，直接返回 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> curMin = prices[<span class="number">0</span>];  <span class="comment">// 记录当前的最低价格</span></span><br><span class="line">    <span class="keyword">let</span> maxProfit = <span class="number">0</span>;  <span class="comment">// 记录最大利润</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 更新最大利润：当前价格减去之前的最低价格</span></span><br><span class="line">        maxProfit = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxProfit, prices[i] - curMin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最低价格：保证我们在最便宜的时间买入</span></span><br><span class="line">        curMin = <span class="title class_">Math</span>.<span class="title function_">min</span>(curMin, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)，其中 <code>n</code> 是数组 <code>prices</code> 的长度。我们只需要遍历一次价格数组。</li>
<li><strong>空间复杂度</strong>：O(1)，只用了常数空间来存储最低价格和最大利润。</li>
</ul>
<h3 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><ul>
<li>时间复杂度：O(n)<ul>
<li>这里 n 是数组 <code>prices</code> 的长度。因为我们只需遍历数组一次，所以时间复杂度是线性的，即 O(n)。</li>
</ul>
</li>
<li>空间复杂度：O(1)<ul>
<li>只使用了两个额外的变量 <code>profit</code> 和 <code>money</code>，所以空间复杂度是常数级别的，即 O(1)。</li>
</ul>
</li>
</ul>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>这个问题可以使用贪心算法来解决。贪心算法的思想是在每一步都尽量跳得更远，从而在遍历数组的过程中不断更新最远可以到达的位置。具体来说，我们维护一个变量 <code>maxReach</code>，表示当前可以到达的最远位置。如果在遍历过程中某一个位置超出了 <code>maxReach</code>，那么说明无法到达最后一个下标，否则最终 <code>maxReach</code> 可以覆盖或超过最后一个下标。</p>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>初始化 <code>maxReach</code> 为 0，表示最远可以到达的位置。</li>
<li>遍历数组中的每一个位置 <code>i</code>：<ul>
<li>如果当前位置 <code>i</code> 超出了 <code>maxReach</code>，返回 <code>false</code>。</li>
<li>更新 <code>maxReach</code> 为 <code>i + nums[i]</code> 和 <code>maxReach</code> 中的较大值。</li>
</ul>
</li>
<li>遍历结束后，如果 <code>maxReach</code> 大于或等于最后一个下标，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxReach = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前位置超出最远可达范围，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; maxReach) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新最远可达范围</span></span><br><span class="line">        maxReach = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxReach, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果循环结束后最远可达范围包含最后一个下标，返回 true</span></span><br><span class="line">    <span class="keyword">return</span> maxReach &gt;= nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-9"><a href="#复杂度分析-9" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>：O(n)</p>
<ul>
<li>需要遍历数组一次，其中 n 是数组 <code>nums</code> 的长度。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：O(1)</p>
<ul>
<li>只使用了一个额外变量 <code>maxReach</code>，所以空间复杂度是常数级别的，即 O(1)。</li>
</ul>
</li>
</ul>
<h2 id="跳跃游戏-1"><a href="#跳跃游戏-1" class="headerlink" title="跳跃游戏||"></a>跳跃游戏||</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<p>可以使用贪心算法来解决这个问题，通过维护一个范围内可以到达的最远位置，以及在当前范围内跳跃的次数来解决。</p>
<ol>
<li>维护三个变量：<ul>
<li><code>jumps</code> 表示总跳跃次数。</li>
<li><code>currentEnd</code> 表示当前跳跃可以到达的最远位置。</li>
<li><code>farthest</code> 表示从当前跳跃到达的所有位置中可以到达的最远位置。</li>
</ul>
</li>
<li>遍历数组中的每一个位置 <code>i</code>：<ul>
<li>更新 <code>farthest</code> 为 <code>max(farthest, i + nums[i])</code>。</li>
<li>如果当前位置 <code>i</code> 达到了 <code>currentEnd</code>，则更新 <code>jumps</code> 并将 <code>currentEnd</code> 更新为 <code>farthest</code>。</li>
</ul>
</li>
<li>返回 <code>jumps</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var jump = function(nums) &#123;</span><br><span class="line">    let jumps = 0;</span><br><span class="line">    let currentEnd = 0;</span><br><span class="line">    let farthest = 0;</span><br><span class="line">    </span><br><span class="line">    // 注意：我们只需要遍历到倒数第二个位置，因为最后一个位置不需要再跳跃</span><br><span class="line">    for (let i = 0; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">        // 更新可以到达的最远位置</span><br><span class="line">        farthest = Math.max(farthest, i + nums[i]);</span><br><span class="line">        </span><br><span class="line">        // 如果当前到达了范围的末端</span><br><span class="line">        if (i === currentEnd) &#123;</span><br><span class="line">            jumps++;</span><br><span class="line">            currentEnd = farthest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return jumps;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)<ul>
<li>只需遍历数组一次，其中 n 是数组 <code>nums</code> 的长度。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：O(1)<ul>
<li>只使用了常数个额外变量。</li>
</ul>
</li>
</ul>
<p>对于 <code>nums = [2, 3, 1, 1, 4]</code>：</p>
<ol>
<li>初始化 <code>jumps = 0</code>, <code>currentEnd = 0</code>, <code>farthest = 0</code>。</li>
<li>遍历数组：<ul>
<li><code>i = 0</code>：<code>farthest = max(0, 0 + 2) = 2</code>，<code>currentEnd = 0</code>，更新 <code>jumps = 1</code>，<code>currentEnd = 2</code>。</li>
<li><code>i = 1</code>：<code>farthest = max(2, 1 + 3) = 4</code>，<code>currentEnd = 2</code>。</li>
<li><code>i = 2</code>：<code>farthest = max(4, 2 + 1) = 4</code>，<code>currentEnd = 2</code>，更新 <code>jumps = 2</code>，<code>currentEnd = 4</code>。</li>
</ul>
</li>
<li>返回 <code>jumps = 2</code>。</li>
</ol>
<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。返回一个表示每个字符串片段的长度的列表。</p>
<p>要将字符串 <code>s</code> 划分为尽可能多的片段，同一字母最多出现在一个片段中，可以使用贪心算法和哈希表来解决这个问题。具体步骤如下：</p>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><strong>记录每个字符的最后出现位置</strong>：使用一个哈希表记录字符串 <code>s</code> 中每个字符最后一次出现的下标。</li>
<li><strong>遍历字符串并划分片段</strong>：使用两个指针 <code>start</code> 和 <code>end</code>，其中 <code>start</code> 表示当前片段的开始位置，<code>end</code> 表示当前片段中字符的最远出现位置。<ul>
<li>遍历字符串 <code>s</code>，更新 <code>end</code> 为当前字符的最后出现位置。</li>
<li>当遍历到的位置 <code>i</code> 等于 <code>end</code> 时，说明当前片段可以结束，记录片段长度并更新 <code>start</code> 为下一个位置。</li>
</ul>
</li>
</ol>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> partitionLabels = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> lastOccurrence = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录每个字符最后出现的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        lastOccurrence[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> end = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历字符串并划分片段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        end = <span class="title class_">Math</span>.<span class="title function_">max</span>(end, lastOccurrence[s[i]]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当当前位置等于当前片段的最远位置时，记录片段长度并更新start</span></span><br><span class="line">        <span class="keyword">if</span> (i === end) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(end - start + <span class="number">1</span>);</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-10"><a href="#复杂度分析-10" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p><strong>时间复杂度</strong>：O(n)</p>
<ul>
<li>其中 n 是字符串 <code>s</code> 的长度。需要遍历字符串两次，一次记录最后出现的位置，一次进行划分。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：O(1)</p>
<ul>
<li>哈希表的空间复杂度是 O(1)，因为字符集大小是固定的（假设只有小写字母）。</li>
</ul>
</li>
</ul>
<h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><p>对于 <code>s = &quot;ababcbacadefegdehijhklij&quot;</code>：</p>
<ol>
<li><p>记录每个字符最后出现的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a: 8, b: 5, c: 7, d: 14, e: 15, f: 11, g: 13, h: 19, i: 22, j: 23, k: 20, l: 21&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历字符串并划分片段：</p>
<ul>
<li><code>i = 0</code> 到 <code>8</code>，最后一个字符是 <code>a</code>，所以第一个片段是 <code>&quot;ababcbaca&quot;</code>，长度是 <code>9</code>。</li>
<li><code>i = 9</code> 到 <code>15</code>，最后一个字符是 <code>e</code>，所以第二个片段是 <code>&quot;defegde&quot;</code>，长度是 <code>7</code>。</li>
<li><code>i = 16</code> 到 <code>23</code>，最后一个字符是 <code>j</code>，所以第三个片段是 <code>&quot;hijhklij&quot;</code>，长度是 <code>8</code>。</li>
</ul>
</li>
</ol>
<p>最终结果是 <code>[9, 7, 8]</code>。</p>
<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。你可以认为每种硬币的数量是无限的。</p>
<h3 id="解题思想-10"><a href="#解题思想-10" class="headerlink" title="解题思想"></a>解题思想</h3><p>该问题可以使用动态规划来解决。动态规划的基本思想是通过保存子问题的解来加速求解过程，从而避免重复计算，通常适用于具有重叠子问题和最优子结构性质的问题。</p>
<p>具体步骤如下：</p>
<ol>
<li><p><strong>定义状态</strong>：使用 <code>dp[i]</code> 表示凑成金额 <code>i</code> 所需的最少硬币数。</p>
</li>
<li><p><strong>状态转移方程</strong>：对于每个金额 <code>i</code>，遍历所有硬币面额 <code>coin</code>，如果可以用当前硬币 <code>coin</code> 凑成金额 <code>i</code>，则更新 <code>dp[i]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.min(dp[i], dp[i - coin] + 1);</span><br></pre></td></tr></table></figure>
<p>其中 <code>dp[i - coin] + 1</code> 表示使用当前硬币 <code>coin</code> 后的硬币数量，<code>dp[i]</code> 则是取当前的最小值。</p>
</li>
<li><p><strong>初始化</strong>：初始化 <code>dp[0] = 0</code>，表示凑成金额 <code>0</code> 不需要任何硬币。</p>
</li>
<li><p><strong>遍历计算</strong>：从金额 <code>1</code> 到 <code>amount</code>，依次计算每个金额的最少硬币数，直到计算出 <code>dp[amount]</code>。</p>
</li>
<li><p><strong>结果返回</strong>：如果 <code>dp[amount]</code> 的值为初始值（例如 <code>amount + 1</code>），则表示无法凑成金额 <code>amount</code>，返回 <code>-1</code>；否则返回 <code>dp[amount]</code>。</p>
</li>
</ol>
<h3 id="复杂度分析-11"><a href="#复杂度分析-11" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(amount * n)，其中 <code>amount</code> 是目标金额， <code>n</code> 是硬币的种类数。内外两层循环的时间复杂度均为 <code>O(amount * n)</code>。</li>
<li>空间复杂度：O(amount)，使用了大小为 <code>amount + 1</code> 的 <code>dp</code> 数组来存储每个金额的最少硬币数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coinChange = <span class="keyword">function</span> (<span class="params">coins, amount</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，大小为 amount + 1，初始值为 amount + 1</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(amount + <span class="number">1</span>).<span class="title function_">fill</span>(amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 凑成金额 0 所需的硬币个数为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有金额从 1 到 amount</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有硬币面额</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin) &#123; <span class="comment">// 当前金额 i 大于等于硬币面额 coin 时才能使用该硬币</span></span><br><span class="line">                dp[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i], dp[i - coin] + <span class="number">1</span>); <span class="comment">// 更新 dp[i]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 dp[amount] 还是初始值，说明无法凑成该金额，返回 -1；否则返回 dp[amount]</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount] === amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>输入：coins = [1, 2, 5], amount = 11</code>：展示了输入的硬币面额数组和目标金额。</li>
<li><code>输出：3</code>：展示了函数 <code>coinChange</code> 返回的最少硬币个数。对于 <code>coins = [1, 2, 5]</code> 和 <code>amount = 11</code>，可以用 <code>5 + 5 + 1</code> 三个硬币凑成 <code>11</code>，所以返回 <code>3</code>。</li>
</ul>
<h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p>你可以使用动态规划来解决这个问题。下面是基于动态规划的解法：</p>
<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>定义状态</strong>：</p>
<ul>
<li>定义一个布尔数组 <code>dp</code>，其中 <code>dp[i]</code> 表示字符串 <code>s</code> 的前 <code>i</code> 个字符能否被字典 <code>wordDict</code> 中的单词拼接而成。</li>
</ul>
</li>
<li><p><strong>状态转移</strong>：</p>
<ul>
<li>对于每个位置 <code>i</code>，检查所有以 <code>j</code> 结尾的子串（其中 <code>0 &lt;= j &lt; i</code>），如果 <code>dp[j]</code> 为 <code>true</code>，且子串 <code>s[j:i]</code> 出现在 <code>wordDict</code> 中，则 <code>dp[i]</code> 也设为 <code>true</code>。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>dp[0]</code> 初始化为 <code>true</code>，表示空串可以被拼接出。</li>
</ul>
</li>
<li><p><strong>计算结果</strong>：</p>
<ul>
<li>最终返回 <code>dp[n]</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。如果 <code>dp[n]</code> 为 <code>true</code>，则说明可以用字典中的单词拼接出整个字符串 <code>s</code>。</li>
</ul>
</li>
</ol>
<h3 id="复杂度分析-12"><a href="#复杂度分析-12" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(n^2)，其中 <code>n</code> 是字符串 <code>s</code> 的长度。外层循环遍历字符串 <code>s</code> 的每个字符，内层循环遍历每个可能的前缀子串。</li>
<li>空间复杂度：O(n)，需要额外的空间存储 <code>dp</code> 数组。</li>
</ul>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code:"></a>code:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wordBreak = <span class="keyword">function</span>(<span class="params">s, wordDict</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">false</span>); <span class="comment">// dp[i] 表示 s 的前 i 个字符能否被拼接出</span></span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 空字符串可以被拼接出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; wordDict.<span class="title function_">includes</span>(s.<span class="title function_">substring</span>(j, i))) &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果找到了符合条件的前缀子串就可以停止内层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例解释-1"><a href="#示例解释-1" class="headerlink" title="示例解释"></a>示例解释</h3><ul>
<li>给定字符串 <code>s = &quot;leetcode&quot;</code> 和字典 <code>wordDict = [&quot;leet&quot;, &quot;code&quot;]</code>。</li>
<li>我们可以将字符串拆分成 “leet code”，其中 “leet” 和 “code” 分别出现在 <code>wordDict</code> 中。</li>
<li>因此，返回 <code>true</code> 表示可以利用字典中的单词拼接出字符串 <code>s</code>。</li>
</ul>
<p>这种方法利用动态规划的思想，通过逐步构建 <code>dp</code> 数组来判断是否能够用字典中的单词拼接出目标字符串。</p>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。<strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p>找到最长严格递增子序列的长度可以使用动态规划（DP）的方法。动态规划的基本思想是通过记录每个位置的最长递增子序列长度来逐步构建最终的结果。</p>
<h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>定义状态</strong>：</p>
<ul>
<li>使用一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长严格递增子序列的长度。</li>
</ul>
</li>
<li><p><strong>状态转移</strong>：</p>
<ul>
<li>对于每个位置 <code>i</code>，遍历 <code>i</code> 之前的所有位置 <code>j</code>，如果 <code>nums[i] &gt; nums[j]</code>，则更新 <code>dp[i]</code>：<br><code>dp[i] = Math.max(dp[i], dp[j] + 1)</code></li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>dp</code> 数组的每个位置初始化为 <code>1</code>，因为每个元素都可以单独成为一个子序列。</li>
</ul>
</li>
<li><p><strong>结果计算</strong>：</p>
<ul>
<li>最终结果是 <code>dp</code> 数组中的最大值，即 <code>dp</code> 数组中所有值的最大值。</li>
</ul>
</li>
</ol>
<h3 id="复杂度分析-13"><a href="#复杂度分析-13" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(n^2)，其中 <code>n</code> 是数组 <code>nums</code> 的长度。两层循环分别遍历数组中的每个元素。</li>
<li>空间复杂度：O(n)，需要额外的空间存储 <code>dp</code> 数组。</li>
</ul>
<h4 id="code：-8"><a href="#code：-8" class="headerlink" title="code："></a>code：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化 dp 数组，长度为 nums.length，每个元素的最长递增子序列长度初始化为 1</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每个元素 i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历元素 i 之前的所有元素 j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums[i] 大于 nums[j]，说明可以从 j 到 i 形成递增子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                <span class="comment">// 更新 dp[i]，取当前 dp[i] 和 dp[j] + 1 的较大值</span></span><br><span class="line">                dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 dp 数组中的最大值，即最长严格递增子序列的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例解释-2"><a href="#示例解释-2" class="headerlink" title="示例解释"></a>示例解释</h3><ul>
<li>给定数组 <code>nums = [10, 9, 2, 5, 3, 7, 101, 18]</code>。</li>
<li>最长严格递增子序列为 <code>[2, 3, 7, 101]</code>，其长度为 <code>4</code>。</li>
</ul>
<p>通过动态规划的方法，我们可以有效地找到最长严格递增子序列的长度。每次更新 <code>dp</code> 数组时，我们记录以每个元素结尾的最长递增子序列的长度，最终取最大值作为结果。</p>
<h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p>要找到数组中乘积最大的非空连续子数组，我们可以使用动态规划的思想。具体来说，我们需要在遍历数组时，记录到当前元素为止的最大乘积和最小乘积，因为负数的乘积可能会使最小值变成最大值。</p>
<h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>定义状态</strong>：</p>
<ul>
<li>使用 <code>maxProduct</code> 记录到当前元素为止的最大乘积。</li>
<li>使用 <code>minProduct</code> 记录到当前元素为止的最小乘积（因为负数乘积可能会导致最小值变成最大值）。</li>
<li>使用 <code>result</code> 记录最终的最大乘积。</li>
</ul>
</li>
<li><p><strong>状态转移</strong>：</p>
<ul>
<li>对于每个元素 <code>nums[i]</code>，更新 <code>maxProduct</code> 和 <code>minProduct</code>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tempMax = maxProduct;</span><br><span class="line">maxProduct = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i], maxProduct * nums[i], minProduct * nums[i]);</span><br><span class="line">minProduct = <span class="title class_">Math</span>.<span class="title function_">min</span>(nums[i], tempMax * nums[i], minProduct * nums[i]);</span><br></pre></td></tr></table></figure></li>
<li>更新 <code>result</code>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="title class_">Math</span>.<span class="title function_">max</span>(result, maxProduct);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>maxProduct</code>、<code>minProduct</code> 和 <code>result</code> 均初始化为数组的第一个元素 <code>nums[0]</code>。</li>
</ul>
</li>
<li><p><strong>结果计算</strong>：</p>
<ul>
<li>最终返回 <code>result</code>。</li>
</ul>
</li>
</ol>
<h3 id="复杂度分析-14"><a href="#复杂度分析-14" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(n)，其中 <code>n</code> 是数组 <code>nums</code> 的长度。只需一次遍历。</li>
<li>空间复杂度：O(1)，只使用了常数级别的额外空间。</li>
</ul>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面是使用动态规划实现的 JavaScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProduct = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 maxProduct、minProduct 和 result</span></span><br><span class="line">    <span class="keyword">let</span> maxProduct = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> minProduct = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> result = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 暂存 maxProduct 的值，因为 minProduct 需要用到它</span></span><br><span class="line">        <span class="keyword">let</span> tempMax = maxProduct;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 maxProduct 和 minProduct</span></span><br><span class="line">        maxProduct = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i], maxProduct * nums[i], minProduct * nums[i]);</span><br><span class="line">        minProduct = <span class="title class_">Math</span>.<span class="title function_">min</span>(nums[i], tempMax * nums[i], minProduct * nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新结果</span></span><br><span class="line">        result = <span class="title class_">Math</span>.<span class="title function_">max</span>(result, maxProduct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例解释-3"><a href="#示例解释-3" class="headerlink" title="示例解释"></a>示例解释</h3><ul>
<li>给定数组 <code>nums = [2, 3, -2, 4]</code>。</li>
<li>乘积最大的非空连续子数组为 <code>[2, 3]</code>，其乘积为 <code>6</code>。</li>
</ul>
<p>通过动态规划的方法，我们可以有效地找到乘积最大的非空连续子数组。每次更新 <code>maxProduct</code> 和 <code>minProduct</code> 时，考虑当前元素、当前元素与之前 <code>maxProduct</code> 的乘积、当前元素与之前 <code>minProduct</code> 的乘积，然后更新结果。最终结果即为乘积最大的子数组的乘积。</p>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>相关的算法：</p>
<h3 id="1-深度优先搜索（DFS）"><a href="#1-深度优先搜索（DFS）" class="headerlink" title="1. 深度优先搜索（DFS）"></a>1. 深度优先搜索（DFS）</h3><p><strong>题目</strong>：给定一个无向图，写一个算法输出图中所有连通分量。</p>
<p><strong>提示</strong>：可以使用深度优先搜索（DFS）来找到所有连通分量。</p>
<h3 id="2-广度优先搜索（BFS）"><a href="#2-广度优先搜索（BFS）" class="headerlink" title="2. 广度优先搜索（BFS）"></a>2. 广度优先搜索（BFS）</h3><p><strong>题目</strong>：给定一个无向图和一个起始节点，写一个算法输出从起始节点到所有其他节点的最短路径。</p>
<p><strong>提示</strong>：可以使用广度优先搜索（BFS）来找到从起始节点到所有其他节点的最短路径。</p>
<h3 id="3-最短路径算法"><a href="#3-最短路径算法" class="headerlink" title="3. 最短路径算法"></a>3. 最短路径算法</h3><p><strong>题目</strong>：给定一个带权有向图和一个起始节点，写一个算法输出从起始节点到所有其他节点的最短路径。</p>
<p><strong>提示</strong>：可以使用Dijkstra算法来解决这个问题。</p>
<h3 id="4-最小生成树"><a href="#4-最小生成树" class="headerlink" title="4. 最小生成树"></a>4. 最小生成树</h3><p><strong>题目</strong>：给定一个带权无向图，写一个算法输出图的最小生成树。</p>
<p><strong>提示</strong>：可以使用Kruskal或Prim算法来找到最小生成树。</p>
<h3 id="5-拓扑排序"><a href="#5-拓扑排序" class="headerlink" title="5. 拓扑排序"></a>5. 拓扑排序</h3><p><strong>题目</strong>：给定一个有向无环图（DAG），写一个算法输出图的拓扑排序。</p>
<p><strong>提示</strong>：可以使用Kahn算法或深度优先搜索（DFS）来找到拓扑排序。</p>
<h3 id="6-二分图检测"><a href="#6-二分图检测" class="headerlink" title="6. 二分图检测"></a>6. 二分图检测</h3><p><strong>题目</strong>：给定一个无向图，写一个算法判断图是否是二分图。</p>
<p><strong>提示</strong>：可以使用染色法（两种颜色）来检测二分图。</p>
<h3 id="7-欧拉回路与欧拉路径"><a href="#7-欧拉回路与欧拉路径" class="headerlink" title="7. 欧拉回路与欧拉路径"></a>7. 欧拉回路与欧拉路径</h3><p><strong>题目</strong>：给定一个无向图，写一个算法判断图中是否存在欧拉回路或欧拉路径，并输出该路径（如果存在）。</p>
<p><strong>提示</strong>：可以使用Hierholzer算法来找到欧拉回路或欧拉路径。</p>
<h3 id="8-强连通分量"><a href="#8-强连通分量" class="headerlink" title="8. 强连通分量"></a>8. 强连通分量</h3><p><strong>题目</strong>：给定一个有向图，写一个算法输出图中的所有强连通分量。</p>
<p><strong>提示</strong>：可以使用Tarjan算法或Kosaraju算法来找到强连通分量。</p>
<h3 id="9-Bellman-Ford算法"><a href="#9-Bellman-Ford算法" class="headerlink" title="9. Bellman-Ford算法"></a>9. Bellman-Ford算法</h3><p><strong>题目</strong>：给定一个带权有向图和一个起始节点，写一个算法输出从起始节点到所有其他节点的最短路径，允许存在负权边。</p>
<p><strong>提示</strong>：可以使用Bellman-Ford算法来解决这个问题。</p>
<h3 id="10-Floyd-Warshall算法"><a href="#10-Floyd-Warshall算法" class="headerlink" title="10. Floyd-Warshall算法"></a>10. Floyd-Warshall算法</h3><p><strong>题目</strong>：给定一个带权有向图，写一个算法输出任意两点间的最短路径。</p>
<p><strong>提示</strong>：可以使用Floyd-Warshall算法来找到任意两点间的最短路径。</p>
<h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
<p>找出并计算岛屿的数量。对于给定的输入，输出应该是1，因为所有的’1’相连在一起形成一个岛屿。</p>
<p>我们将使用深度优先搜索（DFS）来遍历网格，找到并标记所有相连的’1’，每当我们发现一个新的’1’时，就意味着我们找到了一个新的岛屿。</p>
<h3 id="具体步骤-2"><a href="#具体步骤-2" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li><strong>遍历网格</strong>：遍历每一个元素，如果遇到’1’，就开始进行DFS遍历。</li>
<li><strong>DFS遍历</strong>：在DFS过程中，将当前’1’变为’0’，并递归遍历其相邻的’1’，直到所有相连的’1’都被标记为’0’。</li>
<li><strong>计数岛屿</strong>：每次发现一个新的’1’并开始DFS时，计数器加一。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numIslands = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!grid || grid.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索（DFS）函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">grid, i, j</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 检查边界条件和是否已访问</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="property">length</span> || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="property">length</span> || grid[i][j] === <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前格子标记为已访问</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 递归地访问相邻的上下左右格子</span></span><br><span class="line">        <span class="title function_">dfs</span>(grid, i + <span class="number">1</span>, j); <span class="comment">// 下</span></span><br><span class="line">        <span class="title function_">dfs</span>(grid, i - <span class="number">1</span>, j); <span class="comment">// 上</span></span><br><span class="line">        <span class="title function_">dfs</span>(grid, i, j + <span class="number">1</span>); <span class="comment">// 右</span></span><br><span class="line">        <span class="title function_">dfs</span>(grid, i, j - <span class="number">1</span>); <span class="comment">// 左</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历整个网格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                count++; <span class="comment">// 发现一个新的岛屿</span></span><br><span class="line">                <span class="title function_">dfs</span>(grid, i, j); <span class="comment">// 使用DFS标记整个岛屿</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解释-6"><a href="#解释-6" class="headerlink" title="解释"></a>解释</h3><ol>
<li><strong>初始化与边界检查</strong>：首先检查网格是否为空或长度为零。如果是，则直接返回0。</li>
<li><strong>定义DFS函数</strong>：DFS函数用于将当前格子及其相邻的所有’1’标记为’0’。通过递归调用，实现对相邻格子的遍历。</li>
<li><strong>主循环</strong>：遍历整个网格的每个元素。<ul>
<li>如果当前元素是’1’，则意味着发现一个新的岛屿，计数器加一。</li>
<li>调用DFS函数，从当前’1’开始，将与之相连的所有’1’都标记为’0’，避免重复计数。</li>
</ul>
</li>
<li><strong>输出结果</strong>：主循环结束后，计数器的值即为岛屿的数量。</li>
</ol>
<h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h2><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
<p>你的目标是实现一个计算腐烂橘子所需时间的算法，这里是题目的描述以及实现的正确方式。</p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个 <code>grid</code> 矩阵中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>0 表示这个单元格是空的。</li>
<li>1 表示这个单元格有一个新鲜的橘子。</li>
<li>2 表示这个单元格有一个腐烂的橘子。</li>
</ul>
<p>每分钟，任何与腐烂橘子相邻（4个方向：上、下、左、右）的新鲜橘子都会变成腐烂橘子。</p>
<p>编写一个函数，来计算直到没有新鲜橘子存在所需的最小分钟数。如果无法使所有橘子腐烂，则返回 -1。</p>
<h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><strong>问题理解</strong>：<ul>
<li>给定一个二维网格，其中 <code>1</code> 表示新鲜橘子，<code>2</code> 表示腐烂橘子，<code>0</code> 表示空格。新鲜橘子只能被水平或垂直相邻的腐烂橘子腐烂。求使得所有新鲜橘子腐烂所需的最少分钟数。如果无法使所有新鲜橘子腐烂，则返回 <code>-1</code>。</li>
</ul>
</li>
<li><strong>解题思路</strong>：<ul>
<li>使用广度优先搜索（BFS）来模拟腐烂橘子的传播过程。首先将所有初始的腐烂橘子加入队列，然后不断从队列中取出腐烂橘子，并将其相邻的新鲜橘子变为腐烂，直到队列为空。</li>
<li>使用一个计数器 <code>minutes</code> 来记录经过的时间步长，即腐烂的分钟数。</li>
<li>使用一个 <code>fresh</code> 变量来记录当前还未腐烂的新鲜橘子数量，如果 BFS 结束后 <code>fresh</code> 不为 <code>0</code>，说明有新鲜橘子无法腐烂，返回 <code>-1</code>；否则返回 <code>minutes - 1</code>，即腐烂橘子传播的总时间。</li>
</ul>
</li>
</ol>
<p>使用广度优先搜索（BFS）来解决这个问题，具体步骤如下：</p>
<ol>
<li>将所有腐烂橘子的位置加入队列，并记录新鲜橘子的数量。</li>
<li>从队列中依次取出腐烂橘子的位置，并将其四个方向相邻的新鲜橘子变为腐烂，并将这些新变腐烂的橘子位置加入队列。</li>
<li>每一轮处理表示一分钟过去了。</li>
<li>如果处理完所有腐烂橘子后仍然有新鲜橘子未被腐烂，则返回 -1。</li>
</ol>
<h3 id="code：-9"><a href="#code：-9" class="headerlink" title="code："></a>code：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> orangesRotting = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义四个方向的偏移量：下、上、右、左</span></span><br><span class="line">    <span class="keyword">const</span> directions = [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">const</span> queue = []; <span class="comment">// 初始化队列，用来存储腐烂橘子的坐标</span></span><br><span class="line">    <span class="keyword">let</span> fresh = <span class="number">0</span>; <span class="comment">// 记录新鲜橘子的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个网格，初始化队列和计算新鲜橘子的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="number">2</span>) &#123;</span><br><span class="line">                queue.<span class="title function_">push</span>([i, j]); <span class="comment">// 将腐烂橘子的坐标加入队列</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">                fresh++; <span class="comment">// 统计新鲜橘子的数量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有新鲜橘子，直接返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (fresh === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> minutes = <span class="number">0</span>; <span class="comment">// 初始化分钟数，用来记录腐烂橘子的传播时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS 进行橘子腐烂的传播</span></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.<span class="property">length</span>; <span class="comment">// 当前层级的节点数，也就是当前时间点的所有腐烂橘子数目</span></span><br><span class="line">        minutes++; <span class="comment">// 时间步长加一</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前层级的所有腐烂橘子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> [x, y] = queue.<span class="title function_">shift</span>(); <span class="comment">// 取出队列中的一个腐烂橘子的坐标</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前橘子的四个相邻方向</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> [dx, dy] <span class="keyword">of</span> directions) &#123;</span><br><span class="line">                <span class="keyword">const</span> newX = x + dx; <span class="comment">// 计算新的行坐标</span></span><br><span class="line">                <span class="keyword">const</span> newY = y + dy; <span class="comment">// 计算新的列坐标</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断新坐标是否在网格范围内，并且是新鲜橘子</span></span><br><span class="line">                <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; grid.<span class="property">length</span> &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; grid[<span class="number">0</span>].<span class="property">length</span> &amp;&amp; grid[newX][newY] === <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[newX][newY] = <span class="number">2</span>; <span class="comment">// 将新鲜橘子变为腐烂</span></span><br><span class="line">                    queue.<span class="title function_">push</span>([newX, newY]); <span class="comment">// 将新腐烂橘子的坐标加入队列</span></span><br><span class="line">                    fresh--; <span class="comment">// 新鲜橘子数量减一</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS 结束后，检查是否还有新鲜橘子未被腐烂</span></span><br><span class="line">    <span class="keyword">if</span> (fresh &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果还有新鲜橘子未被腐烂，返回 -1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minutes - <span class="number">1</span>; <span class="comment">// 否则返回腐烂橘子传播的总时间，减一是因为最后一个时间步长不需要计算</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解释-7"><a href="#解释-7" class="headerlink" title="解释"></a>解释</h3><ol>
<li><strong>初始化</strong>：我们首先遍历整个网格，将所有腐烂的橘子位置加入队列，同时记录新鲜橘子的数量。</li>
<li><strong>BFS遍历</strong>：使用队列进行广度优先搜索，每轮遍历将相邻的新鲜橘子变为腐烂，并记录所需的时间（分钟数）。</li>
<li><strong>结果计算</strong>：如果所有新鲜橘子都变为腐烂，则返回所需时间；否则返回 -1，表示无法使所有橘子腐烂。</li>
</ol>
<p>这样我们可以有效地计算出使所有橘子腐烂所需的最小时间。</p>
<h3 id="复杂度分析-15"><a href="#复杂度分析-15" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：假设网格大小为 <code>m x n</code>。<ul>
<li>初始化队列和统计新鲜橘子的时间复杂度为 <code>O(m * n)</code>。</li>
<li>BFS 的时间复杂度为 <code>O(m * n)</code>，因为每个节点（橘子）最多访问一次。</li>
<li>总体时间复杂度为 <code>O(m * n)</code>。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：使用了队列来存储腐烂橘子的坐标，最坏情况下空间复杂度为 <code>O(m * n)</code>，用于存储整个网格。</li>
</ul>
<h2 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h3 id="解题思想-11"><a href="#解题思想-11" class="headerlink" title="解题思想"></a>解题思想</h3><p>要解决这个问题，我们可以将其转换为图论中的“检测有向图中是否存在环”的问题。如果课程的先修关系形成了一个有向无环图（DAG），那么我们可以完成所有课程；否则，如果存在环，我们就无法完成所有课程。</p>
<p>我们可以使用拓扑排序来检测有向图中的环。如果图中存在拓扑排序，则说明没有环；否则，存在环。我们可以通过广度优先搜索（BFS）或深度优先搜索（DFS）来实现拓扑排序。</p>
<p>下面是使用 BFS（Kahn’s 算法）实现的代码：</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canFinish = <span class="keyword">function</span>(<span class="params">numCourses, prerequisites</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个数组来记录每门课程的入度（有多少先修课程）</span></span><br><span class="line">    <span class="keyword">const</span> inDegree = <span class="keyword">new</span> <span class="title class_">Array</span>(numCourses).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建一个邻接表来记录每门课程的后续课程</span></span><br><span class="line">    <span class="keyword">const</span> adjList = <span class="keyword">new</span> <span class="title class_">Array</span>(numCourses).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line">    <span class="comment">//另一种创建二维数组</span></span><br><span class="line">    <span class="comment">//const adjust=Array.from(&#123;length:numCourses&#125;,()=&gt;[])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充入度数组和邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [course, prereq] <span class="keyword">of</span> prerequisites) &#123;</span><br><span class="line">        inDegree[course]++;</span><br><span class="line">        adjList[prereq].<span class="title function_">push</span>(course);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个队列来进行广度优先搜索（BFS）</span></span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="comment">// 将所有入度为0的课程加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] === <span class="number">0</span>) &#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经完成的课程数</span></span><br><span class="line">    <span class="keyword">let</span> completedCourses = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> course = queue.<span class="title function_">shift</span>();</span><br><span class="line">        completedCourses++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对当前课程的后续课程进行处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> nextCourse <span class="keyword">of</span> adjList[course]) &#123;</span><br><span class="line">            inDegree[nextCourse]--; <span class="comment">// 将后续课程的入度减1</span></span><br><span class="line">            <span class="keyword">if</span> (inDegree[nextCourse] === <span class="number">0</span>) &#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(nextCourse); <span class="comment">// 如果后续课程的入度为0，将其加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果完成的课程数等于总课程数，说明可以完成所有课程</span></span><br><span class="line">    <span class="keyword">return</span> completedCourses === numCourses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p><strong>构建图</strong>：</p>
<ul>
<li>使用邻接表来表示课程的依赖关系。</li>
<li>使用入度数组来记录每门课程的先修课程数量。</li>
</ul>
</li>
<li><p><strong>初始化队列</strong>：</p>
<ul>
<li>将所有入度为0的课程加入队列。这些课程没有任何先修课程，可以直接开始学习。</li>
</ul>
</li>
<li><p><strong>广度优先搜索（BFS）</strong>：</p>
<ul>
<li>从队列中取出一门课程，将其标记为已完成（增加完成课程的计数）。</li>
<li>对该课程的所有后续课程进行处理：将后续课程的入度减1，如果减1后入度为0，则将其加入队列。</li>
</ul>
</li>
<li><p><strong>检查结果</strong>：</p>
<ul>
<li>如果所有课程都被标记为已完成（完成课程的计数等于总课程数），则返回 <code>true</code>。</li>
<li>否则，返回 <code>false</code>，表示存在循环依赖，无法完成所有课程。</li>
</ul>
</li>
</ol>
<h3 id="复杂度分析-16"><a href="#复杂度分析-16" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：<code>O(V + E)</code>，其中 <code>V</code> 是课程的数量（顶点数），<code>E</code> 是先修课程的数量（边数）。构建图和执行 BFS 的过程都需要遍历所有顶点和边。</li>
<li><strong>空间复杂度</strong>：<code>O(V + E)</code>，需要存储邻接表和入度数组。</li>
</ul>
<p>这个方法高效且直观，适用于解决课程表问题。</p>
<h2 id="实现Trie-前缀树"><a href="#实现Trie-前缀树" class="headerlink" title="实现Trie(前缀树)"></a>实现Trie(前缀树)</h2><p>**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p>下面是完整的 Trie 类实现，使用 JavaScript 原型方法来定义 <code>insert</code>、<code>search</code> 和 <code>startsWith</code> 方法。每个方法都有详细的注释来解释其工作原理。</p>
<h3 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Trie 节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">children</span> = &#123;&#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isEndOfWord</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Trie 类</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Trie</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 向 Trie 中插入一个单词</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">word</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">word</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> word) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node.<span class="property">children</span>[char]) &#123;</span><br><span class="line">            node.<span class="property">children</span>[char] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.<span class="property">children</span>[char];</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">isEndOfWord</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 搜索一个单词是否在 Trie 中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">word</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">search</span> = <span class="keyword">function</span>(<span class="params">word</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="title function_">_searchPrefix</span>(word);</span><br><span class="line">    <span class="keyword">return</span> node !== <span class="literal">null</span> &amp;&amp; node.<span class="property">isEndOfWord</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 检查 Trie 中是否存在某个前缀</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">prefix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">startsWith</span> = <span class="keyword">function</span>(<span class="params">prefix</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_searchPrefix</span>(prefix) !== <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，搜索前缀</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">prefix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TrieNode|null</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_searchPrefix</span> = <span class="keyword">function</span>(<span class="params">prefix</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> prefix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node.<span class="property">children</span>[char]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.<span class="property">children</span>[char];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解释和注释"><a href="#解释和注释" class="headerlink" title="解释和注释"></a>解释和注释</h3><ol>
<li><strong>TrieNode 类</strong>：每个 Trie 节点包含一个 <code>children</code> 对象来存储子节点和一个布尔值 <code>isEndOfWord</code> 来标记单词结束。</li>
<li><strong>Trie 类</strong>：包含一个 <code>root</code> 属性，它是一个 TrieNode 实例，表示前缀树的根节点。</li>
<li><strong>insert 方法</strong>：从根节点开始，逐个字符插入。如果字符不存在当前节点的 <code>children</code> 中，就创建新节点。插入完成后，标记最后一个节点的 <code>isEndOfWord</code> 为 <code>true</code>。</li>
<li><strong>search 方法</strong>：使用 <code>_searchPrefix</code> 辅助函数找到节点，返回节点是否为单词结束。</li>
<li><strong>startsWith 方法</strong>：使用 <code>_searchPrefix</code> 辅助函数检查前缀是否存在。</li>
<li><strong>_searchPrefix 方法</strong>：从根节点开始，逐个字符检查节点是否存在，返回最终节点或 <code>null</code>。</li>
</ol>
<h3 id="复杂度分析-17"><a href="#复杂度分析-17" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li><code>insert</code>：O(m)，其中 m 是单词的长度。</li>
<li><code>search</code> 和 <code>startsWith</code>：O(m)，其中 m 是查询单词或前缀的长度。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>每个节点最多有 26 个子节点（假设只处理小写字母），空间复杂度与插入的单词数量和长度有关。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Lavender321.github.com">流泪猫猫头</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lavender321.github.com/2024/05/20/leetcode-100/">http://lavender321.github.com/2024/05/20/leetcode-100/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Lavender321.github.com" target="_blank">Lavender's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/leetcode-100/">leetcode 100</a><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/%E5%8A%9B%E6%89%A3/">力扣</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/28/PAT%E9%A1%B9%E7%9B%AE/" title="PAT项目"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PAT项目</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/25/%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%A2%98/" title="代码输出题"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">代码输出题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/31/LeetCode%20%E7%B2%BE%E9%80%89%E7%AE%97%E6%B3%95%20200%20%E9%A2%98/" title="LeetCode 精选算法 200 题"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-31</div><div class="title">LeetCode 精选算法 200 题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/03/01/ObQE3TvFKInczfl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">流泪猫猫头</div><div class="author-info__description">THE TORTURED POETS DEPARTMENT</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">75</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lavender321"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lavender321" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:r1727439300@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%9B%BA%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">链表固定区间反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">时间复杂度和空间复杂度：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF"><span class="toc-number">1.3.</span> <span class="toc-text">判断链表有环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">时间和空间复杂度：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.4.</span> <span class="toc-text">链表相加</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">解释：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.4.2.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%88%E7%9A%84%E8%A7%A3%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">使用栈的解法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">1.4.4.</span> <span class="toc-text">解法步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.4.5.</span> <span class="toc-text">实现代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">1.4.6.</span> <span class="toc-text">解法思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">1.4.7.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">1.4.8.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.4.9.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">合并 k 个链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1-%E4%B8%A4%E4%B8%A4%E5%90%88%E5%B9%B6"><span class="toc-number">1.6.1.</span> <span class="toc-text">方法 1: 两两合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">递归合并链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.6.3.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.6.4.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.6.5.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.6.6.</span> <span class="toc-text">方法 2: 使用最小堆（优先队列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3-%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">1.6.7.</span> <span class="toc-text">方法 3: 分治法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-number">1.6.8.</span> <span class="toc-text">优势：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E2%80%93%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.</span> <span class="toc-text">相交链表–两个链表相交的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.7.1.</span> <span class="toc-text">解题思想：双指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.8.</span> <span class="toc-text">k个一组翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E6%9C%80%E5%90%8Ek%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">1.9.</span> <span class="toc-text">链表中倒数最后k个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">1.10.</span> <span class="toc-text">删除链表的倒数第N个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%EF%BC%9A"><span class="toc-number">1.10.1.</span> <span class="toc-text">双指针法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.11.</span> <span class="toc-text">两两交换链表的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%951%EF%BC%9A%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.11.1.</span> <span class="toc-text">解法1：迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%E2%80%93%E9%80%92%E5%BD%92"><span class="toc-number">1.11.2.</span> <span class="toc-text">解法二–递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">1.12.</span> <span class="toc-text">随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU%E7%BC%93%E5%AD%98"><span class="toc-number">1.13.</span> <span class="toc-text">LRU缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#code%EF%BC%9A"><span class="toc-number">1.13.1.</span> <span class="toc-text">code：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E8%A1%8C%E8%A7%A3%E9%87%8A%E4%BB%A3%E7%A0%81"><span class="toc-number">1.13.2.</span> <span class="toc-text">逐行解释代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.13.3.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A80"><span class="toc-number">2.1.</span> <span class="toc-text">移动0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">2.3.</span> <span class="toc-text">三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%E2%80%93%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">2.3.1.</span> <span class="toc-text">方法1–解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">2.3.3.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.3.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%E2%80%93%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">2.3.5.</span> <span class="toc-text">方法2–解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.3.6.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">2.3.7.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">2.3.8.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-1"><span class="toc-number">2.3.9.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B3%B0%E5%80%BC"><span class="toc-number">2.4.</span> <span class="toc-text">删除链表的峰值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.4.1.</span> <span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.5.</span> <span class="toc-text">判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">2.5.1.</span> <span class="toc-text">时间复杂度：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">搜索插入位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%94%E5%9B%9E-left"><span class="toc-number">3.1.1.</span> <span class="toc-text">解释为什么返回 left</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E5%80%BC"><span class="toc-number">3.2.</span> <span class="toc-text">查找数组的峰值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-number">3.3.</span> <span class="toc-text">搜索二维矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">3.3.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">3.3.3.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">3.3.4.</span> <span class="toc-text">方法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%92%8C%E9%80%BB%E8%BE%91%E8%B0%83%E6%95%B4"><span class="toc-number">3.3.5.</span> <span class="toc-text">解释和逻辑调整</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.4.</span> <span class="toc-text">在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">3.5.</span> <span class="toc-text">数组中的逆序对</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">3.5.1.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">3.6.</span> <span class="toc-text">搜索旋转排序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">3.6.1.</span> <span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">3.6.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-number">3.6.3.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">3.7.</span> <span class="toc-text">寻找旋转数组的最小值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9Asort%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.1.</span> <span class="toc-text">方法1：sort排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.7.2.</span> <span class="toc-text">方法2：二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">寻找两个正序数组的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-1"><span class="toc-number">3.8.1.</span> <span class="toc-text">解释：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88-1"><span class="toc-number">4.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">4.1.</span> <span class="toc-text">最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%A7%A3%E9%87%8A"><span class="toc-number">4.1.1.</span> <span class="toc-text">代码实现和解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">4.2.</span> <span class="toc-text">字符串解码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">解释和示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-number">4.3.</span> <span class="toc-text">每日温度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">4.4.</span> <span class="toc-text">有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3"><span class="toc-number">4.4.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E8%A1%8C%E8%A7%A3%E9%87%8A"><span class="toc-number">4.4.2.</span> <span class="toc-text">逐行解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">4.4.3.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-number">4.5.</span> <span class="toc-text">柱状图中最大的矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-3"><span class="toc-number">4.5.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">4.5.2.</span> <span class="toc-text">执行过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">4.5.3.</span> <span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">4.6.</span> <span class="toc-text">只出现一次的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">4.6.1.</span> <span class="toc-text">修正后的代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-4"><span class="toc-number">4.6.2.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">4.6.3.</span> <span class="toc-text">时间和空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952"><span class="toc-number">4.6.4.</span> <span class="toc-text">方法2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.6.5.</span> <span class="toc-text">方法一：使用哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88"><span class="toc-number">4.6.6.</span> <span class="toc-text">方法二：使用集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95%EF%BC%882%E2%88%97sum-%E9%9B%86%E5%90%88-%E2%88%92sum-%E6%95%B0%E7%BB%84-%EF%BC%89"><span class="toc-number">4.6.7.</span> <span class="toc-text">方法三：数学方法（2∗sum(集合)−sum(数组)）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.6.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">4.7.</span> <span class="toc-text">多数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">4.7.1.</span> <span class="toc-text">修正后的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">4.7.2.</span> <span class="toc-text">逐行分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9ABoyer-Moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="toc-number">4.7.3.</span> <span class="toc-text">优化方法：Boyer-Moore 投票算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boyer-Moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%E9%80%90%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">4.7.4.</span> <span class="toc-text">Boyer-Moore 投票算法逐行分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boyer-Moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">4.7.5.</span> <span class="toc-text">Boyer-Moore 投票算法的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">4.8.</span> <span class="toc-text">表达式求值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">5.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">5.1.</span> <span class="toc-text">数组中的第K个最大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text">方法1：排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="toc-number">5.1.2.</span> <span class="toc-text">方法 2：使用最小堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%EF%BC%88Quickselect%EF%BC%89"><span class="toc-number">5.1.3.</span> <span class="toc-text">方法 3：快速选择（Quickselect）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-4%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">方法 4：基于快速排序的分治法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-5%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.5.</span> <span class="toc-text">方法 5：使用内置方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">5.2.</span> <span class="toc-text">前K个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E7%8E%87"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">步骤 1：统计每个元素的频率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E5%A0%86%E6%9D%A5%E7%BB%B4%E6%8A%A4%E5%89%8D-k-%E9%AB%98%E9%A2%91%E7%8E%87%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">5.2.0.2.</span> <span class="toc-text">步骤 2：使用最小堆来维护前 k 高频率的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code%EF%BC%9A-1"><span class="toc-number">5.2.0.3.</span> <span class="toc-text">code：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">5.2.0.4.</span> <span class="toc-text">复杂度分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%952%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">解法2：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%953%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">解法3：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">数据流的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%951%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BC%9A%E8%B6%85%E6%97%B6%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">解法1：排序（会超时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%952%EF%BC%9A%E5%8F%8C%E5%A0%86%E6%B3%95"><span class="toc-number">5.3.2.</span> <span class="toc-text">解法2：双堆法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%953%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">5.3.3.</span> <span class="toc-text">解法3：双指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">6.4.</span> <span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">6.5.</span> <span class="toc-text">二叉树的层次遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">6.6.</span> <span class="toc-text">将有序的数组转换成二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">6.7.</span> <span class="toc-text">二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.8.</span> <span class="toc-text">判断完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.9.</span> <span class="toc-text">判断平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.10.</span> <span class="toc-text">前序和中序遍历构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.11.</span> <span class="toc-text">合并二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E7%9A%84%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B6%E7%BB%99%E5%87%BA%E5%8F%B3%E4%BE%A7%E8%A7%86%E5%9B%BE"><span class="toc-number">6.12.</span> <span class="toc-text">前序和中序的序列构造一棵二叉树并给出右侧视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">6.12.1.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">6.13.</span> <span class="toc-text">验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">6.14.</span> <span class="toc-text">二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">6.15.</span> <span class="toc-text">二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">6.16.</span> <span class="toc-text">二叉搜索树中第K小的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.16.1.</span> <span class="toc-text">方法一：中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E2%80%93%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">6.16.2.</span> <span class="toc-text">方法二–优化方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-number">6.17.</span> <span class="toc-text">二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.18.</span> <span class="toc-text">序列化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7%E8%A7%86%E5%9B%BE"><span class="toc-number">6.19.</span> <span class="toc-text">二叉树的右侧视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.19.1.</span> <span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">6.20.</span> <span class="toc-text">二叉树的镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%E2%80%93%E9%80%92%E5%BD%92"><span class="toc-number">6.20.1.</span> <span class="toc-text">方法1–递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%E2%80%93%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BD%BF%E7%94%A8%E6%A0%88%EF%BC%89"><span class="toc-number">6.20.2.</span> <span class="toc-text">方法2–迭代实现（使用栈）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-number">6.21.</span> <span class="toc-text">二叉树的直径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="toc-number">6.21.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">6.21.2.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">6.22.</span> <span class="toc-text">二叉树转为链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="toc-number">6.22.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">6.22.2.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">6.22.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">6.23.</span> <span class="toc-text">二叉树的路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-1"><span class="toc-number">6.23.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">6.23.2.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">6.23.3.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%E2%80%93%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">6.23.4.</span> <span class="toc-text">解法二–前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-2"><span class="toc-number">6.23.5.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-number">6.23.6.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">6.23.7.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E8%B7%AF%E5%BE%84"><span class="toc-number">6.24.</span> <span class="toc-text">二叉树的最近路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="toc-number">6.24.1.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">6.24.2.</span> <span class="toc-text">空间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">6.25.</span> <span class="toc-text">二叉树最大的路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-5"><span class="toc-number">6.25.1.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">6.25.2.</span> <span class="toc-text">空间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-1"><span class="toc-number">6.26.</span> <span class="toc-text">二叉搜索树与双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">6.26.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">7.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.0.1.</span> <span class="toc-text">回溯算法的基本步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">7.0.2.</span> <span class="toc-text">回溯算法的伪代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.0.3.</span> <span class="toc-text">回溯算法的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">7.0.4.</span> <span class="toc-text">回溯算法的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.0.5.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">7.1.</span> <span class="toc-text">全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-3"><span class="toc-number">7.1.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-6"><span class="toc-number">7.1.2.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">7.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97-1"><span class="toc-number">7.2.</span> <span class="toc-text">全排列||</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">7.2.1.</span> <span class="toc-text">解题思想：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">7.2.2.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">7.3.</span> <span class="toc-text">下一个排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">7.3.1.</span> <span class="toc-text">解题思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code%EF%BC%9A-2"><span class="toc-number">7.3.2.</span> <span class="toc-text">code：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="toc-number">7.3.3.</span> <span class="toc-text">复杂度分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">7.3.4.</span> <span class="toc-text">示例解释：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number">7.4.</span> <span class="toc-text">子集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-4"><span class="toc-number">7.4.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-5"><span class="toc-number">7.4.2.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">7.4.3.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">7.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">7.5.</span> <span class="toc-text">字母大小全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF"><span class="toc-number">7.5.1.</span> <span class="toc-text">解法一——回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="toc-number">7.5.1.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">7.5.1.2.</span> <span class="toc-text">实现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-number">7.5.1.3.</span> <span class="toc-text">代码说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-6"><span class="toc-number">7.5.1.4.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3"><span class="toc-number">7.5.2.</span> <span class="toc-text">解法二——迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.5.2.1.</span> <span class="toc-text">迭代解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-1"><span class="toc-number">7.5.2.2.</span> <span class="toc-text">实现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E-1"><span class="toc-number">7.5.2.3.</span> <span class="toc-text">代码说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-7"><span class="toc-number">7.5.2.4.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">7.5.3.</span> <span class="toc-text">方法比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">7.5.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">7.6.</span> <span class="toc-text">电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%88%B0%E5%AD%97%E6%AF%8D%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">7.6.1.</span> <span class="toc-text">数字到字母的映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5"><span class="toc-number">7.6.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">7.6.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">7.6.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">7.7.</span> <span class="toc-text">组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6"><span class="toc-number">7.7.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">7.7.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="toc-number">7.7.3.</span> <span class="toc-text">代码解释和改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="toc-number">7.7.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">7.7.5.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">7.8.</span> <span class="toc-text">括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-5"><span class="toc-number">7.8.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">7.8.2.</span> <span class="toc-text">时间复杂度分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">7.8.3.</span> <span class="toc-text">空间复杂度分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="toc-number">7.8.4.</span> <span class="toc-text">结论：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">7.9.</span> <span class="toc-text">单词搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3%EF%BC%9A-1"><span class="toc-number">7.9.1.</span> <span class="toc-text">解题思想：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code%EF%BC%9A-3"><span class="toc-number">7.9.2.</span> <span class="toc-text">code：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A-2"><span class="toc-number">7.9.3.</span> <span class="toc-text">复杂度分析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">7.10.</span> <span class="toc-text">分割回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-6"><span class="toc-number">7.10.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">7.10.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-5"><span class="toc-number">7.10.3.</span> <span class="toc-text">复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-8"><span class="toc-number">7.10.3.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">7.10.3.2.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">7.10.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N%E7%9A%87%E5%90%8E"><span class="toc-number">7.11.</span> <span class="toc-text">N皇后</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#code"><span class="toc-number">7.11.1.</span> <span class="toc-text">code:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-1"><span class="toc-number">7.11.2.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-6"><span class="toc-number">7.11.3.</span> <span class="toc-text">复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-9"><span class="toc-number">7.11.3.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-number">7.11.3.2.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">8.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">8.1.</span> <span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">8.2.</span> <span class="toc-text">字母异位词分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">缺失的第一个正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">8.4.</span> <span class="toc-text">最长连续序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-1"><span class="toc-number">8.5.</span> <span class="toc-text">盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">8.6.</span> <span class="toc-text">接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">8.7.</span> <span class="toc-text">无重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">8.8.</span> <span class="toc-text">最长无重复子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">8.9.</span> <span class="toc-text">最大子数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">8.10.</span> <span class="toc-text">和为K的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">8.10.1.</span> <span class="toc-text">解题方法：前缀和+哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.10.2.</span> <span class="toc-text">详细步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-10"><span class="toc-number">8.10.3.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-number">8.11.</span> <span class="toc-text">除自身以外数组的乘积</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%B8%A4%E6%AC%A1%EF%BC%8C%E9%80%BB%E8%BE%91%E6%B8%85%E6%99%B0"><span class="toc-number">8.11.1.</span> <span class="toc-text">遍历两次，逻辑清晰</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">8.12.</span> <span class="toc-text">合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">8.13.</span> <span class="toc-text">找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">8.14.</span> <span class="toc-text">滑动窗口最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="toc-number">8.15.</span> <span class="toc-text">最小的K个数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7"><span class="toc-number">8.15.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%E2%80%93%E6%8E%92%E5%BA%8F"><span class="toc-number">8.15.2.</span> <span class="toc-text">解法一–排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%E2%80%93%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89%E6%B3%95"><span class="toc-number">8.15.3.</span> <span class="toc-text">解法二–堆（优先队列）法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A0%86%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">8.15.3.1.</span> <span class="toc-text">基于堆的代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-11"><span class="toc-number">8.15.4.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0"><span class="toc-number">8.16.</span> <span class="toc-text">寻找第K大的数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E8%A7%A3%E6%B3%95%E2%80%93%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="toc-number">8.16.1.</span> <span class="toc-text">优化解法–快速选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.16.2.</span> <span class="toc-text">选择合适的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2"><span class="toc-number">8.17.</span> <span class="toc-text">最小覆盖字串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU%E7%BC%93%E5%AD%98-1"><span class="toc-number">8.18.</span> <span class="toc-text">LRU缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%80%8D%E6%95%B0%E5%AF%B9%E6%95%B0%E7%BB%84"><span class="toc-number">8.19.</span> <span class="toc-text">二倍数对数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8"><span class="toc-number">8.19.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.19.2.</span> <span class="toc-text">具体步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">8.19.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-7"><span class="toc-number">8.19.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">8.19.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">9.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">9.1.</span> <span class="toc-text">爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%952%E2%80%93%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">9.1.1.</span> <span class="toc-text">解法2–动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">9.2.</span> <span class="toc-text">杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-1"><span class="toc-number">9.3.</span> <span class="toc-text">杨辉三角 ||</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">9.4.</span> <span class="toc-text">打家劫舍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="toc-number">9.5.</span> <span class="toc-text">矩阵置零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">9.6.</span> <span class="toc-text">螺旋矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-number">9.7.</span> <span class="toc-text">旋转图像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-7"><span class="toc-number">9.7.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">9.7.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-1"><span class="toc-number">9.8.</span> <span class="toc-text">搜索二维矩阵 ||</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">9.8.1.</span> <span class="toc-text">具体步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-8"><span class="toc-number">9.8.2.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">9.8.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">9.9.</span> <span class="toc-text">分割等和子集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-2"><span class="toc-number">9.9.1.</span> <span class="toc-text">解释：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">9.10.</span> <span class="toc-text">最长有效括号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="toc-number">9.10.1.</span> <span class="toc-text">方法一：使用栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">9.10.1.1.</span> <span class="toc-text">步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code%EF%BC%9A-4"><span class="toc-number">9.10.1.2.</span> <span class="toc-text">code：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">9.10.2.</span> <span class="toc-text">方法二：动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A-1"><span class="toc-number">9.10.2.1.</span> <span class="toc-text">步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code%EF%BC%9A-5"><span class="toc-number">9.10.2.2.</span> <span class="toc-text">code：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">10.</span> <span class="toc-text">多维动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">10.1.</span> <span class="toc-text">不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95"><span class="toc-number">10.1.1.</span> <span class="toc-text">动态规划解法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">初始化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%EF%BC%9A"><span class="toc-number">10.1.1.2.</span> <span class="toc-text">状态转移：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">10.1.1.3.</span> <span class="toc-text">最终结果：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%9A-1"><span class="toc-number">10.1.1.4.</span> <span class="toc-text">实现代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-5"><span class="toc-number">10.1.2.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">10.2.</span> <span class="toc-text">最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-8"><span class="toc-number">10.2.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">10.2.2.</span> <span class="toc-text">时间和空间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">10.3.</span> <span class="toc-text">最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">10.3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-9"><span class="toc-number">10.3.2.</span> <span class="toc-text">解题思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%EF%BC%9A"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">动态规划的状态转移方程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A-3"><span class="toc-number">10.3.2.2.</span> <span class="toc-text">复杂度分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code%EF%BC%9A-6"><span class="toc-number">10.3.3.</span> <span class="toc-text">code：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-2"><span class="toc-number">10.3.4.</span> <span class="toc-text">代码解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">10.4.</span> <span class="toc-text">最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9"><span class="toc-number">10.4.1.</span> <span class="toc-text">解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">10.4.1.1.</span> <span class="toc-text">动态规划方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code%EF%BC%9A-7"><span class="toc-number">10.4.2.</span> <span class="toc-text">code：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">10.4.3.</span> <span class="toc-text">逐行代码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">10.4.4.</span> <span class="toc-text">时间复杂度和空间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">10.5.</span> <span class="toc-text">编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10"><span class="toc-number">10.5.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">11.1.</span> <span class="toc-text">买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">11.1.1.</span> <span class="toc-text">时间复杂度和空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">11.2.</span> <span class="toc-text">跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11"><span class="toc-number">11.2.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-9"><span class="toc-number">11.2.2.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-1"><span class="toc-number">11.3.</span> <span class="toc-text">跳跃游戏||</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">11.4.</span> <span class="toc-text">划分字母区间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-12"><span class="toc-number">11.4.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">11.4.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-10"><span class="toc-number">11.4.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8A"><span class="toc-number">11.4.4.</span> <span class="toc-text">示例解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">11.5.</span> <span class="toc-text">零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-10"><span class="toc-number">11.5.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-11"><span class="toc-number">11.5.2.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">11.6.</span> <span class="toc-text">单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-13"><span class="toc-number">11.6.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-12"><span class="toc-number">11.6.2.</span> <span class="toc-text">复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-1"><span class="toc-number">11.6.2.1.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8A-1"><span class="toc-number">11.6.3.</span> <span class="toc-text">示例解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.7.</span> <span class="toc-text">最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-14"><span class="toc-number">11.7.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-13"><span class="toc-number">11.7.2.</span> <span class="toc-text">复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code%EF%BC%9A-8"><span class="toc-number">11.7.2.1.</span> <span class="toc-text">code：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8A-2"><span class="toc-number">11.7.3.</span> <span class="toc-text">示例解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">11.8.</span> <span class="toc-text">乘积最大子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-15"><span class="toc-number">11.8.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-14"><span class="toc-number">11.8.2.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="toc-number">11.8.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8A-3"><span class="toc-number">11.8.4.</span> <span class="toc-text">示例解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">12.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89"><span class="toc-number">12.0.1.</span> <span class="toc-text">1. 深度优先搜索（DFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89"><span class="toc-number">12.0.2.</span> <span class="toc-text">2. 广度优先搜索（BFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">12.0.3.</span> <span class="toc-text">3. 最短路径算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">12.0.4.</span> <span class="toc-text">4. 最小生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">12.0.5.</span> <span class="toc-text">5. 拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%A3%80%E6%B5%8B"><span class="toc-number">12.0.6.</span> <span class="toc-text">6. 二分图检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84"><span class="toc-number">12.0.7.</span> <span class="toc-text">7. 欧拉回路与欧拉路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">12.0.8.</span> <span class="toc-text">8. 强连通分量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Bellman-Ford%E7%AE%97%E6%B3%95"><span class="toc-number">12.0.9.</span> <span class="toc-text">9. Bellman-Ford算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Floyd-Warshall%E7%AE%97%E6%B3%95"><span class="toc-number">12.0.10.</span> <span class="toc-text">10. Floyd-Warshall算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">12.1.</span> <span class="toc-text">岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">12.1.1.</span> <span class="toc-text">具体步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-6"><span class="toc-number">12.1.2.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="toc-number">12.2.</span> <span class="toc-text">腐烂的橘子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">12.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-16"><span class="toc-number">12.2.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code%EF%BC%9A-9"><span class="toc-number">12.2.3.</span> <span class="toc-text">code：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-7"><span class="toc-number">12.2.4.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-15"><span class="toc-number">12.2.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="toc-number">12.3.</span> <span class="toc-text">课程表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E6%83%B3-11"><span class="toc-number">12.3.1.</span> <span class="toc-text">解题思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-2"><span class="toc-number">12.3.2.</span> <span class="toc-text">code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-17"><span class="toc-number">12.3.3.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-16"><span class="toc-number">12.3.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">12.4.</span> <span class="toc-text">实现Trie(前缀树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.4.1.</span> <span class="toc-text">完整代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%92%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">12.4.2.</span> <span class="toc-text">解释和注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-17"><span class="toc-number">12.4.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/%E9%93%B6%E8%A1%8C/" title="银行"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="银行"/></a><div class="content"><a class="title" href="/2024/10/22/%E9%93%B6%E8%A1%8C/" title="银行">银行</a><time datetime="2024-10-22T02:15:44.000Z" title="发表于 2024-10-22 10:15:44">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/16/nodejs%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="nodejs面试笔记"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nodejs面试笔记"/></a><div class="content"><a class="title" href="/2024/10/16/nodejs%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" title="nodejs面试笔记">nodejs面试笔记</a><time datetime="2024-10-16T02:23:20.000Z" title="发表于 2024-10-16 10:23:20">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/16/%E5%B0%8F%E7%B1%B3/" title="小米"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小米"/></a><div class="content"><a class="title" href="/2024/10/16/%E5%B0%8F%E7%B1%B3/" title="小米">小米</a><time datetime="2024-10-16T02:12:12.000Z" title="发表于 2024-10-16 10:12:12">2024-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/" title="华为前端面试合集"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="华为前端面试合集"/></a><div class="content"><a class="title" href="/2024/10/15/%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/" title="华为前端面试合集">华为前端面试合集</a><time datetime="2024-10-15T08:35:34.000Z" title="发表于 2024-10-15 16:35:34">2024-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/14/%E6%95%B0%E5%AD%97/" title="数字"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数字"/></a><div class="content"><a class="title" href="/2024/10/14/%E6%95%B0%E5%AD%97/" title="数字">数字</a><time datetime="2024-10-14T08:44:56.000Z" title="发表于 2024-10-14 16:44:56">2024-10-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 流泪猫猫头</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>